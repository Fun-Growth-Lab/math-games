<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ë∂≥„ÅóÁÆó„Éë„Ç∫„É´ - Tally Blitz</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f4f8;
            font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #left-panel, #right-panel {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        #left-panel { flex: 0.8; justify-content: center; }
        #right-panel { flex: 1.2; align-items: center; justify-content: flex-start; }
        
        #game-area {
            flex: 2.5;
            position: relative;
            background-color: #ecf0f1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0,0,0,0.2);
            background-color: #34495e;
            border-radius: 4px;
        }
        h2 { margin-top: 0; border-bottom: 2px solid #3498db; padding-bottom: 5px; font-size: 1.1rem; width: 100%; }
        
        #right-panel-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* NEXT„Éñ„É≠„ÉÉ„ÇØË°®Á§∫„Ç®„É™„Ç¢ */
        #next-block-area {
            width: 100%;
            height: 140px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        #next-label { 
            font-size: 1rem; 
            color: #bdc3c7; 
            position: absolute; 
            top: 5px; 
            left: 10px; 
            font-weight: bold;
        }
        #next-canvas { margin-top: 15px; }

        .info-group { width: 100%; margin-bottom: 10px; text-align: center; }
        .info-item { 
            margin-bottom: 15px; 
            display: flex; 
            flex-direction: column; 
            align-items: center;
            border-bottom: 1px dashed rgba(255,255,255,0.1);
            padding-bottom: 5px;
        }
        .info-label { font-size: 0.9rem; color: #bdc3c7; margin-bottom: 2px; }
        .info-value { font-size: 2.0rem; font-weight: 800; line-height: 1; text-shadow: 1px 1px 0 rgba(0,0,0,0.3); }
        
        #disp-level { color: #3498db; }
        #disp-combo { color: #e74c3c; font-size: 2.4rem; }
        #disp-score { color: #f1c40f; }

        .btn {
            background-color: #3498db; color: white; border: none; padding: 12px 15px;
            border-radius: 8px; cursor: pointer; font-size: 1rem; margin: 5px;
            transition: transform 0.1s;
            box-shadow: 0 4px 0 #2980b9;
            -webkit-tap-highlight-color: transparent;
            font-weight: bold;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .btn-danger { background-color: #e74c3c; box-shadow: 0 4px 0 #c0392b; }
        .btn-success { background-color: #2ecc71; box-shadow: 0 4px 0 #27ae60; }
        .btn-warning { background-color: #f1c40f; box-shadow: 0 4px 0 #d35400; color: #333; }
        
        .btn-auth {
            background-color: #4285F4; 
            box-shadow: 0 4px 0 #3367D6;
            color: white; 
            padding: 12px; 
            font-weight: bold; 
            width: 100%; 
            margin-top: 10px; 
            font-size: 1rem;
            display: flex; justify-content: center; align-items: center;
            gap: 10px;
        }

        #overlay, #ranking-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            flex-direction: column;
            color: white;
        }
        .overlay-content {
            background: #34495e; padding: 25px; border-radius: 16px;
            text-align: center; 
            width: 90%; 
            max-width: 550px;
            max-height: 90vh; overflow-y: auto;
            border: 4px solid #2c3e50;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        
        .hidden { display: none !important; }

        /* „Çø„Ç§„Éà„É´ÁîªÈù¢ */
        .difficulty-container {
            display: flex; justify-content: center; gap: 10px; margin-bottom: 25px; align-items: flex-end; width: 100%;
        }
        .diff-wrapper { 
            display: flex; flex-direction: column; align-items: center; 
            flex: 1; 
            max-width: 120px;
        }
        .diff-wrapper .btn {
            white-space: nowrap;
            width: 100%;
            padding: 12px 5px;
            font-size: 0.95rem;
            margin: 5px 0;
        }
        .crown-icon { font-size: 1.8rem; margin-bottom: 5px; visibility: hidden; }
        .clear-count-text { font-size: 1rem; color: #555; font-weight: bold; margin-top: 5px; }
        #title-screen { background: rgba(255,255,255,0.95); color: #333; }

        /* „É©„É≥„Ç≠„É≥„Ç∞ */
        .ranking-container { display: flex; gap: 5px; margin-bottom: 10px; height: 250px; }
        .ranking-box { background: #2c3e50; padding: 5px; border-radius: 5px; flex: 1; overflow-y: auto; border: 1px solid #7f8c8d; }
        .ranking-list { list-style: none; padding: 0; margin: 0; font-size: 0.8rem; text-align: left; }
        .ranking-list li { border-bottom: 1px dashed #444; padding: 3px 0; display:flex; justify-content:space-between; }

        /* Êìç‰Ωú„Éú„Çø„É≥ */
        #puzzle-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            margin-top: auto;
            width: 100%;
            max-width: 250px;
        }
        .ctrl-btn {
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.5);
            color: white;
            border-radius: 12px;
            font-size: 1.8rem;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
            height: 65px;
            user-select: none;
            transition: background 0.1s;
        }
        .ctrl-btn:active { background: rgba(255,255,255,0.4); }
        #btn-left { grid-column: 1; grid-row: 1; }
        #btn-rotate { grid-column: 2; grid-row: 1; color: #f1c40f; }
        #btn-right { grid-column: 3; grid-row: 1; }
        #btn-drop { 
            grid-column: 1 / span 3; grid-row: 2; 
            background-color: #e74c3c; border-color: #c0392b; 
            font-weight: bold; font-size: 1.5rem;
        }

        /* „É¨„Çπ„Éù„É≥„Ç∑„ÉñË™øÊï¥ */
        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #left-panel { display: none; }
            #game-area { flex: 3; }
            #right-panel { 
                flex: 1.2; flex-direction: row; 
                padding: 10px; align-items: center; 
                justify-content: space-between;
                border-top: 4px solid #34495e;
            }
            #right-panel-content { 
                width: 45%; 
                font-size: 0.8rem; 
                align-items: flex-start;
            }
            #next-block-area { 
                width: 90px; height: 90px; margin-bottom: 0; margin-right: 10px;
                position: absolute; top: 10px; left: 10px; display: none;
            }
            .info-group { 
                display: flex; flex-direction: row; gap: 10px; margin-bottom: 0; text-align: left;
            }
            .info-item { border: none; align-items: flex-start; margin-bottom: 0; }
            .info-value { font-size: 1.5rem; }
            
            #puzzle-controls { width: 50%; height: 100%; gap: 8px; margin: 0;}
            .ctrl-btn { height: 100%; font-size: 1.5rem; border-radius: 8px;}
        }
    </style>
</head>
<body>

<div id="container">
    <div id="left-panel">
        <h2>„ÅÇ„Åù„Å≥„Åã„Åü</h2>
        <div style="font-size: 0.9rem; line-height: 1.6;">
            <p>1. <strong>„Åô„ÅÜ„Åò</strong>„Çí„Åä„Å®„Åó„Å¶<br>„Åó„Åü„ÅÆ„Éñ„É≠„ÉÉ„ÇØ„Å®<br>„Åü„Åó„Åñ„Çì „Åô„Çã„ÇàÔºÅ</p>
            <p>2. „Åü„Åó„Å¶<strong>„Äå10„Äç</strong>„Å´<br>„Å™„Çã„Å® „Åç„Åà„Çã„ÇàÔºÅ</p>
            <p>3. <strong>10„Çà„Çä „Å°„ÅÑ„Åï„ÅÑ</strong>„Å®<br>„Åå„Å£„Åü„ÅÑ „Åó„Å¶<br>„Åô„ÅÜ„Åò„Åå „Åµ„Åà„Çã„Çà„ÄÇ</p>
            <p>4. <strong>11„ÅÑ„Åò„Çá„ÅÜ</strong>„ÅØ<br>„Åä„Åò„ÇÉ„Åæ„Éñ„É≠„ÉÉ„ÇØ„Å´<br>„Å™„Å£„Å°„ÇÉ„ÅÜ„Åû„ÄÇ</p>
            <p>5. <strong>„Åã„ÅÑ„Å¶„Çì</strong>„Çí„Å§„Åã„Å£„Å¶<br>„ÅÜ„Åæ„Åè „Å§„ÇÇ„ÅÜÔºÅ</p>
        </div>
        <div style="margin-top:auto; text-align:center;">
            <button id="btn-to-title" class="btn btn-danger hidden">„Çø„Ç§„Éà„É´„Å∏</button>
        </div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas"></canvas>

        <div id="title-screen" class="overlay-content" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:10; width: 95%; max-width: 550px;">
            <h1 style="font-size:3rem; margin:0 0 10px 0; color:#c0392b; font-family: 'M PLUS Rounded 1c', sans-serif;">TALLY BLITZ</h1>
            <p style="font-size:1.2rem; margin-top:0; margin-bottom:30px; font-weight:bold; color:#555;">- „Åü„Åó„Åñ„Çì„Éë„Ç∫„É´ -</p>
            
            <div class="difficulty-container">
                <div class="diff-wrapper">
                    <div id="crown-easy" class="crown-icon">üëë</div>
                    <button id="btn-easy" class="btn btn-success">„Åó„Çá„Åç„ÇÖ„ÅÜ</button>
                    <div id="clear-easy" class="clear-count-text">0Âõû„Éó„É¨„Ç§</div>
                </div>
                <div class="diff-wrapper">
                    <div id="crown-normal" class="crown-icon">üëë</div>
                    <button id="btn-normal" class="btn">„Å°„ÇÖ„ÅÜ„Åç„ÇÖ„ÅÜ</button>
                    <div id="clear-normal" class="clear-count-text">0Âõû„Éó„É¨„Ç§</div>
                </div>
                <div class="diff-wrapper">
                    <div id="crown-hard" class="crown-icon">üëë</div>
                    <button id="btn-hard" class="btn btn-danger">„Åò„Çá„ÅÜ„Åç„ÇÖ„ÅÜ</button>
                    <div id="clear-hard" class="clear-count-text">0Âõû„Éó„É¨„Ç§</div>
                </div>
            </div>

            <button id="btn-view-ranking" class="btn btn-warning" style="width: 80%; max-width: 300px; font-weight:bold;">„É©„É≥„Ç≠„É≥„Ç∞</button>
            
            <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top:15px; width:100%;">
                <p id="auth-status" style="margin: 0 0 5px 0; font-size: 0.9rem; color: #777;">Êú™„É≠„Ç∞„Ç§„É≥</p>
                <button id="btn-login" class="btn btn-auth" style="max-width: 300px; margin: 10px auto;">
                    <span>G</span> Google„Åß„É≠„Ç∞„Ç§„É≥
                </button>
                <button id="btn-logout" class="btn btn-danger hidden" style="width: 80%; max-width: 300px;">„É≠„Ç∞„Ç¢„Ç¶„Éà</button>
            </div>
            
            <button id="btn-index" class="btn" style="background-color: #7f8c8d; margin-top: 15px; width: 80%; max-width: 300px;">INDEX„Å∏Êàª„Çã</button>
        </div>

        <div id="game-result" style="display: none; position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index: 20; width: 85%; max-width: 400px;">
        </div>

        <div id="ranking-screen" class="hidden">
            <div id="ranking-overlay">
                <div class="overlay-content">
                    <h2 id="ranking-header-title" style="color: #f1c40f;">„É©„É≥„Ç≠„É≥„Ç∞</h2>
                    <div class="ranking-container">
                        <div class="ranking-box">
                            <div style="color:#2ecc71; font-weight:bold;">ÂàùÁ¥ö</div>
                            <ul id="rank-list-easy" class="ranking-list"></ul>
                        </div>
                        <div class="ranking-box">
                            <div style="color:#3498db; font-weight:bold;">‰∏≠Á¥ö</div>
                            <ul id="rank-list-normal" class="ranking-list"></ul>
                        </div>
                        <div class="ranking-box">
                            <div style="color:#e74c3c; font-weight:bold;">‰∏äÁ¥ö</div>
                            <ul id="rank-list-hard" class="ranking-list"></ul>
                        </div>
                    </div>
                    <button id="btn-close-ranking" class="btn">„Å®„Åò„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <div id="right-panel">
        <div id="right-panel-content">
            <div id="next-block-area">
                <div id="next-label">„Å§„Åé</div>
                <canvas id="nextCanvas" width="220" height="80"></canvas>
            </div>

            <div class="info-group">
                <div class="info-item">
                    <span class="info-label">LEVEL</span>
                    <span id="disp-level" class="info-value">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">COMBO</span>
                    <span id="disp-combo" class="info-value">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">SCORE</span>
                    <span id="disp-score" class="info-value">0</span>
                </div>
            </div>
        </div>

        <div id="puzzle-controls" class="hidden">
            <div class="ctrl-btn" id="btn-left">‚óÄ</div>
            <div class="ctrl-btn" id="btn-rotate">‚Üª</div>
            <div class="ctrl-btn" id="btn-right">‚ñ∂</div>
            <div class="ctrl-btn" id="btn-drop">‚Üì</div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, serverTimestamp, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
      authDomain: "math-braves.firebaseapp.com",
      projectId: "math-braves",
      storageBucket: "math-braves.firebasestorage.app",
      messagingSenderId: "217117619290",
      appId: "1:217117619290:web:d227feb603970d3948d463"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    window.currentUser = null; 

    const btnLogin = document.getElementById('btn-login');
    const btnLogout = document.getElementById('btn-logout');
    const authStatus = document.getElementById('auth-status');

    window.handleLogin = function() {
        signInWithPopup(auth, provider)
            .then((result) => { console.log("Login Success"); })
            .catch((error) => { console.error("Login Error", error); alert("„É≠„Ç∞„Ç§„É≥Â§±Êïó"); });
    };

    window.handleLogout = function() {
        signOut(auth).then(() => { console.log("Logout Success"); });
    };

    if(btnLogin) btnLogin.onclick = window.handleLogin;
    if(btnLogout) btnLogout.onclick = window.handleLogout;

    onAuthStateChanged(auth, (user) => {
        if (user) {
            window.currentUser = { uid: user.uid, displayName: user.displayName || 'ÂêçÁÑ°„Åó„Åï„Çì' };
            if(authStatus) authStatus.textContent = `Login: ${window.currentUser.displayName}`;
            if(btnLogin) btnLogin.classList.add('hidden');
            if(btnLogout) btnLogout.classList.remove('hidden');
        } else {
            window.currentUser = null;
            if(authStatus) authStatus.textContent = 'Êú™„É≠„Ç∞„Ç§„É≥';
            if(btnLogin) btnLogin.classList.remove('hidden');
            if(btnLogout) btnLogout.classList.add('hidden');
        }
    });

    const COLLECTION_NAME = "scores_Tally_Blitz_addition";

    window.saveOnlineScore = async (userId, userName, difficulty, score) => {
        try {
            const docId = `${userId}_${difficulty}_${Date.now()}`;
            await setDoc(doc(db, COLLECTION_NAME, docId), {
                uid: userId,
                name: userName,
                difficulty: difficulty,
                score: score,
                createdAt: serverTimestamp()
            });
        } catch (error) { console.error(error); }
    };

    window.fetchOnlineRanking = async (difficulty) => {
        if (!window.currentUser) return [];
        try {
            const scoresRef = collection(db, COLLECTION_NAME);
            const q = query(
                scoresRef, 
                where("difficulty", "==", difficulty), 
                orderBy("score", "desc"), 
                limit(10)
            );
            const querySnapshot = await getDocs(q);
            const ranking = [];
            querySnapshot.forEach((doc) => ranking.push(doc.data()));
            return ranking;
        } catch (error) { console.error(error); return []; }
    };
</script>

<script>
/**
 * Game Configuration & Logic
 */
const CROWN_THRESHOLDS = { BRONZE: 2000, SILVER: 5000, GOLD: 10000 };

// Èõ£ÊòìÂ∫¶„ÉªÂá∫Áèæ„Éñ„É≠„ÉÉ„ÇØÊï∞Ë®≠ÂÆö
const CONFIGS = {
    EASY: { 
        label: "„Åó„Çá„Åç„ÇÖ„ÅÜ", 
        floorRows: 2, 
        dropStages: [
            { count: 30, size: 2 }, 
            { count: 40, size: 3 }, 
            { count: Infinity, size: 4 }
        ] 
    },
    NORMAL: { 
        label: "„Å°„ÇÖ„ÅÜ„Åç„ÇÖ„ÅÜ", 
        floorRows: 3, 
        dropStages: [
            { count: 20, size: 2 }, 
            { count: 30, size: 3 }, 
            { count: Infinity, size: 4 } 
        ]
    },
    HARD: { 
        label: "„Åò„Çá„ÅÜ„Åç„ÇÖ„ÅÜ", 
        floorRows: 4, 
        dropStages: [
            { count: 10, size: 2 }, 
            { count: 20, size: 3 }, 
            { count: Infinity, size: 4 } 
        ]
    }
};

const COLS = 5;
const ROWS = 8;
const BLOCK_VAL_OBSTACLE = 99;
const NEXT_BLOCK_SIZE = 50; 

let currentConfig = CONFIGS.NORMAL;
let state = {
    screen: 'TITLE', difficulty: 'NORMAL',
    score: 0, combo: 0, dropCount: 0,
    grid: [], 
    activeBlock: null, 
    nextBlockValues: [],
    particles: [],
    comboAnim: null, 
    inputLocked: false,
    width: 0, height: 0, blockSize: 40, boardX: 0, boardY: 0,
    timerId: null 
};

// UI References
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas');
const nextCtx = nextCanvas.getContext('2d');
const ui = {
    score: document.getElementById('disp-score'),
    combo: document.getElementById('disp-combo'),
    level: document.getElementById('disp-level'),
    title: document.getElementById('title-screen'),
    result: document.getElementById('game-result'),
    rankingScreen: document.getElementById('ranking-screen'),
    controls: document.getElementById('puzzle-controls'),
    btnToTitle: document.getElementById('btn-to-title'),
    btnEasy: document.getElementById('btn-easy'),
    btnNormal: document.getElementById('btn-normal'),
    btnHard: document.getElementById('btn-hard'),
    btnRanking: document.getElementById('btn-view-ranking'),
    btnCloseRank: document.getElementById('btn-close-ranking'),
    btnIndex: document.getElementById('btn-index'),
    crowns: { EASY: document.getElementById('crown-easy'), NORMAL: document.getElementById('crown-normal'), HARD: document.getElementById('crown-hard') },
    clears: { EASY: document.getElementById('clear-easy'), NORMAL: document.getElementById('clear-normal'), HARD: document.getElementById('clear-hard') }
};

// Helper: Resizing
function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    state.width = rect.width;
    state.height = rect.height;
    canvas.width = state.width;
    canvas.height = state.height;
    
    // Áõ§Èù¢„Ç®„É™„Ç¢Ë®àÁÆó
    const paddingTop = 60; 
    const availableH = state.height - paddingTop;
    const availableW = state.width;
    const sizeByH = availableH / (ROWS + 0.5);
    const sizeByW = availableW / (COLS + 1);
    state.blockSize = Math.min(sizeByH, sizeByW);

    state.boardW = state.blockSize * COLS;
    state.boardH = state.blockSize * ROWS;
    state.boardX = (state.width - state.boardW) / 2;
    state.boardY = paddingTop + (availableH - state.boardH) / 2;
}
window.addEventListener('resize', resize);
resize();

function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

// Helper: LocalStorage
function getRankingKey(d) { return `tally_blitz_v3_rank_${d}`; }
function getClearKey(d) { return `tally_blitz_v3_clear_${d}`; }
function getLocalRanking(d) { return JSON.parse(localStorage.getItem(getRankingKey(d))) || []; }
function getClearCount(d) { return parseInt(localStorage.getItem(getClearKey(d))) || 0; }
function saveScore(d, s) {
    let r = getLocalRanking(d);
    r.push(s); r.sort((a,b)=>b-a); r = r.slice(0,10);
    localStorage.setItem(getRankingKey(d), JSON.stringify(r));
    if(window.currentUser && window.saveOnlineScore) window.saveOnlineScore(window.currentUser.uid, window.currentUser.displayName, d, s);
}
function incrementClear(d) {
    let c = getClearCount(d) + 1;
    localStorage.setItem(getClearKey(d), c);
    return c;
}
function updateTitleStats() {
    ['EASY','NORMAL','HARD'].forEach(d => {
        const c = getClearCount(d);
        ui.clears[d].textContent = `${c}Âõû„Éó„É¨„Ç§`;
        const best = getLocalRanking(d)[0] || 0;
        const crown = ui.crowns[d];
        const th = CONFIGS[d].thresholds || CROWN_THRESHOLDS;
        crown.style.visibility = 'visible';
        if(best >= th.GOLD) { crown.textContent='üëë'; crown.style.color='gold'; crown.style.filter='drop-shadow(0 0 5px gold)'; }
        else if(best >= th.SILVER) { crown.textContent='üëë'; crown.style.color='silver'; crown.style.filter='drop-shadow(0 0 5px silver)'; }
        else if(best >= th.BRONZE) { crown.textContent='üëë'; crown.style.color='#cd7f32'; }
        else crown.style.visibility = 'hidden';
    });
}

/**
 * Block Logic (Rotation & Position)
 */
function getBlockOffsets(rot, len) {
    const offsets = [];
    for(let i=0; i<len; i++) {
        let dx = 0, dy = 0;
        if(rot === 0) { dx = i; dy = 0; }
        else if(rot === 1) { dx = 0; dy = i; }
        else if(rot === 2) { dx = -i; dy = 0; }
        else if(rot === 3) { dx = 0; dy = -i; }
        offsets.push({dx, dy});
    }
    return offsets;
}

function getOccupiedCells(bx, by, rot, len) {
    const offsets = getBlockOffsets(rot, len);
    return offsets.map(o => ({x: bx + o.dx, y: by + o.dy}));
}

function canPlace(bx, by, rot, values) {
    const cells = getOccupiedCells(bx, by, rot, values.length);
    for(let c of cells) {
        if(c.x < 0 || c.x >= COLS) return false;
        if(c.y >= ROWS) return false;
        if(c.y >= 0 && state.grid[c.y][c.x] !== 0) return false;
    }
    return true;
}

/**
 * Game Flow
 */
function initGrid() {
    state.grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    const floorR = currentConfig.floorRows;
    for(let i=0; i<floorR; i++) {
        const r = ROWS - 1 - i;
        for(let c=0; c<COLS; c++) state.grid[r][c] = BLOCK_VAL_OBSTACLE;
    }
    const numRow = ROWS - 1 - floorR;
    if(numRow >= 0) {
        for(let c=0; c<COLS; c++) state.grid[numRow][c] = randomInt(1, 9);
    }
}

function generateBlockValues() {
    state.dropCount++;
    let size = 2;
    let acc = 0;
    for(let stage of currentConfig.dropStages) {
        if(state.dropCount <= acc + stage.count) { size = stage.size; break; }
        acc += stage.count;
    }
    const arr = [];
    for(let i=0; i<size; i++) arr.push(randomInt(1,9));
    return arr;
}

function spawnBlock() {
    if(state.nextBlockValues.length === 0) state.nextBlockValues = generateBlockValues();
    
    const values = [...state.nextBlockValues];
    state.activeBlock = {
        x: Math.floor(COLS/2)-1,
        y: 0, 
        values: values,
        rot: 0
    };
    
    state.nextBlockValues = generateBlockValues();
    drawNextBlock();

    if(!canPlace(state.activeBlock.x, state.activeBlock.y, state.activeBlock.rot, state.activeBlock.values)) {
        gameOver();
    }
}

function rotateBlock() {
    if(!state.activeBlock || state.inputLocked) return;
    const b = state.activeBlock;
    const nextRot = (b.rot + 1) % 4;
    const len = b.values.length;

    let baseDy = 0;
    
    // --- ‰øÆÊ≠£: ÂõûËª¢ÊôÇ„ÅÆ‰∏ä‰∏ãÁßªÂãï„É≠„Ç∏„ÉÉ„ÇØ ---
    // Rot 0 -> 1: Ê®™„Åã„Çâ‰∏ãÂêë„Åç„ÄÇ‰∏ã„Å´Á™Å„ÅçÂá∫„ÅôÂàÜ„Çí‰∏ä„Å´ÊåÅ„Å°‰∏ä„Åí„Çã„ÄÇ
    if (b.rot === 0 && nextRot === 1) {
        baseDy = -(len - 1);
    }
    // Rot 1 -> 2: ‰∏ãÂêë„Åç„Åã„ÇâÊ®™(Â∑¶)„ÄÇ‰∏ä„Å´ÊåÅ„Å°‰∏ä„Åí„Å¶„ÅÑ„ÅüÂàÜ„ÇíÊàª„Åô„ÄÇ
    else if (b.rot === 1 && nextRot === 2) {
        baseDy = (len - 1);
    }
    // Rot 2 -> 3: Ê®™(Â∑¶)„Åã„Çâ‰∏äÂêë„Åç„ÄÇ‰∏ä„Å´‰º∏„Å≥„ÇãÂΩ¢„Å™„ÅÆ„Åß„ÄÅ‰ΩçÁΩÆ„ÅØ„Åö„Çâ„Åï„Å™„ÅÑ„ÄÇ
    // Rot 3 -> 0: ‰∏äÂêë„Åç„Åã„ÇâÊ®™(Âè≥)„ÄÇ‰ΩçÁΩÆ„ÅØ„Åö„Çâ„Åï„Å™„ÅÑ„ÄÇ

    // Ë©¶Ë°åÈ†Ü:
    // 1. Ë¶èÂÆö„ÅÆ‰∏ä‰∏ãÁßªÂãï (baseDy)
    // 2. „Åù„ÅÆÂ†¥ÂõûËª¢ („Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ)
    // 3. Â∑¶Âè≥Â£ÅËπ¥„Çä
    const moves = [
        {dx: 0, dy: baseDy},
        {dx: 0, dy: 0},
        {dx: -1, dy: baseDy}, {dx: 1, dy: baseDy},
        {dx: -1, dy: 0}, {dx: 1, dy: 0},
        {dx: -2, dy: baseDy}, {dx: 2, dy: baseDy}
    ];

    for(let m of moves) {
        if(canPlace(b.x + m.dx, b.y + m.dy, nextRot, b.values)) {
            b.x += m.dx;
            b.y += m.dy;
            b.rot = nextRot;
            return;
        }
    }
}

function moveBlock(dir) {
    if(!state.activeBlock || state.inputLocked) return;
    const b = state.activeBlock;
    if(canPlace(b.x + dir, b.y, b.rot, b.values)) {
        b.x += dir;
    }
}

function dropBlock() {
    if(!state.activeBlock || state.inputLocked) return;
    state.inputLocked = true;

    const b = state.activeBlock;
    let dy = 0;
    while(canPlace(b.x, b.y + dy + 1, b.rot, b.values)) {
        dy++;
    }
    
    const cells = getOccupiedCells(b.x, b.y + dy, b.rot, b.values.length);
    cells.forEach((c, i) => {
        if(c.y >= 0) state.grid[c.y][c.x] = b.values[i];
    });
    
    state.activeBlock = null;
    draw();
    
    if(state.timerId) clearTimeout(state.timerId);
    state.timerId = setTimeout(() => {
        processTurn();
    }, 100); 
}

// „Çø„Éº„É≥Âá¶ÁêÜ
async function processTurn() {
    let totalTens = 0; 
    
    outerLoop:
    while(true) {
        if(await applyGravity()) {
            await wait(100); 
            draw();
        }

        let changeOccurred = false;

        for(let c=0; c<COLS; c++) {
            for(let r=ROWS-2; r>=0; r--) {
                const upper = state.grid[r][c];
                const lower = state.grid[r+1][c];

                if(upper > 0 && lower > 0 && upper !== BLOCK_VAL_OBSTACLE && lower !== BLOCK_VAL_OBSTACLE) {
                    const sum = upper + lower;
                    
                    if(sum < 10) {
                        state.grid[r+1][c] = sum;
                        state.grid[r][c] = 0;
                        spawnParticle(c, r+1, "Âêà‰Ωì!", "#3498db");
                        changeOccurred = true;
                    } else if(sum === 10) {
                        state.grid[r+1][c] = 0;
                        state.grid[r][c] = 0;
                        
                        let bonus = 0;
                        if(r+2 < ROWS && state.grid[r+2][c] === BLOCK_VAL_OBSTACLE) {
                            state.grid[r+2][c] = 0;
                            spawnParticle(c, r+2, "Break!", "#e74c3c");
                            bonus = 10;
                        }

                        state.combo++;
                        totalTens++;

                        let point = (10 + bonus) * (1 + 0.2 * state.combo);
                        point = Math.floor(point);
                        state.score += point;

                        spawnParticle(c, r+0.5, "10!", "#f1c40f");
                        spawnParticle(2, 3, `+${point}`, "#f1c40f");

                        changeOccurred = true;
                        showComboAnim(state.combo + " COMBO!");
                    } else {
                        if(lower !== BLOCK_VAL_OBSTACLE) { 
                            state.grid[r+1][c] = BLOCK_VAL_OBSTACLE;
                            state.grid[r][c] = sum - 10;
                            spawnParticle(c, r+1, "Over!", "#95a5a6");
                            changeOccurred = true;
                        }
                    }

                    if(changeOccurred) {
                        draw();
                        updateUI();
                        await wait(300); 
                        continue outerLoop; 
                    }
                }
            }
        }

        if(!changeOccurred) break; 
    }

    if(totalTens === 0) {
        state.combo = 0;
    }

    updateUI();

    for(let c=0; c<COLS; c++) {
        if(state.grid[0][c] !== 0) {
            gameOver();
            return;
        }
    }

    state.inputLocked = false;
    spawnBlock();
}

async function applyGravity() {
    let moved = false;
    for(let c=0; c<COLS; c++) {
        for(let r=ROWS-2; r>=0; r--) {
            if(state.grid[r][c] !== 0 && state.grid[r+1][c] === 0) {
                let k = r;
                while(k+1 < ROWS && state.grid[k+1][c] === 0) {
                    state.grid[k+1][c] = state.grid[k][c];
                    state.grid[k][c] = 0;
                    k++;
                    moved = true;
                }
            }
        }
    }
    return moved;
}

function showComboAnim(text) {
    state.comboAnim = {
        text: text,
        life: 1.0 
    };
}

function wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

/**
 * Visuals
 */
class Particle {
    constructor(c, r, text, color) {
        this.x = state.boardX + c * state.blockSize + state.blockSize/2;
        this.y = state.boardY + r * state.blockSize + state.blockSize/2;
        this.text = text; this.color = color;
        this.life = 1.0; this.vy = -1;
    }
    update() { this.y += this.vy; this.life -= 0.02; }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.strokeStyle = "white";
        ctx.font = "bold 20px sans-serif";
        ctx.lineWidth = 3;
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}
function spawnParticle(c, r, text, color) {
    state.particles.push(new Particle(c, r, text, color));
}

function draw() {
    ctx.clearRect(0, 0, state.width, state.height);
    
    ctx.fillStyle = "#2c3e50";
    ctx.fillRect(state.boardX, state.boardY, state.boardW, state.boardH);

    ctx.beginPath();
    ctx.strokeStyle = "#34495e";
    ctx.lineWidth = 1;
    for(let i=0; i<=ROWS; i++) {
        let y = state.boardY + i*state.blockSize;
        ctx.moveTo(state.boardX, y); ctx.lineTo(state.boardX+state.boardW, y);
    }
    for(let i=0; i<=COLS; i++) {
        let x = state.boardX + i*state.blockSize;
        ctx.moveTo(x, state.boardY); ctx.lineTo(x, state.boardY+state.boardH);
    }
    ctx.stroke();

    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(state.grid[r][c] !== 0) drawBlock(ctx, c, r, state.grid[r][c]);
        }
    }

    if(state.activeBlock) {
        const b = state.activeBlock;
        const cells = getOccupiedCells(b.x, b.y, b.rot, b.values.length);
        
        let dy = 0;
        while(canPlace(b.x, b.y + dy + 1, b.rot, b.values)) dy++;
        const ghostCells = getOccupiedCells(b.x, b.y + dy, b.rot, b.values.length);
        
        ctx.globalAlpha = 0.2;
        ghostCells.forEach((c, i) => drawBlock(ctx, c.x, c.y, b.values[i]));
        ctx.globalAlpha = 1.0;

        cells.forEach((c, i) => drawBlock(ctx, c.x, c.y, b.values[i], true));
    }

    for(let i=state.particles.length-1; i>=0; i--) {
        let p = state.particles[i];
        p.update();
        p.draw(ctx);
        if(p.life <= 0) state.particles.splice(i,1);
    }
    
    if(state.comboAnim) {
        const anim = state.comboAnim;
        ctx.save();
        ctx.translate(state.width/2, state.height/2);
        let scale = 1 + Math.sin(anim.life * Math.PI) * 0.2;
        ctx.scale(scale, scale);
        
        ctx.globalAlpha = Math.min(1.0, anim.life);
        
        ctx.fillStyle = "#f1c40f";
        ctx.strokeStyle = "#fff";
        ctx.font = "900 60px 'M PLUS Rounded 1c', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineWidth = 5;
        ctx.strokeText(anim.text, 0, 0);
        ctx.fillText(anim.text, 0, 0);
        ctx.restore();
        ctx.globalAlpha = 1.0;
        
        anim.life -= 0.008; 
        if(anim.life <= 0) state.comboAnim = null;
    }

    requestAnimationFrame(draw);
}

function drawBlock(ctx, c, r, val, isActive=false) {
    const x = state.boardX + c * state.blockSize;
    const y = state.boardY + r * state.blockSize;
    const s = state.blockSize;
    const p = 3;

    let bg = "#ecf0f1";
    let fg = "#2c3e50";
    if(val === BLOCK_VAL_OBSTACLE) { bg = "#95a5a6"; }
    else {
        const colors = ["#FF6B6B", "#4ECDC4", "#FFD166", "#6BFFB8", "#A560E8", "#FF9F43", "#54A0FF", "#1DD1A1", "#F368E0"];
        if(val >= 1 && val <= 9) bg = colors[val-1];
        fg = "#fff";
    }

    if(isActive) {
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowBlur = 10;
        ctx.zIndex = 10;
    }

    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.roundRect(x+p, y+p, s-p*2, s-p*2, 6);
    ctx.fill();
    ctx.shadowBlur = 0;

    if(val === BLOCK_VAL_OBSTACLE) {
        ctx.strokeStyle = "#7f8c8d";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x+p+5, y+p+5); ctx.lineTo(x+s-p-5, y+s-p-5);
        ctx.moveTo(x+s-p-5, y+p+5); ctx.lineTo(x+p+5, y+s-p-5);
        ctx.stroke();
    } else {
        ctx.fillStyle = fg;
        ctx.font = `bold ${s*0.6}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(val, x+s/2, y+s/2+2);
    }
}

function drawNextBlock() {
    nextCtx.clearRect(0,0,nextCanvas.width, nextCanvas.height);
    const vals = state.nextBlockValues;
    if(!vals || vals.length===0) return;

    const bSize = NEXT_BLOCK_SIZE; // 50px
    const totalW = vals.length * bSize;
    const startX = (nextCanvas.width - totalW)/2;
    const startY = (nextCanvas.height - bSize)/2;

    for(let i=0; i<vals.length; i++) {
        let val = vals[i];
        const colors = ["#FF6B6B", "#4ECDC4", "#FFD166", "#6BFFB8", "#A560E8", "#FF9F43", "#54A0FF", "#1DD1A1", "#F368E0"];
        nextCtx.fillStyle = colors[val-1] || "#ecf0f1";
        nextCtx.beginPath();
        nextCtx.roundRect(startX + i*bSize + 2, startY+2, bSize-4, bSize-4, 4);
        nextCtx.fill();
        nextCtx.fillStyle = "#fff";
        nextCtx.font = "bold 30px sans-serif"; // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇÇÊã°Â§ß
        nextCtx.textAlign = "center";
        nextCtx.textBaseline = "middle";
        nextCtx.fillText(val, startX + i*bSize + bSize/2, startY + bSize/2 + 2);
    }
}

/**
 * Control Handlers
 */
function gameOver() {
    state.screen = 'GAMEOVER';
    if(state.timerId) clearTimeout(state.timerId); // „Éï„É™„Éº„Ç∫Èò≤Ê≠¢
    state.timerId = null;

    ui.controls.classList.add('hidden');
    ui.btnToTitle.classList.add('hidden');
    saveScore(state.difficulty, state.score);
    incrementClear(state.difficulty);
    ui.result.innerHTML = `
        <div style="background:#34495e; padding:20px; border-radius:10px; border:4px solid #c0392b; color:white;">
            <h2 style="color:#e74c3c;">GAME OVER</h2>
            <div style="font-size:1.2rem; margin:20px 0;">SCORE: <span style="color:#f1c40f; font-weight:bold;">${state.score}</span></div>
            <button id="btn-retry" class="btn btn-success">„ÇÇ„ÅÜ„ÅÑ„Å°„Å©</button>
            <button id="btn-home" class="btn">„Çø„Ç§„Éà„É´„Å∏</button>
        </div>
    `;
    ui.result.style.display = 'block';
    document.getElementById('btn-retry').onclick = () => { ui.result.style.display='none'; startGame(); };
    document.getElementById('btn-home').onclick = () => { ui.result.style.display='none'; backToTitle(); };
}

function startGame() {
    if(state.timerId) clearTimeout(state.timerId); // „Éï„É™„Éº„Ç∫Èò≤Ê≠¢
    state.timerId = null;

    // ‰øÆÊ≠£: „Ç≠„ÉºÊìç‰Ωú‰∏çËÉΩ„Éê„Ç∞ÂØæÁ≠ñÔºà„Ç≤„Éº„É†Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„ÉàÔºâ
    state.screen = 'PLAYING';
    
    state.score = 0; state.combo = 0; state.dropCount = 0;
    state.nextBlockValues = []; state.inputLocked = false;
    state.particles = []; state.comboAnim = null;
    ui.level.textContent = currentConfig.label;
    ui.title.classList.add('hidden');
    ui.rankingScreen.classList.add('hidden');
    ui.controls.classList.remove('hidden');
    ui.btnToTitle.classList.remove('hidden');
    initGrid();
    resize();
    spawnBlock();
    updateUI();
    draw();
}

function backToTitle() {
    if(state.timerId) clearTimeout(state.timerId); // „Éï„É™„Éº„Ç∫Èò≤Ê≠¢
    state.timerId = null;

    state.screen = 'TITLE';
    ui.title.classList.remove('hidden');
    ui.controls.classList.add('hidden');
    ui.btnToTitle.classList.add('hidden');
    updateTitleStats();
}

function updateUI() {
    ui.score.textContent = state.score;
    ui.combo.textContent = state.combo;
}

// Event Bindings
function bind(el, fn) {
    if(!el) return;
    el.addEventListener('click', (e)=>{ e.preventDefault(); fn(); });
    el.addEventListener('touchstart', (e)=>{ e.preventDefault(); fn(); }, {passive:false});
}

bind(ui.btnToTitle, backToTitle);

bind(ui.btnEasy, () => { state.difficulty='EASY'; currentConfig=CONFIGS.EASY; startGame(); });
bind(ui.btnNormal, () => { state.difficulty='NORMAL'; currentConfig=CONFIGS.NORMAL; startGame(); });
bind(ui.btnHard, () => { state.difficulty='HARD'; currentConfig=CONFIGS.HARD; startGame(); });

bind(document.getElementById('btn-left'), () => moveBlock(-1));
bind(document.getElementById('btn-right'), () => moveBlock(1));
bind(document.getElementById('btn-rotate'), () => rotateBlock());
bind(document.getElementById('btn-drop'), () => dropBlock());

window.addEventListener('keydown', (e) => {
    if(ui.title.classList.contains('hidden') && state.screen !== 'GAMEOVER') {
        if(e.key === 'ArrowLeft') moveBlock(-1);
        if(e.key === 'ArrowRight') moveBlock(1);
        if(e.key === 'ArrowUp') rotateBlock();
        if(e.key === 'ArrowDown' || e.key === ' ') dropBlock();
    }
});

bind(ui.btnRanking, () => {
    ui.rankingScreen.classList.remove('hidden');
    ['easy','normal','hard'].forEach(d => {
        const ul = document.getElementById(`rank-list-${d}`);
        ul.innerHTML = '<li>Ë™≠„ÅøËæº„Åø‰∏≠...</li>';
        if(window.currentUser) {
            window.fetchOnlineRanking(d.toUpperCase()).then(list => {
                ul.innerHTML = '';
                if(!list.length) ul.innerHTML = '<li>„Å™„Åó</li>';
                list.forEach((x,i) => {
                    ul.innerHTML += `<li><span>${i+1}. ${x.name}</span><span>${x.score}</span></li>`;
                });
            });
        } else {
            const list = getLocalRanking(d.toUpperCase());
            ul.innerHTML = '';
            if(!list.length) ul.innerHTML = '<li>„Å™„Åó</li>';
            list.forEach((s,i) => {
                ul.innerHTML += `<li><span>${i+1}. „ÅÇ„Å™„Åü</span><span>${s}</span></li>`;
            });
        }
    });
});
bind(ui.btnCloseRank, () => ui.rankingScreen.classList.add('hidden'));
bind(ui.btnIndex, () => window.location.href="index.html");

backToTitle();

</script>
</body>
</html>