<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¶³ã—ç®—ãƒ‘ã‚ºãƒ« - Tally Blitz (Final Ver.)</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #ffdee9 0%, #b5fffc 100%);
            --panel-bg: rgba(255, 255, 255, 0.6);
            --text-color: #5d5d5d;
            --accent-color: #ff9a9e;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-gradient);
            font-family: "M PLUS Rounded 1c", "Hiragino Kaku Gothic ProN", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            color: var(--text-color);
        }
        
        body::before {
            content: "";
            position: absolute;
            top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.4) 10%, transparent 20%),
                        radial-gradient(circle, rgba(255,255,255,0.4) 10%, transparent 20%);
            background-size: 100px 100px;
            background-position: 0 0, 50px 50px;
            z-index: -1;
            opacity: 0.5;
        }

        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        #left-panel, #right-panel {
            background-color: var(--panel-bg);
            backdrop-filter: blur(10px);
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            border: 2px solid rgba(255,255,255,0.8);
        }
        #left-panel { flex: 0.8; justify-content: center; border-right: none; }
        #right-panel { flex: 1.2; align-items: center; justify-content: flex-start; border-left: none; }
        
        #game-area {
            flex: 2.5;
            position: relative;
            background-color: rgba(255, 255, 255, 0.2);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(255, 154, 158, 0.2);
        }

        canvas {
            display: block;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 20px;
            border: 8px solid #fff;
        }

        h2 { 
            margin-top: 0; 
            border-bottom: 3px dashed var(--accent-color); 
            padding-bottom: 5px; 
            font-size: 1.3rem; 
            width: 100%; 
            color: var(--accent-color);
            text-align: center;
        }
        
        #right-panel-content { width: 100%; display: flex; flex-direction: column; align-items: center; }
        
        #next-block-area {
            width: 100%; height: 140px;
            background: #fff; border-radius: 25px;
            margin-bottom: 20px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.05);
            border: 4px solid #f0f4f8;
        }
        #next-label { 
            font-size: 1.1rem; color: var(--accent-color); 
            position: absolute; top: 5px; left: 15px; font-weight: 800;
            background: #fff; padding: 0 10px; border-radius: 10px;
        }
        #next-canvas { margin-top: 15px; }

        .info-group { width: 100%; margin-bottom: 10px; text-align: center; }
        .info-item { 
            margin-bottom: 15px; 
            display: flex; flex-direction: column; align-items: center;
            border-bottom: 2px dotted #ffc3a0; padding-bottom: 5px;
        }
        .info-label { font-size: 0.9rem; color: #aaa; margin-bottom: 2px; font-weight: bold; }
        .info-value { 
            font-size: 2.2rem; font-weight: 800; line-height: 1; 
            text-shadow: 2px 2px 0 #fff; color: #666;
        }
        
        #disp-level { color: #ff9a9e; }
        #disp-round { color: #84fab0; font-size: 1.5rem; }
        #disp-combo { color: #a18cd1; font-size: 2.6rem; }
        #disp-score { color: #fbc2eb; }

        .btn {
            background: linear-gradient(to bottom, #8fd3f4, #84fab0);
            color: white; border: 2px solid white; 
            padding: 12px 20px; border-radius: 50px; 
            cursor: pointer; font-size: 1rem; margin: 5px;
            box-shadow: 0 5px 0 #6dd5ed, 0 8px 10px rgba(0,0,0,0.1);
            font-weight: 800; text-shadow: 1px 1px 0 rgba(0,0,0,0.1);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: 0 1px 0 #6dd5ed; }
        .btn-danger { 
            background: linear-gradient(to bottom, #ff9a9e, #fecfef); 
            box-shadow: 0 5px 0 #ff758c, 0 8px 10px rgba(0,0,0,0.1);
        }
        .btn-danger:active { box-shadow: 0 1px 0 #ff758c; }
        .btn-success { 
            background: linear-gradient(to bottom, #a1c4fd, #c2e9fb); 
            box-shadow: 0 5px 0 #89b0ea, 0 8px 10px rgba(0,0,0,0.1);
        }
        .btn-success:active { box-shadow: 0 1px 0 #89b0ea; }
        .btn-warning { 
            background: linear-gradient(to bottom, #f6d365, #fda085); 
            box-shadow: 0 5px 0 #f5c065, 0 8px 10px rgba(0,0,0,0.1); color: white;
        }
        .btn-warning:active { box-shadow: 0 1px 0 #f5c065; }
        
        .btn-auth {
            background-color: #4285F4; box-shadow: 0 4px 0 #2a56c6; color: white; 
            padding: 12px; font-weight: bold; width: 100%; margin-top: 10px; border-radius: 50px;
            display: flex; justify-content: center; align-items: center; gap: 10px;
        }

        #overlay, #ranking-overlay, #round-clear-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.4); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; flex-direction: column; color: #555;
        }
        .overlay-content {
            background: rgba(255,255,255,0.95); padding: 25px; border-radius: 30px;
            text-align: center; width: 90%; max-width: 550px;
            max-height: 90vh; overflow-y: auto;
            border: 6px solid #b5fffc; box-shadow: 0 15px 35px rgba(100,100,100,0.1);
        }
        .hidden { display: none !important; }

        .difficulty-container { display: flex; justify-content: center; gap: 10px; margin-bottom: 25px; align-items: flex-end; width: 100%; }
        .diff-wrapper { display: flex; flex-direction: column; align-items: center; flex: 1; max-width: 120px; }
        .diff-wrapper .btn { white-space: nowrap; width: 100%; padding: 12px 5px; font-size: 0.95rem; margin: 5px 0; }
        .crown-icon { font-size: 1.8rem; margin-bottom: 5px; visibility: hidden; }
        .clear-count-text { font-size: 1rem; color: #888; font-weight: bold; margin-top: 5px; }

        .ranking-container { display: flex; gap: 5px; margin-bottom: 10px; height: 250px; }
        .ranking-box { background: #fff; padding: 5px; border-radius: 15px; flex: 1; overflow-y: auto; border: 2px solid #f0f0f0; }
        .ranking-list { list-style: none; padding: 0; margin: 0; font-size: 0.8rem; text-align: left; }
        .ranking-list li { border-bottom: 1px dashed #ffd1ff; padding: 5px; display:flex; justify-content:space-between; color: #666; }

        #puzzle-controls {
            display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr;
            gap: 12px; margin-top: auto; width: 100%; max-width: 280px;
        }
        .ctrl-btn {
            background: #fff; border: none; color: #a18cd1; border-radius: 50%;
            font-size: 1.8rem; display: flex; justify-content: center; align-items: center;
            cursor: pointer; height: 65px; width: 65px; margin: 0 auto;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05), inset 0 -4px 0 rgba(0,0,0,0.05); font-weight: bold;
        }
        .ctrl-btn:active { transform: scale(0.9); background: #f0f0f0; }
        #btn-left { grid-column: 1; grid-row: 1; }
        #btn-rotate { grid-column: 2; grid-row: 1; color: #fff; background: linear-gradient(to bottom, #fbc2eb, #a6c1ee); }
        #btn-right { grid-column: 3; grid-row: 1; }
        #btn-drop { 
            grid-column: 1 / span 3; grid-row: 2; 
            background: linear-gradient(to bottom, #ff9a9e, #fecfef); 
            border-color: #fff; color: white; font-weight: bold; font-size: 1.5rem;
            width: 100%; border-radius: 50px; height: 60px;
        }

        @media (max-width: 768px) {
            #container { flex-direction: column; }
            #left-panel { display: none; }
            #game-area { flex: 3; box-shadow: none; border-radius: 0; }
            #right-panel { 
                flex: 1.2; flex-direction: row; padding: 10px; align-items: center; justify-content: space-between;
                border-top: none; background: rgba(255,255,255,0.9);
            }
            #right-panel-content { width: 45%; font-size: 0.8rem; align-items: flex-start; }
            #next-block-area { 
                width: 80px; height: 80px; margin-bottom: 0; margin-right: 10px;
                position: absolute; top: 10px; left: 10px; display: none; border-width: 2px;
            }
            .info-group { display: flex; flex-direction: row; gap: 10px; margin-bottom: 0; text-align: left; }
            .info-item { border: none; align-items: flex-start; margin-bottom: 0; }
            .info-value { font-size: 1.4rem; text-shadow: none; }
            #puzzle-controls { width: 50%; height: auto; gap: 8px; margin: 0; display: grid;}
            .ctrl-btn { height: 55px; width: 55px; font-size: 1.4rem;}
            #btn-drop { height: 55px; width: 100%;}
        }
    </style>
</head>
<body>

<div id="container">
    <div id="left-panel">
        <h2>ã‚ãã³ã‹ãŸ</h2>
        <div style="font-size: 0.95rem; line-height: 1.8; color: #666; font-weight: bold;">
            <p>1. <span style="color:#ff9a9e">ã™ã†ã˜</span>ã‚’ãŠã¨ã—ã¦<br>ã—ãŸã®ãƒ–ãƒ­ãƒƒã‚¯ã¨<br>ãŸã—ã–ã‚“ ã™ã‚‹ã‚ˆï¼</p>
            <p>2. ãŸã—ã¦<span style="color:#a18cd1">ã€Œ10ã€</span>ã«<br>ãªã‚‹ã¨ ããˆã‚‹ã‚ˆï¼</p>
            <p>3. <strong>10ã‚ˆã‚Š ã¡ã„ã•ã„</strong>ã¨<br>ãã£ã¤ã„ã¦<br>ã™ã†ã˜ãŒ ãµãˆã‚‹ã‚ˆã€‚</p>
            <p>4. <strong>11ã„ã˜ã‚‡ã†</strong>ã¯<br>ãŠã˜ã‚ƒã¾ãƒ–ãƒ­ãƒƒã‚¯ã«<br>ãªã£ã¡ã‚ƒã†ãã€‚</p>
            <p>5. <strong>ã‚¹ã‚³ã‚¢é”æˆ</strong>ã§<br>æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã¸ï¼<br>ã ã‚“ã ã‚“é€Ÿããªã‚‹ã‚ˆã€‚</p>
        </div>
        <div style="margin-top:auto; text-align:center;">
            <button id="btn-to-title" class="btn btn-danger hidden">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
        </div>
    </div>

    <div id="game-area">
        <canvas id="gameCanvas"></canvas>

        <div id="title-screen" class="overlay-content" style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:10; width: 95%; max-width: 550px;">
            <h1 style="font-size:3.5rem; margin:0 0 10px 0; color:#ff9a9e; font-family: 'M PLUS Rounded 1c', sans-serif; text-shadow: 4px 4px 0 #fff, 6px 6px 0 #fad0c4;">TALLY BLITZ</h1>
            <p style="font-size:1.2rem; margin-top:0; margin-bottom:30px; font-weight:bold; color:#a18cd1;">- ãŸã—ã–ã‚“ãƒ‘ã‚ºãƒ« -</p>
            
            <div class="difficulty-container">
                <div class="diff-wrapper">
                    <div id="crown-easy" class="crown-icon">ğŸ‘‘</div>
                    <button id="btn-easy" class="btn btn-success">ã—ã‚‡ãã‚…ã†</button>
                    <div id="clear-easy" class="clear-count-text">0å›ãƒ—ãƒ¬ã‚¤</div>
                    <div style="font-size:0.75rem; color:#aaa;">3000ç‚¹ã§ã‚¯ãƒªã‚¢</div>
                </div>
                <div class="diff-wrapper">
                    <div id="crown-normal" class="crown-icon">ğŸ‘‘</div>
                    <button id="btn-normal" class="btn">ã¡ã‚…ã†ãã‚…ã†</button>
                    <div id="clear-normal" class="clear-count-text">0å›ãƒ—ãƒ¬ã‚¤</div>
                    <div style="font-size:0.75rem; color:#aaa;">5000ç‚¹ã§ã‚¯ãƒªã‚¢</div>
                </div>
                <div class="diff-wrapper">
                    <div id="crown-hard" class="crown-icon">ğŸ‘‘</div>
                    <button id="btn-hard" class="btn btn-danger">ã˜ã‚‡ã†ãã‚…ã†</button>
                    <div id="clear-hard" class="clear-count-text">0å›ãƒ—ãƒ¬ã‚¤</div>
                    <div style="font-size:0.75rem; color:#aaa;">10000ç‚¹ã§ã‚¯ãƒªã‚¢</div>
                </div>
            </div>

            <button id="btn-view-ranking" class="btn btn-warning" style="width: 80%; max-width: 300px; font-weight:bold;">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
            
            <div style="margin-top: 20px; border-top: 2px dashed #eee; padding-top:15px; width:100%;">
                <p id="auth-status" style="margin: 0 0 5px 0; font-size: 0.9rem; color: #aaa; font-weight: bold;">æœªãƒ­ã‚°ã‚¤ãƒ³</p>
                <button id="btn-login" class="btn btn-auth" style="max-width: 300px; margin: 10px auto;">
                    <span>G</span> Googleã§ãƒ­ã‚°ã‚¤ãƒ³
                </button>
                <button id="btn-logout" class="btn btn-danger hidden" style="width: 80%; max-width: 300px;">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
            </div>
            
            <button id="btn-index" class="btn" style="background: #e0e0e0; color:#888; border-color:#ccc; box-shadow: 0 5px 0 #bbb; margin-top: 15px; width: 80%; max-width: 300px;">INDEXã¸æˆ»ã‚‹</button>
        </div>

        <div id="game-result" style="display: none; position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index: 20; width: 85%; max-width: 400px;"></div>

        <div id="round-clear-screen" class="hidden">
            <div id="round-clear-overlay">
                <div class="overlay-content">
                    <h2 style="color:#ff9a9e; font-size:2rem; border-bottom:none;">ROUND CLEAR!</h2>
                    <p style="font-size:1.1rem; font-weight:bold;">ãŠã‚ã§ã¨ã†ï¼</p>
                    <p>ã¤ãã®ãƒ©ã‚¦ãƒ³ãƒ‰ã«ã™ã™ã¿ã¾ã™ã‹ï¼Ÿ<br><span style="color:#a18cd1; font-size:0.9rem;">(ãƒ–ãƒ­ãƒƒã‚¯ãŒã›ã‚Šã‚ãŒã‚‹ã®ãŒ ã¯ã‚„ããªã‚‹ã‚ˆï¼)</span></p>
                    <div style="margin: 20px 0; padding: 10px; background: #fff0f5; border-radius: 10px;">
                        <p style="margin:5px;">ã¤ãã®ã‚‚ãã²ã‚‡ã†</p>
                        <span id="next-target-score" style="color:#f6d365; font-weight:800; font-size:1.5rem;">6000</span><span style="font-weight:bold;"> ç‚¹</span>
                    </div>
                    <button id="btn-next-round" class="btn btn-success" style="width:80%;">ã¤ã¥ã‘ã‚‹</button>
                    <button id="btn-quit-round" class="btn btn-danger" style="width:80%;">ã‚„ã‚ã‚‹</button>
                </div>
            </div>
        </div>

        <div id="ranking-screen" class="hidden">
            <div id="ranking-overlay">
                <div class="overlay-content">
                    <h2 id="ranking-header-title" style="color: #f6d365; border-bottom-color: #f6d365;">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
                    <div class="ranking-container">
                        <div class="ranking-box">
                            <div style="color:#84fab0; font-weight:bold;">åˆç´š</div>
                            <ul id="rank-list-easy" class="ranking-list"></ul>
                        </div>
                        <div class="ranking-box">
                            <div style="color:#8fd3f4; font-weight:bold;">ä¸­ç´š</div>
                            <ul id="rank-list-normal" class="ranking-list"></ul>
                        </div>
                        <div class="ranking-box">
                            <div style="color:#ff9a9e; font-weight:bold;">ä¸Šç´š</div>
                            <ul id="rank-list-hard" class="ranking-list"></ul>
                        </div>
                    </div>
                    <button id="btn-close-ranking" class="btn">ã¨ã˜ã‚‹</button>
                </div>
            </div>
        </div>
    </div>

    <div id="right-panel">
        <div id="right-panel-content">
            <div id="next-block-area">
                <div id="next-label">ã¤ã</div>
                <canvas id="nextCanvas" width="220" height="80"></canvas>
            </div>
            <div class="info-group">
                <div class="info-item">
                    <span class="info-label">LEVEL</span>
                    <span id="disp-level" class="info-value">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">ROUND</span>
                    <span id="disp-round" class="info-value">1</span>
                </div>
                <div class="info-item">
                    <span class="info-label">COMBO</span>
                    <span id="disp-combo" class="info-value">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">SCORE</span>
                    <span id="disp-score" class="info-value">0</span>
                </div>
            </div>
        </div>

        <div id="puzzle-controls" class="hidden">
            <div class="ctrl-btn" id="btn-left">â—€</div>
            <div class="ctrl-btn" id="btn-rotate">â†»</div>
            <div class="ctrl-btn" id="btn-right">â–¶</div>
            <div class="ctrl-btn" id="btn-drop">â†“</div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, serverTimestamp, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
      authDomain: "math-braves.firebaseapp.com",
      projectId: "math-braves",
      storageBucket: "math-braves.firebasestorage.app",
      messagingSenderId: "217117619290",
      appId: "1:217117619290:web:d227feb603970d3948d463"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();

    window.currentUser = null; 

    const btnLogin = document.getElementById('btn-login');
    const btnLogout = document.getElementById('btn-logout');
    const authStatus = document.getElementById('auth-status');

    window.handleLogin = function() {
        signInWithPopup(auth, provider)
            .then((result) => { console.log("Login Success"); })
            .catch((error) => { console.error("Login Error", error); alert("ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—"); });
    };

    window.handleLogout = function() {
        signOut(auth).then(() => { console.log("Logout Success"); });
    };

    if(btnLogin) btnLogin.onclick = window.handleLogin;
    if(btnLogout) btnLogout.onclick = window.handleLogout;

    onAuthStateChanged(auth, (user) => {
        if (user) {
            window.currentUser = { uid: user.uid, displayName: user.displayName || 'åç„¡ã—ã•ã‚“' };
            if(authStatus) authStatus.textContent = `Login: ${window.currentUser.displayName}`;
            if(btnLogin) btnLogin.classList.add('hidden');
            if(btnLogout) btnLogout.classList.remove('hidden');
        } else {
            window.currentUser = null;
            if(authStatus) authStatus.textContent = 'æœªãƒ­ã‚°ã‚¤ãƒ³';
            if(btnLogin) btnLogin.classList.remove('hidden');
            if(btnLogout) btnLogout.classList.add('hidden');
        }
    });

    const COLLECTION_NAME = "scores_Tally_Blitz_addition";

    window.saveOnlineScore = async (userId, userName, difficulty, score) => {
        try {
            const docId = `${userId}_${difficulty}_${Date.now()}`;
            await setDoc(doc(db, COLLECTION_NAME, docId), {
                uid: userId,
                name: userName,
                difficulty: difficulty,
                score: score,
                createdAt: serverTimestamp()
            });
        } catch (error) { console.error(error); }
    };

    window.fetchOnlineRanking = async (difficulty) => {
        if (!window.currentUser) return [];
        try {
            const scoresRef = collection(db, COLLECTION_NAME);
            const q = query(
                scoresRef, 
                where("difficulty", "==", difficulty), 
                orderBy("score", "desc"), 
                limit(10)
            );
            const querySnapshot = await getDocs(q);
            const ranking = [];
            querySnapshot.forEach((doc) => ranking.push(doc.data()));
            return ranking;
        } catch (error) { console.error(error); return []; }
    };
</script>

<script>
// --- Game Config ---
const CROWN_THRESHOLDS = { BRONZE: 2000, SILVER: 5000, GOLD: 10000 };
const CONFIGS = {
    EASY: { label: "ã—ã‚‡ãã‚…ã†", floorRows: 2, probs: [0.5, 0.8], riseInterval: 10, clearScore: 3000 },
    NORMAL: { label: "ã¡ã‚…ã†ãã‚…ã†", floorRows: 3, probs: [0.25, 0.75], riseInterval: 7, clearScore: 5000 },
    HARD: { label: "ã˜ã‚‡ã†ãã‚…ã†", floorRows: 4, probs: [0.20, 0.50], riseInterval: 5, clearScore: 10000 }
};

// ã€é‡è¦ã€‘å¤©äº•è£ï¼ˆè¦‹ãˆãªã„é ˜åŸŸï¼‰ã®å®Ÿè£…
const COLS = 5;
const VISIBLE_ROWS = 8;
const EXTRA_ROWS = 4; // å¤©äº•è£ã®è¡Œæ•°
const ROWS = VISIBLE_ROWS + EXTRA_ROWS; // å…¨ä½“ã®è¡Œæ•°ï¼ˆ12è¡Œï¼‰
const BLOCK_VAL_OBSTACLE = 99;
const NEXT_BLOCK_SIZE = 50; 

// Animation Speed Constants
const ANIM_SPEED_DROP_Y = 0.8;
const ANIM_SPEED_FALL = 20; 
const WAIT_AFTER_DROP = 50; 
const WAIT_AFTER_CLEAR = 150; 

let currentConfig = CONFIGS.NORMAL;
let state = {
    screen: 'TITLE', difficulty: 'NORMAL',
    score: 0, combo: 0, dropCount: 0, riseCounter: 0,
    round: 1, targetScore: 0, currentRiseInterval: 0,
    grid: [], 
    animOffsets: [], 
    activeBlock: null, nextBlockValues: [],
    particles: [], comboAnim: null, inputLocked: false,
    width: 0, height: 0, blockSize: 40, boardX: 0, boardY: 0,
    timerId: null,
    fastDropping: false
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas');
const nextCtx = nextCanvas.getContext('2d');
const ui = {
    score: document.getElementById('disp-score'),
    combo: document.getElementById('disp-combo'),
    level: document.getElementById('disp-level'),
    round: document.getElementById('disp-round'),
    title: document.getElementById('title-screen'),
    result: document.getElementById('game-result'),
    roundClearScreen: document.getElementById('round-clear-screen'),
    nextTargetScore: document.getElementById('next-target-score'),
    rankingScreen: document.getElementById('ranking-screen'),
    controls: document.getElementById('puzzle-controls'),
    btnToTitle: document.getElementById('btn-to-title'),
    btnEasy: document.getElementById('btn-easy'),
    btnNormal: document.getElementById('btn-normal'),
    btnHard: document.getElementById('btn-hard'),
    btnRanking: document.getElementById('btn-view-ranking'),
    btnCloseRank: document.getElementById('btn-close-ranking'),
    btnNextRound: document.getElementById('btn-next-round'),
    btnQuitRound: document.getElementById('btn-quit-round'),
    btnIndex: document.getElementById('btn-index'),
    crowns: { EASY: document.getElementById('crown-easy'), NORMAL: document.getElementById('crown-normal'), HARD: document.getElementById('crown-hard') },
    clears: { EASY: document.getElementById('clear-easy'), NORMAL: document.getElementById('clear-normal'), HARD: document.getElementById('clear-hard') }
};

function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    state.width = rect.width;
    state.height = rect.height;
    canvas.width = state.width;
    canvas.height = state.height;
    
    const paddingTop = 60; 
    const availableH = state.height - paddingTop;
    const availableW = state.width;
    // ã‚µã‚¤ã‚ºè¨ˆç®—ã¯ã€Œè¦‹ãˆã‚‹è¡Œæ•°ã€ã§è¡Œã†
    const sizeByH = availableH / (VISIBLE_ROWS + 0.5);
    const sizeByW = availableW / (COLS + 1);
    state.blockSize = Math.min(sizeByH, sizeByW);

    state.boardW = state.blockSize * COLS;
    state.boardH = state.blockSize * VISIBLE_ROWS;
    state.boardX = (state.width - state.boardW) / 2;
    state.boardY = paddingTop + (availableH - state.boardH) / 2;
}
window.addEventListener('resize', resize);
resize();

function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

// --- Storage ---
function getRankingKey(d) { return `tally_blitz_v3_rank_${d}`; }
function getClearKey(d) { return `tally_blitz_v3_clear_${d}`; }
function getLocalRanking(d) { return JSON.parse(localStorage.getItem(getRankingKey(d))) || []; }
function getClearCount(d) { return parseInt(localStorage.getItem(getClearKey(d))) || 0; }
function saveScore(d, s) {
    let r = getLocalRanking(d);
    r.push(s); r.sort((a,b)=>b-a); r = r.slice(0,10);
    localStorage.setItem(getRankingKey(d), JSON.stringify(r));
    if(window.currentUser && window.saveOnlineScore) window.saveOnlineScore(window.currentUser.uid, window.currentUser.displayName, d, s);
}
function incrementClear(d) {
    let c = getClearCount(d) + 1;
    localStorage.setItem(getClearKey(d), c);
    return c;
}
function updateTitleStats() {
    ['EASY','NORMAL','HARD'].forEach(d => {
        const c = getClearCount(d);
        ui.clears[d].textContent = `${c}å›ãƒ—ãƒ¬ã‚¤`;
        const best = getLocalRanking(d)[0] || 0;
        const crown = ui.crowns[d];
        const th = CONFIGS[d].thresholds || CROWN_THRESHOLDS;
        crown.style.visibility = 'visible';
        if(best >= th.GOLD) { crown.textContent='ğŸ‘‘'; crown.style.color='gold'; crown.style.filter='drop-shadow(0 0 5px gold)'; }
        else if(best >= th.SILVER) { crown.textContent='ğŸ‘‘'; crown.style.color='silver'; crown.style.filter='drop-shadow(0 0 5px silver)'; }
        else if(best >= th.BRONZE) { crown.textContent='ğŸ‘‘'; crown.style.color='#cd7f32'; }
        else crown.style.visibility = 'hidden';
    });
}

// --- Block Logic ---
function getBlockOffsets(rot, len) {
    const offsets = [];
    for(let i=0; i<len; i++) {
        let dx = 0, dy = 0;
        if(rot === 0) { dx = i; dy = 0; }
        else if(rot === 1) { dx = 0; dy = i; }
        else if(rot === 2) { dx = -i; dy = 0; }
        else if(rot === 3) { dx = 0; dy = -i; }
        offsets.push({dx, dy});
    }
    return offsets;
}

function getOccupiedCells(bx, by, rot, len) {
    const offsets = getBlockOffsets(rot, len);
    const iX = Math.round(bx);
    const iY = Math.floor(by); 
    return offsets.map(o => ({x: iX + o.dx, y: iY + o.dy}));
}

function canPlace(bx, by, rot, values) {
    const cells = getOccupiedCells(bx, by, rot, values.length);
    for(let c of cells) {
        if(c.x < 0 || c.x >= COLS) return false;
        // å¤©äº•è£ãŒã‚ã‚‹ã®ã§ã€y >= 0 ã§ã‚ã‚Œã°é…ç½®å¯èƒ½ï¼ˆå¤©äº•è£ã®ä¸Šé™ãƒã‚§ãƒƒã‚¯ã¯spawnæ™‚ãªã©ã«ï¼‰
        if(c.y >= ROWS) return false;
        if(c.y >= 0 && state.grid[c.y][c.x] !== 0) return false;
    }
    return true;
}

// --- Game Loop Logic ---
function initGrid() {
    state.grid = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    state.animOffsets = Array.from({length: ROWS}, () => Array(COLS).fill(0));
    const floorR = currentConfig.floorRows;
    for(let i=0; i<floorR; i++) {
        const r = ROWS - 1 - i;
        for(let c=0; c<COLS; c++) state.grid[r][c] = BLOCK_VAL_OBSTACLE;
    }
    const numRow = ROWS - 1 - floorR;
    if(numRow >= EXTRA_ROWS) { // å¤©äº•è£ã‚ˆã‚Šä¸‹ã«ã®ã¿åˆæœŸé…ç½®
        for(let c=0; c<COLS; c++) state.grid[numRow][c] = randomInt(1, 9);
    }
}

function generateBlockValues() {
    state.dropCount++;
    const r = Math.random();
    let size = 2;
    const p = currentConfig.probs;
    if(r < p[0]) size = 2;
    else if(r < p[1]) size = 3;
    else size = 4;
    const arr = [];
    for(let i=0; i<size; i++) arr.push(randomInt(1,9));
    return arr;
}

function spawnBlock() {
    if(state.nextBlockValues.length === 0) state.nextBlockValues = generateBlockValues();
    const values = [...state.nextBlockValues];
    // å‡ºç¾ä½ç½®ã‚’1æ®µä¸‹ã’ã¦ï¼ˆEXTRA_ROWSï¼‰ã€ç”»é¢ä¸Šç«¯ã«è¦‹ãˆã‚‹ä½ç½®ã«ã™ã‚‹
    state.activeBlock = { x: Math.floor(COLS/2)-1, y: EXTRA_ROWS, values: values, rot: 0, offsetY: 0 };
    state.nextBlockValues = generateBlockValues();
    state.fastDropping = false;
    drawNextBlock();
    if(!canPlace(state.activeBlock.x, state.activeBlock.y, state.activeBlock.rot, state.activeBlock.values)) {
        gameOver();
    }
    draw(); 
}

function rotateBlock() {
    if(!state.activeBlock || state.inputLocked || state.fastDropping) return;
    const b = state.activeBlock;
    const nextRot = (b.rot + 1) % 4;
    const len = b.values.length;
    let baseDy = 0;
    if (b.rot === 0 && nextRot === 1) baseDy = -(len - 1);
    else if (b.rot === 1 && nextRot === 2) baseDy = (len - 1);

    const moves = [
        {dx: 0, dy: baseDy}, {dx: 0, dy: 0},
        {dx: -1, dy: baseDy}, {dx: 1, dy: baseDy},
        {dx: -1, dy: 0}, {dx: 1, dy: 0},
        {dx: -2, dy: baseDy}, {dx: 2, dy: baseDy}
    ];
    for(let m of moves) {
        if(canPlace(b.x + m.dx, b.y + m.dy, nextRot, b.values)) {
            b.x += m.dx; b.y += m.dy; b.rot = nextRot; 
            draw(); 
            return;
        }
    }
}

function moveBlock(dir) {
    if(!state.activeBlock || state.inputLocked || state.fastDropping) return;
    const b = state.activeBlock;
    if(canPlace(b.x + dir, b.y, b.rot, b.values)) {
        b.x += dir;
        draw(); 
    }
}

function dropBlock() {
    if(!state.activeBlock || state.inputLocked || state.fastDropping) return;
    state.fastDropping = true; 
}

function lockBlock() {
    if(!state.activeBlock) return;
    const b = state.activeBlock;
    state.activeBlock = null; 
    state.fastDropping = false;
    
    const landY = Math.round(b.y);
    const cells = getOccupiedCells(b.x, landY, b.rot, b.values.length);
    cells.forEach((c, i) => { 
        // è² ã®åº§æ¨™ï¼ˆå¤©äº•è£ã®ã•ã‚‰ã«ä¸Šï¼‰ã¯ç„¡è¦–ã™ã‚‹ã‹ã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ã™ã‚‹ã‹
        // ã“ã“ã§ã¯é…åˆ—ç¯„å›²å†…ãªã‚‰æ ¼ç´
        if(c.y >= 0 && c.y < ROWS) state.grid[c.y][c.x] = b.values[i]; 
    });

    draw();
    setTimeout(() => { processTurn(); }, WAIT_AFTER_DROP); 
}

async function processTurn() {
    state.inputLocked = true;
    state.riseCounter++;
    let totalTens = 0;

    const runPhysics = async () => {
        let anyChange = false;
        outerLoop:
        while(true) {
            if(applyGravityLogic()) { 
                await animateGravity(); 
            }
            
            let changeOccurred = false;
            for(let c=0; c<COLS; c++) {
                // ROWSå…¨ä½“ã‚’ã‚¹ã‚­ãƒ£ãƒ³
                for(let r=ROWS-2; r>=0; r--) {
                    const upper = state.grid[r][c];
                    const lower = state.grid[r+1][c];
                    if(upper > 0 && lower > 0 && upper !== BLOCK_VAL_OBSTACLE && lower !== BLOCK_VAL_OBSTACLE) {
                        const sum = upper + lower;
                        if(sum < 10) {
                            state.grid[r+1][c] = sum; state.grid[r][c] = 0;
                            // å¤©äº•è£ãªã‚‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯å‡ºã•ãªã„ã€ã¾ãŸã¯ã‚¯ãƒªãƒƒãƒ—ã•ã‚Œã‚‹
                            spawnParticle(c, r+1, "åˆä½“!", "#3498db"); changeOccurred = true;
                        } else if(sum === 10) {
                            state.grid[r+1][c] = 0; state.grid[r][c] = 0;
                            let bonus = 0;
                            if(r+2 < ROWS && state.grid[r+2][c] === BLOCK_VAL_OBSTACLE) {
                                state.grid[r+2][c] = 0; spawnParticle(c, r+2, "Break!", "#ff9a9e"); bonus = 10;
                            }
                            state.combo++; totalTens++;
                            
                            // ã€å¤‰æ›´ã€‘ã‚¹ã‚³ã‚¢è¨ˆç®—: (åŸºç¤ç‚¹10 + ãƒœãƒ¼ãƒŠã‚¹) * ã‚³ãƒ³ãƒœ
                            // ã“ã‚Œã§å˜ç™ºã¯ x1ã€2å›ç›®ã¯ x2...ã¨ãªã‚‹
                            let point = (10 + bonus) * state.combo;
                            state.score += Math.floor(point);
                            
                            spawnParticle(c, r+0.5, "10!", "#f6d365"); spawnParticle(2, 3, `+${Math.floor(point)}`, "#f6d365");
                            changeOccurred = true; 
                            // ã‚³ãƒ³ãƒœæ¼”å‡ºã«ã‚¹ã‚³ã‚¢ã‚‚å«ã‚ã‚‹
                            showComboAnim(state.combo + " COMBO", point);
                        } else {
                            if(lower !== BLOCK_VAL_OBSTACLE) { 
                                state.grid[r+1][c] = BLOCK_VAL_OBSTACLE; state.grid[r][c] = sum - 10;
                                spawnParticle(c, r+1, "Over!", "#999"); changeOccurred = true;
                            }
                        }
                        if(changeOccurred) { 
                            draw(); updateUI(); 
                            await wait(WAIT_AFTER_CLEAR); 
                            continue outerLoop; 
                        }
                    }
                }
            }
            if(!changeOccurred) break; 
            anyChange = true;
        }
        return anyChange;
    };

    await runPhysics();

    if(state.score >= state.targetScore) { showRoundClear(); return; }

    if(state.riseCounter >= state.currentRiseInterval) {
        // ã€å¤‰æ›´ã€‘ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šï¼ˆã›ã‚Šä¸ŠãŒã‚Šæ™‚ï¼‰
        // å¯è¦–é ˜åŸŸæœ€ä¸Šæ®µ(EXTRA_ROWS)ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹ã€å…¨ã¦ã®åˆ—(c=0ã‚’å«ã‚€)ã‚’ãƒã‚§ãƒƒã‚¯
        let overflow = false;
        for(let c=0; c<COLS; c++) { if(state.grid[EXTRA_ROWS][c] !== 0) overflow = true; }
        if(overflow) { gameOver(); return; }

        state.riseCounter = 0;
        
        for(let r=0; r<ROWS-1; r++) { state.grid[r] = [...state.grid[r+1]]; }
        state.grid[ROWS-1] = Array.from({length: COLS}, () => randomInt(1, 9));
        
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) { if(state.grid[r][c]!==0) state.animOffsets[r][c] = state.blockSize; }
        }
        await animateGravity();
        await runPhysics();
        if(state.score >= state.targetScore) { showRoundClear(); return; }
    }

    if(totalTens === 0) state.combo = 0;
    updateUI();
    
    // ã€å¤‰æ›´ã€‘ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šï¼ˆã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ï¼‰
    // å¯è¦–é ˜åŸŸæœ€ä¸Šæ®µ(EXTRA_ROWS)ã«ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚‹ã‹ã€å…¨ã¦ã®åˆ—(c=0ã‚’å«ã‚€)ã‚’ãƒã‚§ãƒƒã‚¯
    for(let c=0; c<COLS; c++) { if(state.grid[EXTRA_ROWS][c] !== 0) { gameOver(); return; } }
    
    state.inputLocked = false; spawnBlock();
}

function applyGravityLogic() {
    let moved = false;
    for(let c=0; c<COLS; c++) {
        for(let r=ROWS-2; r>=0; r--) {
            if(state.grid[r][c] !== 0) {
                let fallDist = 0;
                let k = r;
                while(k+1 < ROWS && state.grid[k+1][c] === 0) {
                    k++; fallDist++;
                }
                if(fallDist > 0) {
                    state.grid[k][c] = state.grid[r][c];
                    state.grid[r][c] = 0;
                    state.animOffsets[k][c] = -fallDist * state.blockSize;
                    moved = true;
                }
            }
        }
    }
    return moved;
}

function animateGravity() {
    return new Promise(resolve => {
        const loop = () => {
            let stillAnimating = false;
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    if(state.animOffsets[r][c] !== 0) {
                        if(state.animOffsets[r][c] < 0) {
                            state.animOffsets[r][c] += ANIM_SPEED_FALL;
                            if(state.animOffsets[r][c] > 0) state.animOffsets[r][c] = 0;
                        } else {
                            state.animOffsets[r][c] -= ANIM_SPEED_FALL;
                            if(state.animOffsets[r][c] < 0) state.animOffsets[r][c] = 0;
                        }
                        stillAnimating = true;
                    }
                }
            }
            draw();
            if(stillAnimating) requestAnimationFrame(loop);
            else resolve();
        };
        loop();
    });
}

function showComboAnim(text, score) { 
    state.comboAnim = { text: text, score: score, life: 1.0 }; 
}
function wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

// --- Update & Draw Loop ---
function update() {
    if(state.screen !== 'PLAYING') {
        requestAnimationFrame(update);
        return;
    }

    if(state.activeBlock && state.fastDropping) {
        const b = state.activeBlock;
        if(canPlace(b.x, b.y + ANIM_SPEED_DROP_Y, b.rot, b.values)) {
            b.y += ANIM_SPEED_DROP_Y;
        } else {
            let finalY = Math.floor(b.y);
            while(canPlace(b.x, finalY + 1, b.rot, b.values)) finalY++;
            b.y = finalY;
            lockBlock(); 
        }
        draw();
    }
    
    for(let i=state.particles.length-1; i>=0; i--) {
        let p = state.particles[i]; p.update(); 
        if(p.life <= 0) state.particles.splice(i,1);
    }
    if(state.comboAnim) {
        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ï¼†ã‚¢ã‚¦ãƒˆã®æ¼”å‡ºç”¨ã«lifeã‚’ä½¿ã†
        // 0.02 -> 0.01 ã«å¤‰æ›´ã—ã¦è¡¨ç¤ºæ™‚é–“ã‚’2å€ã«
        state.comboAnim.life -= 0.02; 
        if(state.comboAnim.life <= 0) state.comboAnim = null;
    }
    
    if(state.particles.length > 0 || state.comboAnim || state.fastDropping) {
        draw();
    }
    
    requestAnimationFrame(update);
}
requestAnimationFrame(update);


class Particle {
    constructor(c, r, text, color) {
        // åº§æ¨™è¨ˆç®—æ™‚ã«å¤©äº•è£åˆ†ã‚’è€ƒæ…® (visualåº§æ¨™)
        let visualR = r - EXTRA_ROWS;
        this.x = state.boardX + c * state.blockSize + state.blockSize/2;
        this.y = state.boardY + visualR * state.blockSize + state.blockSize/2;
        this.text = text; this.color = color; this.life = 1.0; this.vy = -2; 
    }
    update() { this.y += this.vy; this.life -= 0.04; } 
    draw(ctx) {
        // å¤©äº•è£ãªã‚‰æç”»ã—ãªã„
        if(this.y < state.boardY) return;
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color; ctx.strokeStyle = "white";
        ctx.font = "800 24px 'M PLUS Rounded 1c', sans-serif";
        ctx.lineWidth = 4; ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}
function spawnParticle(c, r, text, color) { state.particles.push(new Particle(c, r, text, color)); }

function draw() {
    ctx.clearRect(0, 0, state.width, state.height);
    
    // ç›¤é¢ã‚¨ãƒªã‚¢ã®ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°è¨­å®šï¼ˆå¤©äº•è£ã‚’éš ã™ãŸã‚ï¼‰
    ctx.save();
    ctx.beginPath();
    ctx.rect(state.boardX - 10, state.boardY - 10, state.boardW + 20, state.boardH + 20);
    ctx.clip();

    ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
    ctx.beginPath();
    ctx.roundRect(state.boardX - 5, state.boardY - 5, state.boardW + 10, state.boardH + 10, 15);
    ctx.fill();

    // Grid
    for(let r=EXTRA_ROWS; r<ROWS; r++) { // è¦‹ãˆã‚‹ç¯„å›²ã ã‘ã‚°ãƒªãƒƒãƒ‰æç”»
        let visualR = r - EXTRA_ROWS;
        for(let c=0; c<COLS; c++) {
            const x = state.boardX + c * state.blockSize;
            const y = state.boardY + visualR * state.blockSize;
            const s = state.blockSize;
            const p = 3;
            
            ctx.fillStyle = "rgba(0, 0, 0, 0.06)"; 
            ctx.beginPath();
            ctx.roundRect(x+p, y+p, s-p*2, s-p*2, 6);
            ctx.fill();

            ctx.strokeStyle = "rgba(0, 0, 0, 0.15)";
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    // Static Blocks
    for(let r=0; r<ROWS; r++) {
        for(let c=0; c<COLS; c++) {
            if(state.grid[r][c] !== 0) {
                const dy = state.animOffsets[r][c] || 0;
                drawBlock(ctx, c, r, state.grid[r][c], false, false, dy);
            }
        }
    }

    // Ghost & Active Block
    if(state.activeBlock) {
        const b = state.activeBlock;
        let dy = 0;
        const iY = Math.floor(b.y);
        while(canPlace(b.x, iY + dy + 1, b.rot, b.values)) dy++;
        
        const ghostCells = getOccupiedCells(b.x, iY + dy, b.rot, b.values.length);
        ghostCells.forEach((c, i) => drawBlock(ctx, c.x, c.y, b.values[i], false, true));

        const cells = getOccupiedCells(b.x, 0, b.rot, b.values.length); 
        cells.forEach((c, i) => {
            const offsets = getBlockOffsets(b.rot, b.values.length);
            const off = offsets[i];
            const px = b.x + off.dx;
            const py = b.y + off.dy; 
            const gridX = px; 
            const gridY = Math.floor(py);
            const fracY = (py - gridY) * state.blockSize;
            drawBlock(ctx, gridX, gridY, b.values[i], true, false, fracY);
        });
    }

    // Effects
    for(let i=state.particles.length-1; i>=0; i--) { state.particles[i].draw(ctx); }
    
    // ã‚¯ãƒªãƒƒãƒ—è§£é™¤
    ctx.restore();

    // ã‚³ãƒ³ãƒœæ¼”å‡ºï¼ˆç›¤é¢ã®ä¸Šã«æç”»ã—ãŸã„ã®ã§ã‚¯ãƒªãƒƒãƒ—å¤–ï¼‰
    if(state.comboAnim) {
        const anim = state.comboAnim;
        const life = anim.life;
        
        ctx.save();
        
        // æ¼”å‡ºï¼šä¸­å¤®ã‹ã‚‰å°‘ã—ä¸Šã«ç§»å‹•
        const startY = state.height/2 + 20;
        const endY = state.height/2 - 50;
        const currentY = endY + (startY - endY) * life; // life 1->0 ã§ä¸Šã«ç§»å‹•

        // æ¼”å‡ºï¼šãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ï¼†ã‚¢ã‚¦ãƒˆ
        let alpha = 1.0;
        if(life > 0.8) alpha = (1.0 - life) * 5.0; // 0.0 -> 1.0
        else if(life < 0.2) alpha = life * 5.0;    // 1.0 -> 0.0
        
        ctx.translate(state.width/2, currentY);
        let scale = 1 + Math.sin(life * Math.PI) * 0.1;
        ctx.scale(scale, scale);
        
        ctx.globalAlpha = alpha;
        
        // --- ã‚³ãƒ³ãƒœæ•°ã¨å¾—ç‚¹ã®å‹•çš„ã‚µã‚¤ã‚ºè¨ˆç®— ---
        const comboNum = parseInt(anim.text) || 0;
        // ã‚³ãƒ³ãƒœã‚µã‚¤ã‚º: åŸºæœ¬50px + (ã‚³ãƒ³ãƒœæ•° * 5px)ã€‚æœ€å¤§+30pxã¾ã§ã€‚
        const comboSize = 50 + Math.min(30, comboNum * 5);
        // å¾—ç‚¹ã‚µã‚¤ã‚º: åŸºæœ¬55px + (å¾—ç‚¹ / 10)ã€‚æœ€å¤§+25pxã¾ã§ã€‚
        const scoreSize = 55 + Math.min(25, anim.score / 10);

        // ã‚³ãƒ³ãƒœæ•°
        ctx.fillStyle = "#ffdf40"; ctx.strokeStyle = "#fff";
        ctx.font = `900 ${comboSize}px 'M PLUS Rounded 1c', sans-serif`;
        ctx.textAlign = "center"; ctx.textBaseline = "bottom"; ctx.lineWidth = 6;
        ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 10;
        
        // ä½ç½®èª¿æ•´: å°‘ã—ä¸Šã«ãšã‚‰ã™
        ctx.strokeText(anim.text, 0, -10);
        ctx.fillText(anim.text, 0, -10);

        // ã‚¹ã‚³ã‚¢
        ctx.fillStyle = "#fff"; 
        ctx.font = `800 ${scoreSize}px 'M PLUS Rounded 1c', sans-serif`;
        ctx.textBaseline = "top";
        
        // ä½ç½®èª¿æ•´: å°‘ã—ä¸‹ã«ãšã‚‰ã™
        ctx.strokeText(`+${anim.score}`, 0, 15);
        ctx.fillText(`+${anim.score}`, 0, 15);

        ctx.restore();
    }
}

function drawBlock(ctx, c, r, val, isActive=false, isGhost=false, offsetY_px=0) {
    // å¤©äº•è£è£œæ­£
    let visualR = r - EXTRA_ROWS;
    
    const x = state.boardX + c * state.blockSize;
    const y = state.boardY + visualR * state.blockSize + offsetY_px; 
    const s = state.blockSize;
    const p = 2; 

    // å¤©äº•è£ã‚ˆã‚Šä¸Šã«ã‚ã‚‹å ´åˆã¯æç”»ã—ãªã„ï¼ˆã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°ã§æ¶ˆãˆã‚‹ãŒã€ç„¡é§„ãªæç”»ã‚’çœãï¼‰
    if (y + s < state.boardY && !isActive) return;

    let bg = "#ecf0f1"; let fg = "#2c3e50";
    if(val === BLOCK_VAL_OBSTACLE) { 
        bg = "#b2bec3"; 
    } else {
        const colors = [
            "#ff9a9e", "#a18cd1", "#fad0c4", "#84fab0", 
            "#a1c4fd", "#fbc2eb", "#f6d365", "#ff9a9e", "#c2e9fb"
        ];
        if(val >= 1 && val <= 9) bg = colors[val-1];
        fg = "#fff";
    }

    const alphaBg = isGhost ? 0.3 : 1.0;
    const alphaText = isGhost ? 0.8 : 1.0;

    ctx.save();
    if(isActive) {
        ctx.shadowColor = "rgba(0,0,0,0.2)"; ctx.shadowBlur = 15; ctx.zIndex = 10;
    }

    ctx.globalAlpha = alphaBg;
    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.roundRect(x+p, y+p, s-p*2, s-p*2, s*0.4); 
    ctx.fill();
    ctx.shadowBlur = 0;

    if(val !== BLOCK_VAL_OBSTACLE && !isGhost) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.beginPath();
        ctx.ellipse(x + s*0.3, y + s*0.3, s*0.15, s*0.1, Math.PI / 4, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.globalAlpha = alphaText;
    if(val === BLOCK_VAL_OBSTACLE) {
        ctx.fillStyle = "#7f8c8d";
        ctx.beginPath();
        ctx.arc(x+s*0.35, y+s*0.4, s*0.08, 0, Math.PI*2);
        ctx.arc(x+s*0.65, y+s*0.4, s*0.08, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#7f8c8d"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x+s*0.5, y+s*0.7, s*0.2, Math.PI, Math.PI*2); ctx.stroke();
    } else {
        ctx.fillStyle = fg;
        ctx.font = `800 ${s*0.6}px 'M PLUS Rounded 1c', sans-serif`;
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        if(!isGhost) {
            ctx.shadowColor = "rgba(0,0,0,0.1)"; ctx.shadowBlur = 2; ctx.shadowOffsetY = 2;
        }
        ctx.fillText(val, x+s/2, y+s/2+2);
    }
    ctx.restore();
}

function drawNextBlock() {
    nextCtx.clearRect(0,0,nextCanvas.width, nextCanvas.height);
    const vals = state.nextBlockValues;
    if(!vals || vals.length===0) return;
    const bSize = NEXT_BLOCK_SIZE; 
    const totalW = vals.length * bSize;
    const startX = (nextCanvas.width - totalW)/2;
    const startY = (nextCanvas.height - bSize)/2;

    for(let i=0; i<vals.length; i++) {
        let val = vals[i];
        const colors = ["#ff9a9e", "#a18cd1", "#fad0c4", "#84fab0", "#a1c4fd", "#fbc2eb", "#f6d365", "#ff9a9e", "#c2e9fb"];
        nextCtx.fillStyle = colors[val-1] || "#ecf0f1";
        nextCtx.beginPath();
        nextCtx.roundRect(startX + i*bSize + 2, startY+2, bSize-4, bSize-4, 20);
        nextCtx.fill();
        
        nextCtx.fillStyle = "rgba(255,255,255,0.4)";
        nextCtx.beginPath();
        nextCtx.ellipse(startX + i*bSize + bSize*0.3, startY + bSize*0.3, bSize*0.15, bSize*0.1, Math.PI/4, 0, Math.PI*2);
        nextCtx.fill();

        nextCtx.fillStyle = "#fff";
        nextCtx.font = "800 32px 'M PLUS Rounded 1c', sans-serif";
        nextCtx.textAlign = "center"; nextCtx.textBaseline = "middle";
        nextCtx.shadowColor = "rgba(0,0,0,0.1)"; nextCtx.shadowOffsetY = 2;
        nextCtx.fillText(val, startX + i*bSize + bSize/2, startY + bSize/2 + 2);
        nextCtx.shadowOffsetY = 0;
    }
}

// --- Control Handlers ---
function gameOver() {
    state.screen = 'GAMEOVER';
    if(state.timerId) clearTimeout(state.timerId); state.timerId = null;
    ui.controls.classList.add('hidden'); ui.btnToTitle.classList.add('hidden');
    saveScore(state.difficulty, state.score); incrementClear(state.difficulty);
    ui.result.innerHTML = `
        <div style="background:#fff; padding:25px; border-radius:25px; border:5px solid #ff9a9e; color:#555; box-shadow: 0 10px 25px rgba(0,0,0,0.1);">
            <h2 style="color:#ff9a9e; border:none; font-size: 2rem;">GAME OVER</h2>
            <div style="font-size:1.5rem; margin:20px 0;">SCORE: <span style="color:#f6d365; font-weight:800; text-shadow:1px 1px 0 #ddd;">${state.score}</span></div>
            <button id="btn-retry" class="btn btn-success" style="width:100%; margin-bottom:10px;">ã‚‚ã†ã„ã¡ã©</button>
            <button id="btn-home" class="btn" style="background:#eee; color:#777; width:100%;">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
        </div>
    `;
    ui.result.style.display = 'block';
    document.getElementById('btn-retry').onclick = () => { ui.result.style.display='none'; startGame(); };
    document.getElementById('btn-home').onclick = () => { ui.result.style.display='none'; backToTitle(); };
}

function startGame() {
    if(state.timerId) clearTimeout(state.timerId); state.timerId = null;
    state.screen = 'PLAYING';
    state.score = 0; state.combo = 0; state.dropCount = 0; state.riseCounter = 0;
    
    state.round = 1;
    state.targetScore = currentConfig.clearScore;
    state.currentRiseInterval = currentConfig.riseInterval;
    
    state.nextBlockValues = []; state.inputLocked = false; state.fastDropping = false;
    state.particles = []; state.comboAnim = null;
    ui.level.textContent = currentConfig.label;
    ui.title.classList.add('hidden'); ui.rankingScreen.classList.add('hidden');
    ui.roundClearScreen.classList.add('hidden');
    ui.controls.classList.remove('hidden'); ui.btnToTitle.classList.remove('hidden');
    initGrid(); resize(); spawnBlock(); updateUI(); draw();
}

function showRoundClear() {
    state.screen = 'ROUND_CLEAR';
    if(state.timerId) clearTimeout(state.timerId);
    state.timerId = null;

    ui.nextTargetScore.textContent = state.targetScore + currentConfig.clearScore;
    ui.roundClearScreen.classList.remove('hidden');
    ui.controls.classList.add('hidden');
}

function nextRound() {
    state.round++;
    state.targetScore += currentConfig.clearScore;
    state.currentRiseInterval = Math.max(2, state.currentRiseInterval - 1);
    
    ui.roundClearScreen.classList.add('hidden');
    ui.controls.classList.remove('hidden');
    state.screen = 'PLAYING';
    state.inputLocked = false;
    updateUI();
    spawnBlock();
}

function backToTitle() {
    if(state.timerId) clearTimeout(state.timerId); state.timerId = null;
    state.screen = 'TITLE';
    ui.title.classList.remove('hidden'); ui.controls.classList.add('hidden');
    ui.btnToTitle.classList.add('hidden'); updateTitleStats();
}

function updateUI() {
    ui.score.textContent = state.score;
    ui.combo.textContent = state.combo;
    ui.round.textContent = state.round;
}

function bind(el, fn) {
    if(!el) return;
    const handler = (e) => { e.preventDefault(); fn(); };
    el.addEventListener('mousedown', handler);
    el.addEventListener('touchstart', handler, {passive:false});
}

bind(ui.btnToTitle, backToTitle);
bind(ui.btnEasy, () => { state.difficulty='EASY'; currentConfig=CONFIGS.EASY; startGame(); });
bind(ui.btnNormal, () => { state.difficulty='NORMAL'; currentConfig=CONFIGS.NORMAL; startGame(); });
bind(ui.btnHard, () => { state.difficulty='HARD'; currentConfig=CONFIGS.HARD; startGame(); });

bind(ui.btnNextRound, nextRound);
bind(ui.btnQuitRound, gameOver);

bind(document.getElementById('btn-left'), () => moveBlock(-1));
bind(document.getElementById('btn-right'), () => moveBlock(1));
bind(document.getElementById('btn-rotate'), () => rotateBlock());
bind(document.getElementById('btn-drop'), () => dropBlock());

window.addEventListener('keydown', (e) => {
    if(ui.title.classList.contains('hidden') && state.screen === 'PLAYING') {
        if(e.key === 'ArrowLeft') moveBlock(-1);
        if(e.key === 'ArrowRight') moveBlock(1);
        if(e.key === 'ArrowUp') rotateBlock();
        if(e.key === 'ArrowDown' || e.key === ' ') dropBlock();
    }
});

bind(ui.btnRanking, () => {
    ui.rankingScreen.classList.remove('hidden');
    ['easy','normal','hard'].forEach(d => {
        const ul = document.getElementById(`rank-list-${d}`);
        ul.innerHTML = '<li>èª­ã¿è¾¼ã¿ä¸­...</li>';
        if(window.currentUser) {
            window.fetchOnlineRanking(d.toUpperCase()).then(list => {
                ul.innerHTML = '';
                if(!list.length) ul.innerHTML = '<li>ãªã—</li>';
                list.forEach((x,i) => { ul.innerHTML += `<li><span>${i+1}. ${x.name}</span><span>${x.score}</span></li>`; });
            });
        } else {
            const list = getLocalRanking(d.toUpperCase());
            ul.innerHTML = '';
            if(!list.length) ul.innerHTML = '<li>ãªã—</li>';
            list.forEach((s,i) => { ul.innerHTML += `<li><span>${i+1}. ã‚ãªãŸ</span><span>${s}</span></li>`; });
        }
    });
});
bind(ui.btnCloseRank, () => ui.rankingScreen.classList.add('hidden'));
bind(ui.btnIndex, () => window.location.href="index.html");

backToTitle();
</script>
</body>
</html>
