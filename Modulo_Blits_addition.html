<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„É¢„Ç∏„É•„É≠ „Éñ„É™„ÉÉ„ÉÑ - Math Braves</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Zen+Kaku+Gothic+New:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        /* Âü∫Êú¨„Çπ„Çø„Ç§„É´ */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
            background-color: #0b1021; /* ËÉåÊôØ„Çí„ÉÄ„Éº„ÇØ„Éç„Ç§„Éì„Éº„Å´ */
            font-family: "Zen Kaku Gothic New", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            position: relative;
        }

        /* „Ç≤„Éº„É†ÂÖ®‰Ωì„ÅÆ„Ç≥„É≥„ÉÜ„ÉäÔºà1280x720 Âõ∫ÂÆöËß£ÂÉèÂ∫¶„ÉªÁµ∂ÂØæÈÖçÁΩÆÔºâ */
        #game-root {
            width: 1280px; 
            height: 720px;
            position: absolute;
            top: 50%;
            left: 50%;
            /* transform„ÅØJS„ÅßÂà∂Âæ° */
            background-color: #0b1021;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden;
        }

        #container {
            display: flex;
            width: 100%;
            height: 100%;
        }
        #left-panel, #right-panel {
            flex: 1;
            background-color: #15192b; /* „Éë„Éç„É´„ÇÇ„ÉÄ„Éº„ÇØ„Å´ */
            color: #a0aab5;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            z-index: 5;
            border-right: 1px solid #2a3b55;
            border-left: 1px solid #2a3b55;
        }
        /* ‰∏≠Â§Æ„Ç®„É™„Ç¢ÔºöËÉåÊôØÈÄèÊòé„ÄÅÊû†„Å™„Åó„ÅßCanvas„ÅÆ„Åø„ÇíË°®Á§∫ */
        #game-area {
            flex: 2;
            position: relative;
            background-color: transparent; 
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        h2 { 
            margin-top: 0; 
            border-bottom: 2px solid #00f0ff; /* „Ç∑„Ç¢„É≥ */
            padding-bottom: 10px; 
            font-size: 1.4rem; 
            color: #00f0ff;
            font-weight: bold;
            letter-spacing: 1px;
        }
        p, .info-label { color: #a0aab5; font-weight: bold;}
        
        .info-item { margin-bottom: 15px; font-size: 1.0rem; }
        .info-value { font-size: 1.8rem; font-weight: bold; color: #fff; text-shadow: 0 0 5px rgba(255,255,255,0.5); font-family: 'Orbitron', sans-serif;}
        
        #disp-actions {
            font-size: 4rem !important;
            color: #00f0ff !important; /* „Ç∑„Ç¢„É≥ */
            line-height: 1;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.6);
        }
        
        /* „Ç¨„Ç§„Éâ„Çπ„Ç§„ÉÉ„ÉÅ */
        .guide-switch-container {
            display: flex;
            align-items: center;
            margin-top: 5px;
            background: rgba(255,255,255,0.1);
            padding: 5px 10px;
            border-radius: 20px;
            cursor: pointer;
            width: fit-content;
        }
        .guide-label { font-size: 0.9rem; margin-right: 10px; color: #fff; }
        .toggle-btn {
            width: 40px; height: 20px; background: #4a5568; border-radius: 10px; position: relative; transition: 0.3s;
        }
        .toggle-btn::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px;
            background: #fff; border-radius: 50%; transition: 0.3s;
        }
        .guide-on .toggle-btn { background: #00f0ff; }
        .guide-on .toggle-btn::after { left: 22px; }

        .rank-invalid-badge {
            display: inline-block;
            background: #e74c3c;
            color: white;
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 4px;
            margin-left: 5px;
            vertical-align: middle;
        }

        .invisible { visibility: hidden; }
        .hidden { display: none !important; }

        /* „Éú„Çø„É≥ÂÖ±ÈÄö */
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; border: none; padding: 10px 20px;
            border-radius: 4px; cursor: pointer; font-size: 1rem; margin: 5px;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
            font-family: "Zen Kaku Gothic New", sans-serif;
            font-weight: bold;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(118, 75, 162, 0.6); filter: brightness(1.1); }
        .btn:active { transform: translateY(1px); box-shadow: 0 2px 10px rgba(118, 75, 162, 0.4); }
        
        .btn-danger { background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%); box-shadow: 0 4px 15px rgba(255, 75, 43, 0.4); }
        .btn-danger:hover { box-shadow: 0 6px 20px rgba(255, 75, 43, 0.6); }
        
        .btn-success { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); box-shadow: 0 4px 15px rgba(56, 239, 125, 0.4); }
        .btn-success:hover { box-shadow: 0 6px 20px rgba(56, 239, 125, 0.6); }

        .btn-warning { background: linear-gradient(135deg, #f09819 0%, #edde5d 100%); color: #333; box-shadow: 0 4px 15px rgba(240, 152, 25, 0.4); }
        
        .btn-auth {
            background: #ea4335; box-shadow: 0 4px 0 #d93025;
            color: white; padding: 6px 20px; font-weight: bold; margin-top: 5px; font-size: 0.9rem;
        }

        #overlay, #ranking-overlay, #game-result, #continue-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.9);
            display: flex; justify-content: center; align-items: center;
            z-index: 100;
            flex-direction: column;
            color: white;
            backdrop-filter: blur(5px);
        }
        .overlay-content {
            background: #1a2035;
            padding: 30px; border-radius: 12px;
            text-align: center; max-width: 90%; width: 90%;
            max-height: 95%; /* ‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„Çã */
            overflow-y: hidden; /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÇíÊ∂à„Åô */
            border: 1px solid #2a3b55;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            /* „Çπ„ÇØ„É≠„Éº„É´„Éê„ÉºÈùûË°®Á§∫ */
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .overlay-content::-webkit-scrollbar {
            display: none;
        }
        
        /* „Çø„Ç§„Éà„É´ÁîªÈù¢ÔºàBOXÂâäÈô§„ÉªÈñìÈöîË™øÊï¥Ôºâ */
        #title-screen {
            background: transparent;
            border: none;
            box-shadow: none;
            color: #fff;
            position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:10;
            width: 80% !important; 
            max-width: 600px;
            text-align: center;
        }
        
        #title-h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem; 
            margin: 0 0 10px 0; /* Â∞ë„ÅóÂ∫É„Åí„Çã */
            color: #fff;
            text-shadow: 0 0 20px #00f0ff;
            letter-spacing: 2px;
        }
        
        #title-sub {
            font-size: 0.9rem;
            margin-top: 0; 
            margin-bottom: 20px; /* Â∞ë„ÅóÂ∫É„Åí„Çã */
            font-weight: bold; 
            color: #a0aab5;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        /* „Éü„Éã„Ç≤„Éº„É†ÁîªÈù¢Ôºà„Éì„Ç∏„É•„Ç¢„É´„Ç®„Ç§„ÉâÔºâ */
        .mini-grid-container {
            display: flex; flex-direction: column; align-items: center;
            margin: 0 auto 20px auto; padding: 5px; /* Â∞ë„ÅóÂ∫É„Åí„Çã */
            background: rgba(0,0,0,0.3); border-radius: 8px; width: fit-content;
        }
        .mini-grid {
            display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px;
            width: 100px; height: 100px;
            background: #2a3b55; padding: 2px; border: 1px solid #4a5568;
        }
        .mini-cell {
            background: #edf2f7; display: flex; justify-content: center; align-items: center;
            font-size: 10px; font-weight: bold; color: #2d3748; border-radius: 1px;
        }
        .mini-cell.target { background: #f6e05e; color: #744210; box-shadow: inset 0 0 2px rgba(0,0,0,0.2); }
        .mini-cell.match { background: #9f7aea; color: #fff; }
        .mini-cell.empty { background: #2d3748; }
        .mini-label { margin-top: 2px; font-size: 0.7rem; color: #00f0ff; }

        #disp-targets {
            font-size: 1.2rem; font-weight: bold; color: #00f0ff; 
            display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
        }
        .target-wrapper { display: flex; flex-direction: column; align-items: center; margin: 2px; }
        .target-item {
            display: flex; justify-content: center; align-items: center;
            background-color: #00f0ff; color: #0b1021; border-radius: 50%;
            width: 45px; height: 45px; font-size: 1.4rem; font-weight: bold;
            box-shadow: 0 0 10px #00f0ff; border: 2px solid #fff;
            animation: pulse-target-ui 3s infinite ease-in-out;
            font-family: 'Orbitron', sans-serif;
        }

        @keyframes pulse-target-ui {
            0% { transform: scale(1); box-shadow: 0 0 10px #00f0ff; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px #00f0ff; }
            100% { transform: scale(1); box-shadow: 0 0 10px #00f0ff; }
        }

        .difficulty-container {
            display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; align-items: flex-end; /* Â∞ë„ÅóÂ∫É„Åí„Çã */
        }
        .diff-wrapper { display: flex; flex-direction: column; align-items: center; position: relative; }
        .crown-icon { font-size: 1.2rem; margin-bottom: -5px; text-shadow: 0 0 10px rgba(255,215,0,0.5); visibility: hidden; }
        .clear-count-text { font-size: 0.7rem; color: #a0aab5; font-weight: bold; margin-top: 2px; }
        .difficulty-container button { width: 90px; padding: 8px 0; font-size: 0.85rem; font-weight: bold; margin: 0; }
        
        .ranking-container { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: nowrap; padding-bottom: 0; }
        .ranking-box { background: #2d3748; padding: 10px; border-radius: 8px; flex: 1; min-width: 0; border: 1px solid #4a5568; }
        .ranking-title { font-weight: bold; color: #f1c40f; margin-bottom: 8px; border-bottom: 1px solid #4a5568; padding-bottom: 5px; font-size: 1rem; }
        .ranking-list { list-style: none; padding: 0; margin: 0; text-align: left; font-size: 0.85rem; height: 300px; overflow-y: auto; }
        .ranking-list li { padding: 5px 0; border-bottom: 1px dashed #4a5568; display: flex; justify-content: space-between; color: #e2e8f0; }
        .ranking-rank { display: inline-block; width: 20px; color: #a0aab5; }
        .ranking-name { display: inline-block; width: 80px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; vertical-align: bottom; }
        .ranking-score { font-weight: bold; color: #00f0ff; float: right; font-family: 'Orbitron', monospace; }

        /* ÂêçÂâçÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ */
        #name-input-container { margin: 15px 0; } /* Â∞ë„ÅóÂ∫É„Åí„Çã */
        #nickname-input {
            font-size: 16px; padding: 6px; text-align: center;
            border: 2px solid #00f0ff; border-radius: 8px;
            font-family: 'Zen Kaku Gothic New', sans-serif;
            color: #0b1021; width: 70%; outline: none; background: #fff;
        }
        #nickname-input::placeholder { color: #aaa; }
        .action-row { display: flex; gap: 10px; width: 100%; justify-content: center; margin-top: 15px; } /* Â∞ë„ÅóÂ∫É„Åí„Çã */

    </style>
</head>
<body>

<div id="game-root">
    <div id="container">
        <div id="left-panel">
            <h2>„ÅÇ„Åù„Å≥„Åã„Åü</h2>
            <div style="font-size: 0.9rem; line-height: 1.6;">
                <p><strong>1. „Ç´„Éº„Éâ„Çí„Åä„Åè</strong><br>
                   „Å¶„Åµ„Å†„ÅÆ „Ç´„Éº„Éâ„Çí „Éû„Çπ„Å´ „Åä„Åì„ÅÜ„ÄÇ<br>
                   „Åü„Åó„Åñ„Çì„Åß 10„Çí„Åì„Åà„Çã„Å®<br>
                   1„ÅÆ„Åè„Çâ„ÅÑ„Å´ „ÇÇ„Å©„Çã„Çà„ÄÇ<br>
                   <span style="color:#718096; font-size:0.8rem;">(„Çå„ÅÑ: 7 + 5 = 12 ‚Üí 2 )</span></p>
                
                <p><strong>2. 3„Å§„Åù„Çç„Åà„Å¶ „Åë„Åô</strong><br>
                   „Åä„Å™„Åò „Åô„ÅÜ„Åò„Çí „Çø„ÉÜ„Éª„É®„Ç≥„Å´<br>
                   3„Å§ „ÅÑ„Åò„Çá„ÅÜ „Å§„Å™„Åí„Çà„ÅÜ„ÄÇ<br>
                   „Åæ„Åå„Å£„Å¶„ÅÑ„Å¶„ÇÇ OKÔºÅ</p>
                
                <p><strong>3. „Çø„Éº„Ç≤„ÉÉ„Éà „Éú„Éº„Éä„Çπ</strong><br>
                   <strong>„Çø„Éº„Ç≤„ÉÉ„Éà</strong>„ÅÆ „Åô„ÅÜ„Åò„Çí<br>
                   „Åë„Åô„Å® <strong>„Çπ„Ç≥„Ç¢ 2„Å∞„ÅÑÔºÅ</strong></p>
                
                <p><strong>4. „Åä„Åò„ÇÉ„Åæ„Éñ„É≠„ÉÉ„ÇØ</strong><br>
                   <span style="color:#a0aec0; font-weight:bold;">„Åè„Çç„ÅÑ „Éñ„É≠„ÉÉ„ÇØ</span> „ÅØ<br>
                   „Ç´„Éº„Éâ„Çí „Åä„Åë„Å™„ÅÑ„Çà„ÄÇ<br>
                   „Å®„Å™„Çä„Åß „Åë„Åó„Å¶ „Åì„Çè„Åù„ÅÜÔºÅ</p>
            </div>
            <div style="margin-top:auto; text-align:center;">
                <button id="btn-to-title" class="btn btn-danger hidden">„Çø„Ç§„Éà„É´„Å∏</button>
            </div>
        </div>

        <div id="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <div id="title-screen" class="overlay-content">
                <h1 id="title-h1">5x5 Modulo Blitz<br><span style="font-size:0.5em">5√ó5 „É¢„Ç∏„É•„É≠ „Éñ„É™„ÉÉ„ÉÑ</span></h1>
                
                <div class="mini-grid-container">
                    <div class="mini-grid">
                        <div class="mini-cell">2</div><div class="mini-cell">5</div><div class="mini-cell empty"></div><div class="mini-cell">9</div><div class="mini-cell">1</div>
                        <div class="mini-cell">8</div><div class="mini-cell match">3</div><div class="mini-cell match">3</div><div class="mini-cell match">3</div><div class="mini-cell">4</div>
                        <div class="mini-cell">1</div><div class="mini-cell">7</div><div class="mini-cell match">3</div><div class="mini-cell">6</div><div class="mini-cell">2</div>
                        <div class="mini-cell">5</div><div class="mini-cell empty"></div><div class="mini-cell match">3</div><div class="mini-cell target">7</div><div class="mini-cell">9</div>
                        <div class="mini-cell">4</div><div class="mini-cell">2</div><div class="mini-cell">8</div><div class="mini-cell">1</div><div class="mini-cell">5</div>
                    </div>
                    </div>

                <div class="difficulty-container">
                    <div class="diff-wrapper">
                        <div id="crown-EASY" class="crown-icon">üëë</div>
                        <button id="btn-easy" class="btn btn-success">„Åã„Çì„Åü„Çì</button>
                        <div id="clear-EASY" class="clear-count-text">„ÇØ„É™„Ç¢: 0Âõû</div>
                    </div>
                    <div class="diff-wrapper">
                        <div id="crown-NORMAL" class="crown-icon">üëë</div>
                        <button id="btn-normal" class="btn">„Åµ„Å§„ÅÜ</button>
                        <div id="clear-NORMAL" class="clear-count-text">„ÇØ„É™„Ç¢: 0Âõû</div>
                    </div>
                    <div class="diff-wrapper">
                        <div id="crown-HARD" class="crown-icon">üëë</div>
                        <button id="btn-hard" class="btn btn-danger">„ÇÄ„Åö„Åã„Åó„ÅÑ</button>
                        <div id="clear-HARD" class="clear-count-text">„ÇØ„É™„Ç¢: 0Âõû</div>
                    </div>
                </div>

                <div id="auth-status" style="margin-top: 2px; font-size: 0.7rem; color: #a0aab5;">„Ç≤„Çπ„Éà</div>
                <button id="btn-login" class="btn btn-auth">Google„Åß„É≠„Ç∞„Ç§„É≥</button>
                <button id="btn-logout" class="btn btn-danger hidden" style="padding:6px 20px; font-size:0.9rem; margin-top:5px;">„É≠„Ç∞„Ç¢„Ç¶„Éà</button>

                <div id="name-input-container">
                    <input type="text" id="nickname-input" placeholder="„Åä„Å™„Åæ„ÅàÔºà„Å≤„Çâ„Åå„Å™Ôºò„ÇÇ„Åò„Åæ„ÅßÔºâ" maxlength="8">
                    </div>

                <div class="action-row">
                    <button id="btn-view-ranking" class="btn btn-warning" style="flex:1;">„É©„É≥„Ç≠„É≥„Ç∞</button>
                    <button id="btn-index" class="btn" style="background-color: #4a5568; flex:1;">„Éõ„Éº„É†„Å∏</button>
                </div>
            </div>

            <div id="game-result" class="hidden">
                <div class="overlay-content" style="background: #1a2035; border: 2px solid #f1c40f;">
                    <h2 id="result-header" style="font-size: 2.5rem; color: #f1c40f; margin: 0 0 20px 0;"></h2>
                    <div id="result-detail" style="font-size: 1.5rem; line-height: 1.8; color:#fff;"></div>
                    <button id="btn-result-ok" class="btn btn-success" style="font-size: 1.2rem; padding: 10px 40px; margin-top: 20px;">„Çø„Ç§„Éà„É´„Å∏</button>
                </div>
            </div>

            <div id="continue-screen" class="hidden">
                <div class="overlay-content" style="background: #1a2035; border: 2px solid #00f0ff;">
                    <h2 style="font-size: 2.5rem; color: #00f0ff; margin: 0 0 20px 0;">„É©„Ç¶„É≥„Éâ „ÇØ„É™„Ç¢ÔºÅ</h2>
                    <p style="font-size: 1.2rem; color:#fff;">„ÇÇ„Åè„Å≤„Çá„ÅÜ „Åü„Å£„Åõ„ÅÑÔºÅ</p>
                    <p style="font-size: 1.5rem; font-weight: bold; margin-bottom: 30px; color:#fff;">„Å§„Åé„ÅÆ„É©„Ç¶„É≥„Éâ„Å∏ „Åô„Åô„ÇÄÔºü<br><span style="font-size:1rem; color:#e74c3c;">(„Åä„Åò„ÇÉ„Åæ„Éñ„É≠„ÉÉ„ÇØ„Åå „Åµ„Åà„Çã„ÇàÔºÅ)</span></p>
                    <button id="btn-continue-yes" class="btn btn-success" style="font-size: 1.2rem; padding: 10px 30px;">„ÅØ„ÅÑ</button>
                    <button id="btn-continue-no" class="btn btn-danger" style="font-size: 1.2rem; padding: 10px 30px; margin-left: 20px;">„ÅÑ„ÅÑ„Åà</button>
                </div>
            </div>

            <div id="ranking-screen" class="hidden">
                <div id="ranking-overlay">
                    <div class="overlay-content" style="width: 95%; max-width: 900px;">
                        <h2 id="ranking-header-title" style="color: #f1c40f; margin-top: 0;">„É©„É≥„Ç≠„É≥„Ç∞ („Éà„ÉÉ„Éó10)</h2>
                        <div class="ranking-container">
                            <div class="ranking-box">
                                <div class="ranking-title" style="color: #2ecc71;">„Åã„Çì„Åü„Çì</div>
                                <ul id="rank-list-EASY" class="ranking-list"></ul>
                            </div>
                            <div class="ranking-box">
                                <div class="ranking-title" style="color: #9b59b6;">„Åµ„Å§„ÅÜ</div>
                                <ul id="rank-list-NORMAL" class="ranking-list"></ul>
                            </div>
                            <div class="ranking-box">
                                <div class="ranking-title" style="color: #e74c3c;">„ÇÄ„Åö„Åã„Åó„ÅÑ</div>
                                <ul id="rank-list-HARD" class="ranking-list"></ul>
                            </div>
                        </div>
                        <button id="btn-close-ranking" class="btn">„Å®„Åò„Çã</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="right-panel">
            <div id="right-panel-content">
                <div class="info-item">
                    <div class="info-label">„É¨„Éô„É´ („É©„Ç¶„É≥„Éâ)</div>
                    <div style="display:flex; align-items:center; flex-wrap:wrap;">
                        <div id="disp-difficulty-label" class="info-value" style="font-size: 1.4rem; color: #fff; margin-right:10px;"></div>
                        <span id="rank-invalid-badge" class="rank-invalid-badge hidden">„É©„É≥„Ç≠„É≥„Ç∞„Å™„Åó</span>
                    </div>
                    
                    <div id="btn-guide-toggle" class="guide-switch-container">
                        <span class="guide-label">„Ç¨„Ç§„Éâ</span>
                        <div class="toggle-btn"></div>
                    </div>
                </div>
                
                <div class="info-item">
                    <div class="info-label">„ÅÆ„Åì„ÇäÂõûÊï∞</div>
                    <div id="disp-actions" class="info-value">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">„ÇÇ„Åè„Å≤„Çá„ÅÜ</div>
                    <div id="disp-goal-score" class="info-value" style="color:#00f0ff;">0</div>
                </div>
                 <div class="info-item">
                    <div class="info-label">„Åî„ÅÜ„Åë„ÅÑ</div>
                    <div id="disp-total-score" class="info-value" style="color:#f1c40f;">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">‰ªä„ÅÆ„Çπ„Ç≥„Ç¢</div>
                    <div id="disp-last-score" class="info-value" style="font-size: 1.2rem;">0</div>
                </div>
                <hr style="border-color: #2a3b55; margin: 15px 0;">
                <div class="info-item">
                    <div class="info-label">„Çø„Éº„Ç≤„ÉÉ„Éà</div>
                    <div id="disp-targets" class="info-value"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, serverTimestamp, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
      authDomain: "math-braves.firebaseapp.com",
      projectId: "math-braves",
      storageBucket: "math-braves.firebasestorage.app",
      messagingSenderId: "217117619290",
      appId: "1:217117619290:web:d227feb603970d3948d463"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new GoogleAuthProvider();
    const FIREBASE_COLLECTION_NAME = "scores_modulo"; 

    window.currentUser = null; 
    const btnLogin = document.getElementById('btn-login');
    const btnLogout = document.getElementById('btn-logout');
    const authStatus = document.getElementById('auth-status');
    const nicknameInput = document.getElementById('nickname-input'); // ÂêçÂâçÂÖ•ÂäõÊ¨Ñ

    window.handleLogin = function() {
        signInWithPopup(auth, provider).catch((error) => { alert("Login failed."); });
    };

    window.handleLogout = function() {
        signOut(auth);
    };

    onAuthStateChanged(auth, (user) => {
        if (user) {
            window.currentUser = { uid: user.uid, displayName: user.displayName || 'No Name' };
            if(authStatus) authStatus.textContent = `User: ${window.currentUser.displayName}`;
            if(btnLogin) btnLogin.classList.add('hidden');
            if(btnLogout) btnLogout.classList.remove('hidden');
        } else {
            window.currentUser = null;
            if(authStatus) authStatus.textContent = '„Ç≤„Çπ„Éà';
            if(btnLogin) btnLogin.classList.remove('hidden');
            if(btnLogout) btnLogout.classList.add('hidden');
        }
    });

    window.saveOnlineScore = async (userId, userName, difficulty, score) => {
        try {
            const docId = `${userId}_${difficulty}_${Date.now()}`;
            await setDoc(doc(db, FIREBASE_COLLECTION_NAME, docId), {
                uid: userId,
                name: userName,
                difficulty: difficulty,
                score: score,
                createdAt: serverTimestamp()
            });
        } catch (error) { console.error(error); }
    };

    window.fetchOnlineRanking = async (difficulty) => {
        if (!window.currentUser) return [];
        try {
            const scoresRef = collection(db, FIREBASE_COLLECTION_NAME);
            const q = query(scoresRef, where("difficulty", "==", difficulty), orderBy("score", "desc"), limit(10));
            const querySnapshot = await getDocs(q);
            const ranking = [];
            querySnapshot.forEach((doc) => ranking.push(doc.data()));
            return ranking;
        } catch (error) { return []; }
    };
    
    window.fetchOnlineRankingGlobal = window.fetchOnlineRanking;
</script>
<script>
/**
 * Game Configuration & State
 */

// NG„ÉØ„Éº„Éâ„É™„Çπ„ÉàÔºà„Å≤„Çâ„Åå„Å™Ôºâ
const NG_WORDS_HIRAGANA = [
    '„Åó„Å≠', '„Åó„Å¨', '„Åó„Å´', '„Åì„Çç„Åô', '„Åì„Çç„Åõ', '„Åï„Å§„Åå„ÅÑ', '„Åè„Åü„Å∞„Çå',
    '„Åò„Åï„Å§', '„Åé„Åï„Å§', '„Å§„Çã„Åô', '„Çå„Çì„Åü„Çì', '„Åó„Å´„Åü„ÅÑ',
    '„Å¶„Çç', '„Å¶„Çç„Çä„Åô„Å®', '„Å∞„Åè„ÅØ', '„Å∞„Åè„Å†„Çì', '„Åª„ÅÜ„Åã',
    '„ÅØ„Çì„Åñ„ÅÑ', '„Åî„ÅÜ„Å®„ÅÜ', '„ÇÜ„ÅÜ„Åã„ÅÑ', '„Åã„Çì„Åç„Çì', '„Åä„Åù„ÅÜ',
    '„ÇÑ„Åè„Åñ', '„Åº„ÅÜ„Çä„Çá„Åè', '„ÅØ„Çì„Åê„Çå', '„Å°„Çì„Å¥„Çâ', '„Åæ„Åµ„ÅÉ„ÅÇ',
    '„Åü„ÅÑ„Åæ', '„Åæ„ÇÑ„Åè', '„Åã„Åè„Åõ„ÅÑ„Åñ„ÅÑ', '„Åó„ÇÉ„Å∂', '„Å©„Çâ„Å£„Åê', '„Åì„Åã„ÅÑ„Çì',
    '„Å∏„Çç„ÅÑ„Çì', '„Åà„Åè„Åô„Åü„Åó„Éº', '„Å†„Å£„ÅΩ„ÅÜ', '„Åç„ÇÅ„Åõ„Åè',
    '„ÅÑ„Åò„ÇÅ', '„Åé„ÇÉ„Åè„Åü„ÅÑ',
    '„Å∞„Åã', '„ÅÇ„Åª', '„Åæ„Å¨„Åë', '„Åç„Å°„Åå„ÅÑ', '„ÅçÈÅï„ÅÑ',
    '„ÅÜ„Åñ„ÅÑ', '„ÅÜ„Åñ', '„Åç„ÇÇ„ÅÑ', '„Åç„ÇÇ', '„Åç„Åó„Çá„ÅÑ', '„Åç„Åà„Çç',
    '„Åè„Åö', '„Åî„Åø', '„Åî„Åø„ÇÄ„Åó', '„Åã„Åô', '„Åñ„Åì', '„Åú„Å§',
    '„Å∂„Åô', '„Åß„Å∂', '„ÅØ„Åí', '„Å°„Å≥', '„Åß„Å£„Å±', '„ÅÑ„Å™„Åã„ÇÇ„ÅÆ',
    '„ÅÜ„Åò', '„ÅØ„ÅÑ„Åº„Åè', '„Åæ„Åë„ÅÑ„Å¨', '„Åä„Å§„ÇÄ', '„ÅÆ„ÅÜ„Åü„Çä„Çì',
    '„Å¶„ÅÑ„ÅÆ„ÅÜ', '„Å°„Åó„Çá„ÅÜ', '„Åó„Çá„ÅÜ„Åå„ÅÑ', '„Åå„ÅÑ„Åò', '„Åã„Åü„Çè', '„Å≥„Å£„Åì',
    '„ÇÅ„Åè„Çâ', '„Å§„Çì„Åº', '„Åä„Åó', '„Å©„Åò„Çì', '„Åà„Åü', '„Å≤„Å´„Çì',
    '„Åü„Å≤', '„Åü„Å≤„Å≠',
    '„ÅÜ„Åõ„Çç', '„Å†„Åæ„Çå',
    '„Å°„Çì„Å°„Çì', '„Å°„Çì„Åì', '„Å°„Çì„ÅΩ', '„Å°„Çì„Åã', '„Åæ„Çâ', '„Åï„Åä',
    '„Åæ„Çì„Åì', '„Åæ„Çì„Åó„ÇÖ„ÅÜ', '„Åæ„Çì„Åí', '„Çè„Çå„ÇÅ', '„Åä„Åæ„Åü',
    '„Åè„Çä', '„Åè„Çä„Å®„Çä„Åô', '„ÅÑ„Çì„Åó„Çì', '„ÅÑ„Çì„Åã„Åè', '„Å≥„Çâ„Å≥„Çâ',
    '„Åì„ÅÜ„Åå„Çì', '„Åü„Åæ„Åç„Çì', '„Åç„Çì„Åü„Åæ', '„Åµ„Åê„Çä',
    '„Åä„Å£„Å±„ÅÑ', '„Å°„Å°', '„Å´„ÇÖ„ÅÜ„Çä„Çì', '„Å´„ÇÖ„ÅÜ„Å®„ÅÜ', '„Åç„Çá„Å´„ÇÖ„ÅÜ', '„Å≤„Çì„Å´„ÇÖ„ÅÜ',
    '„Åë„Å§', '„ÅÇ„Å™„Çã', '„Åì„ÅÜ„ÇÇ„Çì', '„Åë„Å§„ÅÆ„ÅÇ„Å™',
    '„Åà„Çç', '„Åà„Å£„Å°', '„Åô„Åë„Åπ', '„Å∏„Çì„Åü„ÅÑ', '„ÇÄ„Å£„Å§„Çä', '„Åó„Åì',
    '„Åõ„Å£„Åè„Åô', '„Åõ„ÅÑ„Åì„ÅÜ', '„Åæ„Åê„Çè„ÅÑ', '„Åù„ÅÜ„Å´„ÇÖ„ÅÜ', '„ÅØ„ÇÅ„Çã',
    '„Åä„Å™„Å´„Éº', '„Åò„ÅÑ', '„Åó„Åì„Åó„Åì', '„Åµ„Åá„Çâ', '„Å±„ÅÑ„Åö„Çä', '„Åè„Çì„Å´',
    '„ÅÑ„Çâ„Åæ', '„Åó„Å£„Åó„Çì', '„Å™„Åã„Å†„Åó', '„Åî„Å£„Åè„Çì', '„Å∂„Å£„Åã„Åë',
    '„Åó„Åä„Åµ„Åç', '„Åú„Å£„Å°„Çá„ÅÜ', '„ÅÑ„Åè', '„ÅÑ„Åã„Åõ„Çç', '„ÅÇ„Åà„Åé',
    '„Å©„ÅÜ„Å¶„ÅÑ', '„Åó„Çá„Åò„Çá', '„ÇÑ„Çä„Åæ„Çì', '„ÇÑ„Çä„Å°„Çì', '„Å≥„Å£„Å°',
    '„Åõ„Åµ„Çå', '„Å±„Åì', '„Å±„Åì„Å±„Åì', '„Çè„ÅÑ„Åõ„Å§', '„Çç„Çä', '„Åó„Çá„Åü', '„Å∫„Å©',
    '„Åç„Çì„Åó„Çì', '„Åò„ÇÖ„ÅÜ„Åã„Çì', '„Çä„Çá„ÅÜ„Åò„Çá„Åè', '„Çâ„Çì„Åì„ÅÜ', '„Åô„Åã„Çì„Å®',
    '„ÅÆ„Éº„Å±„Çì', '„Å±„Çì„Å°„Çâ',
    '„Çå„ÅÑ„Å∑', '„Åî„ÅÜ„Åã„Çì', '„Å°„Åã„Çì', '„Å®„ÅÜ„Åï„Å§', '„ÅÆ„Åû„Åç', '„Çç„Åó„ÇÖ„Å§',
    '„Åµ„ÅÜ„Åû„Åè', '„Åù„Éº„Å∑', '„Å∏„Çã„Åô', '„Åß„Çä„Å∏„Çã', '„Å¥„Çì„Åï„Çç', '„ÅÑ„ÇÅ„Åè„Çâ',
    '„ÅÇ„Å†„Çã„Å®', '„Åà„Éº„Å∂„ÅÑ', '„Åà„Å∂„ÅÑ', '„ÅΩ„Çã„ÅÆ', '„ÅÜ„Çâ„Å≥„Åß„Åä', '„ÇÄ„Åó„ÇÖ„ÅÜ„Åõ„ÅÑ',
    '„Åà„Çì„Åì„ÅÜ', '„Åà„Çì„Åò„Çá', '„ÅÜ„Çä', '„Åã„ÅÑ„Åó„ÇÖ„Çì', '„Å∞„ÅÑ„Åó„ÇÖ„Çì',
    '„Å±„Å±„Åã„Å§', '„Åæ„Åæ„Åã„Å§', '„ÅÜ„Çä„Åõ„Çì',
    '„ÅÜ„Çì„Åì', '„ÅÜ„Çì„Å°', '„Åè„Åù', '„Åí„Çä', '„Åπ„Çì', '„Åµ„Çì',
    '„Åó„Å£„Åì', '„Åó„Çá„Çì„Åπ„Çì', '„Å´„Çá„ÅÜ', '„Åª„ÅÜ„Å´„Çá„ÅÜ',
    '„Å∏', '„Åä„Å™„Çâ', '„Åí„Çç', '„Åü„Çì',
    '„ÅÜ„Çì„Åà„ÅÑ', '„Åì„ÅÜ„Åó„Åç', '„Åô„Åü„Å£„Åµ', '„Åã„Çì„Çä', '„Å±„Å®„Çç„Éº„Çã',
    '„Åò„Åà„ÇÄ', '„Åí„Éº„ÇÄ„Åæ„Åô„Åü„Éº', '„Åæ„Åô„Åü„Éº', '„ÅÇ„Å©„Åø„Çì', '„Åó„Åô„Å¶„ÇÄ',
    '„Åï„Éº„Å∞„Éº', '„ÅÇ„Åã„Å∞„Çì', '„Å∞„Çì', '„Å°„Éº„Å®', '„Å°„Éº„Åü„Éº', '„Å∞„Åê',
    '„Çâ„ÅÑ„Çì', '„Åã„Åã„Åä', '„Åô„Åã„ÅÑ„Å∑', '„ÅÑ„Çì„Åô„Åü', '„Å§„ÅÑ„Å£„Åü„Éº', '„Åß„ÅÉ„Åô„Åì',
    '„Åß„Çì„Çè', '„Å∞„Çì„Åî„ÅÜ', '„Åë„ÅÑ„Åü„ÅÑ', '„ÅÇ„Å©„Çå„Åô', '„ÇÅ„ÅÇ„Å©', '„Åò„ÇÖ„ÅÜ„Åó„Çá',
    '„ÅÇ„Åä', '„ÅÇ„ÅÑ„Åü„ÅÑ', '„Åæ„Å°„ÅÇ„Çè„Åõ', '„Åª„Å¶„Çã', '„Çâ„Å∂„Åª', '„Åä„Åµ„Åã„ÅÑ',
    '„Å±„Åô„Çè„Éº„Å©', '„Å±„Åô', '„ÅÇ„Åã„ÅÜ„Çì„Å®', '„Åì„Åò„Çì„Åò„Çá„ÅÜ„Åª„ÅÜ'
];

const NUMBER_COLORS = {
    1: { bg: '#718096', text: '#FFFFFF' }, // Gray 500
    2: { bg: '#4299E1', text: '#FFFFFF' }, // Blue 500
    3: { bg: '#48BB78', text: '#FFFFFF' }, // Green 500
    4: { bg: '#D69E2E', text: '#FFFFFF' }, // Yellow 600
    5: { bg: '#9F7AEA', text: '#FFFFFF' }, // Purple 500
    6: { bg: '#ED64A6', text: '#FFFFFF' }, // Pink 500
    7: { bg: '#ED8936', text: '#FFFFFF' }, // Orange 500
    8: { bg: '#38B2AC', text: '#FFFFFF' }, // Teal 500
    9: { bg: '#4A5568', text: '#FFFFFF' }, // Gray 700
    10: { bg: '#A0AEC0', text: '#FFFFFF' } // Gray 500
};

// Èõ£ÊòìÂ∫¶Ë®≠ÂÆö
const PRESET_EASY = { 
    label: "„Åã„Çì„Åü„Çì", initialActions: 30, scoreGoal: 10000, 
    handMin: 1, handMax: 9, boardMin: 1, boardMax: 10,
    jammerStart: 0, jammerStep: 0.1 
};
const PRESET_NORMAL = { 
    label: "„Åµ„Å§„ÅÜ", initialActions: 20, scoreGoal: 20000, 
    handMin: 1, handMax: 9, boardMin: 1, boardMax: 10,
    jammerStart: 0.05, jammerStep: 0.1 
};
const PRESET_HARD = { 
    label: "„ÇÄ„Åö„Åã„Åó„ÅÑ", initialActions: 10, scoreGoal: 30000, 
    handMin: 1, handMax: 9, boardMin: 1, boardMax: 10,
    jammerStart: 0.1, jammerStep: 0.1 
};

let CONFIG = Object.assign({}, PRESET_NORMAL);

let state = {
    screen: 'TITLE', 
    difficulty: 'NORMAL', 
    actions: 20, score: 0, lastScore: 0, 
    board: [], hand: [], particles: [], 
    width: 0, height: 0, dragInfo: null, 
    isGameOverProcessing: false, isGameClearProcessing: false, 
    inputLocked: false, comboCount: 0, 
    targetNumbers: [], 
    isMatching: false, boardSize: 5,
    round: 1, startTime: 0, guideMode: false, isRankEligible: true,
    clearedRounds: [],
    playerName: "ÂêçÁÑ°„Åó„Åï„Çì",
    isClearCounted: false // ËøΩÂä†: 1„Éó„É¨„Ç§„Åß1Âõû„ÇØ„É™„Ç¢„Çí„Ç´„Ç¶„É≥„Éà„Åô„Çã„Åü„ÇÅ„ÅÆ„Éï„É©„Ç∞
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const ui = {
    rightPanelContent: document.getElementById('right-panel-content'),
    difficultyLabel: document.getElementById('disp-difficulty-label'),
    rankInvalidBadge: document.getElementById('rank-invalid-badge'),
    actions: document.getElementById('disp-actions'),
    goalScore: document.getElementById('disp-goal-score'),
    totalScore: document.getElementById('disp-total-score'),
    lastScore: document.getElementById('disp-last-score'),
    targets: document.getElementById('disp-targets'),
    title: document.getElementById('title-screen'),
    result: document.getElementById('game-result'),
    continueScreen: document.getElementById('continue-screen'),
    rankingScreen: document.getElementById('ranking-screen'),
    rankingHeaderTitle: document.getElementById('ranking-header-title'),
    btnEasy: document.getElementById('btn-easy'),
    btnNormal: document.getElementById('btn-normal'),
    btnHard: document.getElementById('btn-hard'),
    btnViewRanking: document.getElementById('btn-view-ranking'),
    btnCloseRanking: document.getElementById('btn-close-ranking'),
    btnToTitle: document.getElementById('btn-to-title'),
    btnResultOk: document.getElementById('btn-result-ok'),
    btnContinueYes: document.getElementById('btn-continue-yes'),
    btnContinueNo: document.getElementById('btn-continue-no'),
    btnLogin: document.getElementById('btn-login'),
    btnLogout: document.getElementById('btn-logout'),
    btnIndex: document.getElementById('btn-index'),
    btnGuideToggle: document.getElementById('btn-guide-toggle'),
    crowns: {
        EASY: document.getElementById('crown-EASY'),
        NORMAL: document.getElementById('crown-NORMAL'),
        HARD: document.getElementById('crown-HARD')
    },
    clears: {
        EASY: document.getElementById('clear-EASY'),
        NORMAL: document.getElementById('clear-NORMAL'),
        HARD: document.getElementById('clear-HARD')
    },
    nicknameInput: document.getElementById('nickname-input')
};

window.resolveContinue = null;

// --- ÁîªÈù¢Ë™øÊï¥„É≠„Ç∏„ÉÉ„ÇØ (ÂÆåÂÖ®Âõ∫ÂÆöÊØîÁéá„ÉªÁµ∂ÂØæÈÖçÁΩÆ) ---
function adjustLayout() {
    const root = document.getElementById('game-root');
    const BASE_WIDTH = 1280;
    const BASE_HEIGHT = 720;
    
    // „Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫„Å®„Éô„Éº„Çπ„Çµ„Ç§„Ç∫„ÅÆÊØîÁéá
    const winW = window.innerWidth;
    const winH = window.innerHeight;
    
    // Á∏¶Ê®™„Å©„Å°„Çâ„Åã„Åå„ÅØ„ÅøÂá∫„Å™„ÅÑ„Çà„ÅÜ„Å´ÊúÄÂ∞è„ÅÆ„Çπ„Ç±„Éº„É´„ÇíÊé°Áî®
    const scale = Math.min(winW / BASE_WIDTH, winH / BASE_HEIGHT);
    
    // translate(-50%, -50%) „ÅßÁîªÈù¢‰∏≠Â§Æ„Å´ÈÖçÁΩÆ„Åó„ÄÅ„Åù„Åì„Åã„Çâ„Çπ„Ç±„Éº„É´„Åï„Åõ„Çã
    root.style.transform = `translate(-50%, -50%) scale(${scale})`;
    
    resize();
}

function resize() {
    state.width = canvas.parentElement.clientWidth;
    state.height = canvas.parentElement.clientHeight;
    canvas.width = state.width;
    canvas.height = state.height;
}

window.addEventListener('resize', () => { adjustLayout(); });
window.onload = () => {
    adjustLayout();
    resize();
    updateTitleScreenStats();
};

// Utility
function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath();
    if (fill) ctx.fill(); if (stroke) ctx.stroke();
}
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

// Stats & LocalStorage
function getRankingKey(diff) { return `modulo_blitz_ranking_v1_${diff}`; }
function getClearCountKey(diff) { return `modulo_blitz_clears_v1_${diff}`; }
function getLocalRanking(difficulty) { return JSON.parse(localStorage.getItem(getRankingKey(difficulty))) || []; }
function getClearCount(difficulty) { return parseInt(localStorage.getItem(getClearCountKey(difficulty))) || 0; }
function incrementClearCount(difficulty) {
    let count = getClearCount(difficulty); count++;
    localStorage.setItem(getClearCountKey(difficulty), count);
    return count;
}

function saveScore(difficulty, score) {
    if (!state.isRankEligible) return false;
    
    let ranking = getLocalRanking(difficulty);
    ranking.push({ score: score, name: state.playerName });
    ranking.sort((a, b) => b.score - a.score);
    ranking = ranking.slice(0, 10);
    localStorage.setItem(getRankingKey(difficulty), JSON.stringify(ranking));
    
    const isNewRecord = (ranking.length > 0 && ranking[0].score === score);
    
    if (window.currentUser && window.saveOnlineScore) {
        window.saveOnlineScore(window.currentUser.uid, state.playerName, difficulty, score);
    }
    return isNewRecord;
}

function updateTitleScreenStats() {
    ['EASY', 'NORMAL', 'HARD'].forEach(diff => {
        const count = getClearCount(diff);
        ui.clears[diff].textContent = `„ÇØ„É™„Ç¢: ${count}Âõû`;
        const crownEl = ui.crowns[diff];
        crownEl.style.visibility = 'visible';
        if (count >= 10) { crownEl.textContent = 'üëë'; crownEl.style.color = 'gold'; crownEl.style.filter = 'drop-shadow(0 0 5px gold)'; }
        else if (count >= 5) { crownEl.textContent = 'üëë'; crownEl.style.color = 'silver'; crownEl.style.filter = 'drop-shadow(0 0 5px silver)'; }
        else if (count >= 1) { crownEl.textContent = 'üëë'; crownEl.style.color = '#cd7f32'; crownEl.style.filter = 'drop-shadow(0 0 5px #cd7f32)'; }
        else { crownEl.style.visibility = 'hidden'; }
    });
}

// Logic Classes
class Cell {
    constructor(value) { this.value = value; this.isMatch = false; this.drawOffsetY = 0; this.type = 'NORMAL'; }
}

class HandCard {
    constructor(slotIndex) {
        this.slotIndex = slotIndex;
        this.value = randomInt(CONFIG.handMin, CONFIG.handMax);
        this.width = state.width * 0.12;
        this.height = this.width;
        this.x = 0; this.y = 0;
        this.baseX = 0; this.baseY = state.height * 0.83;
        this.isDragging = false;
        
        const gap = this.width * 0.5;
        const totalSetWidth = (this.width * 3) + (gap * 2);
        const startX = (state.width - totalSetWidth) / 2;
        this.baseX = startX + (this.width + gap) * slotIndex;
        this.x = this.baseX; this.y = this.baseY;
    }
    draw(ctx) {
        if (!this.isDragging) { this.x = this.baseX; this.y = this.baseY; }
        const colorSet = NUMBER_COLORS[this.value];
        ctx.fillStyle = colorSet ? colorSet.bg : '#fff';
        ctx.strokeStyle = '#00f0ff';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#00f0ff'; ctx.shadowBlur = 10;
        roundRect(ctx, this.x, this.y, this.width, this.height, 10, true, true);
        ctx.shadowBlur = 0;
        ctx.fillStyle = colorSet ? colorSet.text : '#333';
        ctx.font = `bold ${this.width * 0.5}px 'Orbitron', sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(this.value, this.x + this.width/2, this.y + this.height/2);
    }
}

class Particle {
    constructor(x, y, text, color, type = 'text', size = 0) {
        this.x = x; this.y = y; this.text = text; this.color = color; this.type = type;
        this.life = 1.0; this.size = size; this.vy = -1.5;
        
        if (type === 'combo') { this.vy = -0.5; this.life = 1.5; } 
        else if (type === 'sparkle') {
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            this.life = 0.8;
        }
    }
    update(dt) {
        if (this.type === 'sparkle') {
            this.x += this.vx; this.y += this.vy; this.life -= 0.05;
        } else if (this.type === 'text' || this.type === 'combo') { 
            this.y += this.vy; 
            const decay = (this.type === 'combo') ? 0.01 : 0.015;
            this.life -= decay; 
        }
        else { this.size += 5; this.life -= 0.03; }
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, Math.min(1, this.life));
        if (this.type === 'sparkle') {
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(this.x, this.y, 2, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'text' || this.type === 'combo') {
            const fontSize = this.type === 'combo' ? 60 : Math.max(12, 30 * this.life);
            ctx.fillStyle = this.color; 
            ctx.font = `bold ${fontSize}px 'Orbitron', sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; 
            if(this.type === 'combo') {
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 4;
                ctx.strokeText(this.text, this.x, this.y);
            }
            ctx.fillText(this.text, this.x, this.y);
        } else if (this.type === 'circle') {
            ctx.strokeStyle = this.color; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, 10 + this.size * 0.2, 0, Math.PI * 2); ctx.stroke();
        } else if (this.type === 'match-effect') {
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 5 + this.size * 0.5, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
    }
}

// Game Flow
function initGame() {
    state.actions = CONFIG.initialActions;
    state.score = 0; state.lastScore = 0; state.comboCount = 0;
    state.targetNumbers = []; 
    state.hand = []; state.board = []; state.particles = [];
    state.isGameOverProcessing = false; state.isGameClearProcessing = false;
    state.inputLocked = false; state.isMatching = false;
    state.round = 1; 
    state.startTime = performance.now();
    state.clearedRounds = [];
    state.isRankEligible = state.isRankEligible; // Á∂≠ÊåÅ
    // state.guideMode „ÅØ„Åì„Åì„Åß„ÅØ„É™„Çª„ÉÉ„Éà„Åó„Å™„ÅÑÔºà„Çø„Ç§„Éà„É´ÁîªÈù¢„ÅÆË®≠ÂÆö„ÇíÂºï„ÅçÁ∂ô„Åê„Åü„ÇÅÔºâ
    // „Åü„Å†„Åó„ÄÅ„É©„É≥„Ç≠„É≥„Ç∞ÊúâÂäπ„Éï„É©„Ç∞„ÅØ„Ç¨„Ç§„ÉâON„Å™„Çâfalse„Å´„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã
    if (state.guideMode) state.isRankEligible = false;
    else state.isRankEligible = true;

    state.isClearCounted = false; // „ÇØ„É™„Ç¢„Ç´„Ç¶„É≥„Éà„É™„Çª„ÉÉ„Éà

    let baseGoal = 0;
    if(state.difficulty === 'EASY') baseGoal = PRESET_EASY.scoreGoal;
    else if(state.difficulty === 'NORMAL') baseGoal = PRESET_NORMAL.scoreGoal;
    else if(state.difficulty === 'HARD') baseGoal = PRESET_HARD.scoreGoal;
    CONFIG.scoreGoal = baseGoal; 
    
    while (true) {
        for (let i = 0; i < state.boardSize; i++) {
            state.board[i] = [];
            for (let j = 0; j < state.boardSize; j++) {
                state.board[i][j] = new Cell(randomInt(CONFIG.boardMin, CONFIG.boardMax));
            }
        }
        if (!checkInitialMatches()) break;
    }

    spawnJammers();
    updateTargets();

    resize(); refillHand(); updateUI();
    state.screen = 'PLAYING';
    ui.title.classList.add('hidden'); ui.btnToTitle.classList.remove('hidden'); ui.rightPanelContent.classList.remove('invisible');
    requestAnimationFrame(gameLoop);
}

function spawnJammers() {
    const jammerCount = Math.floor(state.boardSize * state.boardSize * (CONFIG.jammerStart + (state.round-1)*CONFIG.jammerStep));
    let placed = 0; let attempts = 0;
    while(placed < jammerCount && attempts < 100) {
        let r = randomInt(0, state.boardSize-1);
        let c = randomInt(0, state.boardSize-1);
        if (state.board[r][c].type !== 'JAMMER') {
            state.board[r][c].type = 'JAMMER';
            state.board[r][c].value = 99; 
            placed++;
        }
        attempts++;
    }
}

function updateTargets() {
    state.targetNumbers = [];
    while(state.targetNumbers.length < 2) {
        let n = randomInt(1, 10);
        if(!state.targetNumbers.includes(n)) state.targetNumbers.push(n);
    }
    updateUI();
}

function checkInitialMatches() {
    const visited = Array(state.boardSize).fill(0).map(() => Array(state.boardSize).fill(false));
    function getCluster(r, c, val) {
        let stack = [{r, c}]; let cluster = []; visited[r][c] = true; cluster.push({r, c});
        while(stack.length > 0) {
            const curr = stack.pop();
            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                const nr = curr.r + dr, nc = curr.c + dc;
                if(nr >= 0 && nr < state.boardSize && nc >= 0 && nc < state.boardSize) {
                    if(!visited[nr][nc] && state.board[nr][nc].value === val && state.board[nr][nc].type === 'NORMAL') {
                        visited[nr][nc] = true; cluster.push({r: nr, c: nc}); stack.push({r: nr, c: nc});
                    }
                }
            });
        }
        return cluster;
    }
    for(let i=0; i<state.boardSize; i++) {
        for(let j=0; j<state.boardSize; j++) {
            if(!visited[i][j] && state.board[i][j].value > 0) {
                if (getCluster(i, j, state.board[i][j].value).length >= 3) return true;
            }
        }
    }
    return false;
}

function refillHand() {
    if (state.hand.length === 0) { state.hand = [null, null, null]; }
    for (let i = 0; i < 3; i++) {
        if (!state.hand[i]) { state.hand[i] = new HandCard(i); }
    }
    state.hand.forEach((card) => {
        if(card) {
            const gap = card.width * 0.5;
            const totalSetWidth = (card.width * 3) + (gap * 2);
            const startX = (state.width - totalSetWidth) / 2;
            card.baseX = startX + (card.width + gap) * card.slotIndex;
            if (!card.isDragging) { card.x = card.baseX; card.y = card.baseY; }
        }
    });
}

function updateUI() {
    if (state.screen === 'TITLE') return;

    ui.difficultyLabel.textContent = `${CONFIG.label} („É©„Ç¶„É≥„Éâ ${state.round})`;
    ui.actions.textContent = state.actions;
    ui.goalScore.textContent = CONFIG.scoreGoal;
    ui.totalScore.textContent = state.score;
    ui.lastScore.textContent = state.lastScore;
    
    ui.targets.innerHTML = state.targetNumbers.map((n, idx) => {
        const colorSet = NUMBER_COLORS[n] || NUMBER_COLORS[10];
        return `
            <div class="target-wrapper">
                <span class="target-item" style="background-color: ${colorSet.bg}; color: ${colorSet.text}; box-shadow: 0 0 10px ${colorSet.bg};">${n}</span>
            </div>
        `;
    }).join('');
    
    if(state.guideMode) ui.btnGuideToggle.classList.add('guide-on');
    else ui.btnGuideToggle.classList.remove('guide-on');

    if(!state.isRankEligible) ui.rankInvalidBadge.classList.remove('hidden');
    else ui.rankInvalidBadge.classList.add('hidden');
}

function addAction(amount) {
    state.actions += amount;
    state.particles.push(new Particle(ui.actions.getBoundingClientRect().left + ui.actions.offsetWidth / 2, ui.actions.getBoundingClientRect().top + ui.actions.offsetHeight / 2, `+${amount}`, '#f1c40f', 'text'));
}

function applyModulo(original, cardValue) {
    const r = (original + cardValue) % 10; return r === 0 ? 10 : r;
}

function getBoardLayout() {
    const headerHeight = 70; const handHeight = 150;
    const maxH = state.height - headerHeight - handHeight - 20;
    const maxW = state.width * 0.95; // „Éû„Éº„Ç∏„É≥„ÇíÊ∏õ„Çâ„Åó„Å¶Â§ß„Åç„ÅèË°®Á§∫
    const boardSizePx = Math.min(maxW, maxH);
    const cellSize = boardSizePx / state.boardSize;
    const startX = state.width / 2 - boardSizePx / 2;
    const startY = headerHeight + 20;
    return { boardSizePx, cellSize, startX, startY };
}

function getCellPosition(row, col) {
    const { cellSize, startX, startY } = getBoardLayout();
    return { x: startX + col * cellSize, y: startY + row * cellSize, size: cellSize };
}

function getTargetScale(now) { return 1.0 + Math.sin(now / 800) * 0.05; }

function drawBoard(ctx) {
    const { boardSizePx, cellSize, startX, startY } = getBoardLayout();
    const padding = 2; const drawSize = cellSize - padding * 2;
    
    // ‰∏≠Â§ÆBOXÔºàÊû†Á∑öÔºâ„ÇíÂâäÈô§
    // ctx.strokeStyle = '#2a3b55'; ctx.lineWidth = 5; ctx.strokeRect(startX, startY, boardSizePx, boardSizePx);

    const now = performance.now();
    const glowAlpha = (Math.sin(now / 300) + 1) / 2 * 0.5 + 0.2; 
    const targetScale = getTargetScale(now);

    for (let i = 0; i < state.boardSize; i++) {
        for (let j = 0; j < state.boardSize; j++) {
            const cell = state.board[i][j];
            const { x, y } = getCellPosition(i, j);
            const drawY = y + cell.drawOffsetY;

            if (cell.type === 'JAMMER') {
                ctx.fillStyle = '#000'; 
                ctx.fillRect(x + padding, drawY + padding, drawSize, drawSize);
                ctx.strokeStyle = '#333'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(x + padding + 5, drawY + padding + 5); ctx.lineTo(x + padding + drawSize - 5, drawY + padding + drawSize - 5); ctx.moveTo(x + padding + drawSize - 5, drawY + padding + 5); ctx.lineTo(x + padding + 5, drawY + padding + drawSize - 5); ctx.stroke();
            }
            else if (cell.value > 0) {
                const colorSet = NUMBER_COLORS[cell.value] || NUMBER_COLORS[10];
                const isTarget = state.targetNumbers.includes(cell.value);
                
                let cx = x + cellSize/2; let cy = drawY + cellSize/2; let size = drawSize;

                if (isTarget) {
                    size *= targetScale;
                    if (Math.random() < 0.05) state.particles.push(new Particle(x + Math.random()*cellSize, drawY + Math.random()*cellSize, "", "#FFD700", "sparkle"));
                }

                ctx.fillStyle = colorSet.bg;
                ctx.fillRect(cx - size/2, cy - size/2, size, size);
                
                if (isTarget) {
                    ctx.save(); ctx.globalAlpha = glowAlpha; ctx.fillStyle = '#f1c40f'; ctx.fillRect(cx - size/2, cy - size/2, size, size); ctx.restore();
                    ctx.strokeStyle = `rgba(241, 196, 15, ${glowAlpha + 0.3})`; ctx.lineWidth = 3; ctx.strokeRect(cx - size/2, cy - size/2, size, size);
                }
                
                ctx.fillStyle = colorSet.text;
                ctx.font = `bold ${cellSize * 0.5 * (isTarget ? targetScale : 1)}px 'Orbitron', sans-serif`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(cell.value, cx, cy + 5);
            } else {
                ctx.fillStyle = '#15192b'; ctx.fillRect(x + padding, drawY + padding, drawSize, drawSize);
            }
        }
    }
}

function checkPotentialMatch(r, c, val) {
    const visited = Array(state.boardSize).fill(0).map(() => Array(state.boardSize).fill(false));
    function getCluster(r, c, val) {
        let stack = [{r, c}]; let cluster = []; visited[r][c] = true; cluster.push({r, c});
        while(stack.length > 0) {
            const curr = stack.pop();
            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                const nr = curr.r + dr, nc = curr.c + dc;
                if(nr >= 0 && nr < state.boardSize && nc >= 0 && nc < state.boardSize) {
                    if(!visited[nr][nc] && state.board[nr][nc].value === val && state.board[nr][nc].type === 'NORMAL') {
                        visited[nr][nc] = true; cluster.push({r: nr, c: nc}); stack.push({r: nr, c: nc});
                    }
                }
            });
        }
        return cluster;
    }
    return getCluster(r, c, val).length >= 3;
}

function drawHUD(ctx) {
    ctx.textAlign = 'center';
    const boxW = 600; const boxH = 50; const boxX = state.width/2 - boxW/2; const boxY = 15;
    // „Çø„Ç§„Éà„É´„Éú„ÉÉ„ÇØ„Çπ„ÅÆËÉåÊôØ„ÇíÂ∞ë„ÅóÈÄèÈÅé
    ctx.fillStyle = 'rgba(26, 32, 53, 0.8)'; ctx.strokeStyle = '#00f0ff'; ctx.lineWidth = 2;
    ctx.shadowColor = '#00f0ff'; ctx.shadowBlur = 10;
    roundRect(ctx, boxX, boxY, boxW, boxH, 5, true, true);
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#00f0ff'; ctx.font = 'bold 20px "Orbitron", "Zen Kaku Gothic New", sans-serif'; ctx.textBaseline = 'middle';
    ctx.fillText("5x5 MODULO BLITZ („É¢„Ç∏„É•„É≠„Éñ„É™„ÉÉ„ÉÑ)", state.width/2, boxY + boxH/2);
}

function drawGame(ctx) {
    ctx.clearRect(0, 0, state.width, state.height);
    drawBoard(ctx);
    
    const { cellSize } = getBoardLayout();
    
    for(let i=0; i<state.boardSize; i++) {
        for(let j=0; j<state.boardSize; j++) {
            if(state.board[i][j].isMatch) {
                const {x, y} = getCellPosition(i, j);
                ctx.globalAlpha = 0.5; ctx.fillStyle = '#9b59b6'; ctx.fillRect(x, y + state.board[i][j].drawOffsetY, cellSize, cellSize); ctx.globalAlpha = 1.0;
            }
        }
    }
    
    const draggingCard = state.hand.find(c => c && c.isDragging);

    if (state.guideMode && draggingCard) {
        const layout = getBoardLayout();
        for(let i=0; i<state.boardSize; i++) {
            for(let j=0; j<state.boardSize; j++) {
                if(state.board[i][j].type === 'NORMAL') {
                    const originalVal = state.board[i][j].value;
                    const newVal = applyModulo(originalVal, draggingCard.value);
                    state.board[i][j].value = newVal;
                    
                    if(checkPotentialMatch(i, j, newVal)) {
                        const {x, y} = getCellPosition(i, j);
                        ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#00f0ff'; 
                        ctx.fillRect(x, y, layout.cellSize, layout.cellSize);
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; ctx.strokeRect(x, y, layout.cellSize, layout.cellSize);
                        ctx.restore();
                    }
                    state.board[i][j].value = originalVal;
                }
            }
        }
    }

    drawHUD(ctx);
    state.hand.forEach(c => { if(c && !c.isDragging) c.draw(ctx); });
    if (draggingCard) draggingCard.draw(ctx);
    state.particles.forEach(p => p.draw(ctx));
}

function checkMatchesAndScore() {
    const visited = Array(state.boardSize).fill(0).map(() => Array(state.boardSize).fill(false));
    let matchesFound = false;
    let totalScore = 0;
    let eliminatedNumbersCount = {}; 
    let destroyedJammers = [];

    function getCluster(r, c, val) {
        let stack = [{r, c}]; let cluster = []; visited[r][c] = true; cluster.push({r, c});
        while(stack.length > 0) {
            const curr = stack.pop();
            [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                const nr = curr.r + dr, nc = curr.c + dc;
                if(nr >= 0 && nr < state.boardSize && nc >= 0 && nc < state.boardSize) {
                    if(!visited[nr][nc] && state.board[nr][nc].value === val && state.board[nr][nc].type === 'NORMAL') {
                        visited[nr][nc] = true; cluster.push({r: nr, c: nc}); stack.push({r: nr, c: nc});
                    }
                }
            });
        }
        return cluster;
    }

    for(let i=0; i<state.boardSize; i++) {
        for(let j=0; j<state.boardSize; j++) {
            if(!visited[i][j] && state.board[i][j].value > 0 && state.board[i][j].type === 'NORMAL') {
                const val = state.board[i][j].value;
                const cluster = getCluster(i, j, val);
                if(cluster.length >= 3) {
                    matchesFound = true;
                    cluster.forEach(pos => {
                        state.board[pos.r][pos.c].isMatch = true;
                        const {x, y, size} = getCellPosition(pos.r, pos.c);
                        state.particles.push(new Particle(x + size/2, y + size/2, "", '#9b59b6', 'match-effect'));
                        
                        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                            const nr = pos.r + dr, nc = pos.c + dc;
                            if(nr >= 0 && nr < state.boardSize && nc >= 0 && nc < state.boardSize) {
                                if(state.board[nr][nc].type === 'JAMMER' && !state.board[nr][nc].isMatch) {
                                    state.board[nr][nc].isMatch = true; 
                                    destroyedJammers.push({r: nr, c: nc});
                                    const jp = getCellPosition(nr, nc);
                                    state.particles.push(new Particle(jp.x + jp.size/2, jp.y + jp.size/2, "„Åì„Çè„Çå„ÅüÔºÅ", '#7f8c8d', 'text'));
                                }
                            }
                        });
                    });
                    
                    const N = cluster.length;
                    let fixedBonus = N === 3 ? 100 : (N === 4 ? 200 : (N - 2) * 100);
                    let comboBonus = (state.comboCount) * 100;
                    let multiplier = 1;
                    let targetHitCount = 0;
                    
                    state.targetNumbers.forEach(tVal => {
                         if (tVal === val) { multiplier *= 2; targetHitCount++; }
                    });
                    if (targetHitCount > 0) eliminatedNumbersCount[val] = (eliminatedNumbersCount[val] || 0) + 1;

                    totalScore += (fixedBonus + comboBonus) * multiplier;
                    
                    if (targetHitCount > 0) state.particles.push(new Particle(state.width/2, state.height * 0.25, `„Çø„Éº„Ç≤„ÉÉ„Éà„Éú„Éº„Éä„Çπ x${multiplier}!`, '#2ecc71', 'combo'));
                }
            }
        }
    }

    if (!matchesFound) { state.comboCount = 0; return 0; }
    state.comboCount++;
    
    Object.keys(eliminatedNumbersCount).forEach(key => {
        const val = parseInt(key);
        let i = state.targetNumbers.length;
        while (i--) {
            if (state.targetNumbers[i] === val) state.targetNumbers.splice(i, 1);
        }
    });

    state.lastScore = totalScore; state.score += totalScore;
    addAction(1); 

    state.particles.push(new Particle(state.width/2, state.height * 0.45, `+${totalScore}„Å¶„Çì`, '#e67e22', 'combo'));
    if (state.comboCount > 1) state.particles.push(new Particle(state.width/2, state.height * 0.35, `${state.comboCount} „Çå„Çì„ÅïÔºÅ`, '#e74c3c', 'combo'));

    if (Math.random() < state.comboCount * 0.2) generateTargetNumber();

    return totalScore;
}

function generateTargetNumber() {
    if (state.targetNumbers.length >= 5) state.targetNumbers.shift();
    const newNum = randomInt(1, 9);
    state.targetNumbers.push(newNum); 
    state.particles.push(new Particle(state.width/2, 80, "„Çø„Éº„Ç≤„ÉÉ„Éà„Å§„ÅÑ„ÅãÔºÅ", '#2ecc71', 'text'));
}

function getJammerRate() {
    let startRate = 0; let stepRate = 0;
    if (state.difficulty === 'EASY') { startRate = PRESET_EASY.jammerStart; stepRate = PRESET_EASY.jammerStep; }
    else if (state.difficulty === 'NORMAL') { startRate = PRESET_NORMAL.jammerStart; stepRate = PRESET_NORMAL.jammerStep; }
    else if (state.difficulty === 'HARD') { startRate = PRESET_HARD.jammerStart; stepRate = PRESET_HARD.jammerStep; }
    
    const rate = startRate + (state.round - 1) * stepRate;
    return Math.min(rate, 0.8); 
}

function updateBoardLogic() {
    let moved = false;
    const { cellSize } = getBoardLayout();
    const jammerRate = getJammerRate();

    for (let j = 0; j < state.boardSize; j++) {
        let validCells = [];
        for(let i = 0; i < state.boardSize; i++) {
            if(state.board[i][j].value !== 0 || state.board[i][j].type === 'JAMMER') {
                validCells.push({ val: state.board[i][j].value, type: state.board[i][j].type, oldRow: i });
            }
        }
        for(let i=0; i < state.boardSize; i++) { 
            state.board[i][j].value = 0; state.board[i][j].type = 'NORMAL';
        }

        let currentWriteRow = state.boardSize - 1;
        for(let k = validCells.length - 1; k >= 0; k--) {
            const cellInfo = validCells[k];
            state.board[currentWriteRow][j].value = cellInfo.val;
            state.board[currentWriteRow][j].type = cellInfo.type;
            
            if (currentWriteRow !== cellInfo.oldRow) {
                const distRows = currentWriteRow - cellInfo.oldRow;
                state.board[currentWriteRow][j].drawOffsetY = -1 * distRows * cellSize;
                moved = true;
            }
            currentWriteRow--;
        }

        let newCount = 0;
        for (let row = currentWriteRow; row >= 0; row--) {
            newCount++;
            if (Math.random() < jammerRate) {
                state.board[row][j].type = 'JAMMER'; state.board[row][j].value = -1; 
            } else {
                state.board[row][j].type = 'NORMAL'; state.board[row][j].value = randomInt(CONFIG.boardMin, CONFIG.boardMax);
            }
            const distRows = newCount + (currentWriteRow + 1); 
            state.board[row][j].drawOffsetY = -1 * (distRows * cellSize * 1.5); 
            moved = true;
        }
    }
    return moved;
}

function waitForDropAnimation() {
    return new Promise(resolve => {
        const check = () => {
            let animating = false;
            for(let i=0; i<state.boardSize; i++) {
                for(let j=0; j<state.boardSize; j++) {
                    if (state.board[i][j].drawOffsetY < 0) { animating = true; break; }
                }
            }
            if (!animating) resolve();
            else requestAnimationFrame(check);
        };
        check();
    });
}

async function handleMatching() {
    state.isMatching = true; state.inputLocked = true;
    let scoreGained = 0;

    while (true) {
        // ÁõÆÊ®ôÈÅîÊàêÊôÇ„ÅÆÂá¶ÁêÜÔºà„Åì„Åì„Åß„ÇØ„É™„Ç¢„Ç´„Ç¶„É≥„Éà„ÇíÂä†ÁÆóÔºâ
        if (state.score + scoreGained >= CONFIG.scoreGoal && !state.clearedRounds.includes(state.round)) {
            state.score += scoreGained;
            scoreGained = 0; 
            updateUI();
            
            state.clearedRounds.push(state.round);
            
            // ‰øÆÊ≠£: 1„Éó„É¨„Ç§„ÅßÂàù„ÇÅ„Å¶„ÅÆÁõÆÊ®ôÈÅîÊàêÊôÇ„Å´„ÇØ„É™„Ç¢ÂõûÊï∞„Çí„Ç´„Ç¶„É≥„Éà
            if (!state.isClearCounted) {
                incrementClearCount(state.difficulty);
                state.isClearCounted = true; // „Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã
            }
            
            showContinueScreen();
            await new Promise(r => window.resolveContinue = r);
            
            ui.continueScreen.classList.add('hidden');
            state.isGameClearProcessing = false;
            state.inputLocked = true; 
        }

        let currentScore = checkMatchesAndScore();
        if (currentScore === 0) break;
        scoreGained += currentScore;

        await wait(250); 

        for(let i=0; i<state.boardSize; i++) {
            for(let j=0; j<state.boardSize; j++) {
                if(state.board[i][j].isMatch) {
                    state.board[i][j].value = 0; state.board[i][j].type = 'NORMAL'; state.board[i][j].isMatch = false;
                }
            }
        }
        await wait(400); 
        updateBoardLogic();
        await waitForDropAnimation();
        await wait(100);
    }

    state.score += scoreGained;
    updateUI();
    state.isMatching = false;
    
    if (state.actions <= 0) gameOver(false);
    else state.inputLocked = false;
    
    return 0; 
}

async function applyCard(r, c, card) {
    state.inputLocked = true;
    
    let originalVal = state.board[r][c].value;
    let sum = originalVal + card.value;
    let newVal = sum > 10 ? sum % 10 : sum; 
    if (newVal === 0) newVal = 10;
    
    state.board[r][c].value = newVal;
    state.particles.push(new Particle(
        20 + 20 + c * (state.width-40)/5 + (state.width-40)/10, 
        20 + 20 + r * (state.width-40)/5 + (state.width-40)/10,
        `${originalVal} + ${card.value} = ${newVal}`, '#fff', 'text'
    ));

    card.value = randomInt(CONFIG.handMin, CONFIG.handMax);
    state.actions--;
    
    await handleMatching();
    updateUI();
    
    // „Ç¢„ÇØ„Ç∑„Éß„É≥„Åå0„Å´„Å™„Çä„ÄÅ„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂá¶ÁêÜ‰∏≠„Åß„Å™„Åè„ÄÅ„Éû„ÉÉ„ÉÅ„É≥„Ç∞„ÇÇ„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà
    if (state.actions <= 0 && !state.isMatching && !state.isGameOverProcessing) {
        gameOver(false);
    } else if (!state.isMatching) {
        state.inputLocked = false;
    }
}

function gameOver(clearFlag) {
    if (state.isGameOverProcessing) return;
    state.isGameOverProcessing = true; state.inputLocked = true;
    const isNewRecord = saveScore(state.difficulty, state.score);
    // „Ç≤„Éº„É†ÁµÇ‰∫ÜÊôÇ„Å´„ÅØ„Ç´„Ç¶„É≥„Éà„Åó„Å™„ÅÑÔºàhandleMatching„Åß„Ç´„Ç¶„É≥„ÉàÊ∏à„ÅøÔºâ
    
    if (clearFlag && state.round >= 5) {
        ui.result.innerHTML = `
            <div class="overlay-content" style="background: #1a2035; border: 4px solid #f1c40f;">
                <h2 style="font-size: 3rem; color: #f1c40f; margin: 0 0 20px 0;">üéâ „Åã„Çì„Åú„Çì „ÇØ„É™„Ç¢ÔºÅ üéâ</h2>
                <div style="font-size: 1.2rem; line-height: 1.8; margin-bottom: 20px; color:#fff;">
                    „É©„Ç¶„É≥„Éâ5 „ÇØ„É™„Ç¢ÔºÅ<br>„Åç„Åø„ÅØ <strong>„É¢„Ç∏„É•„É≠ „Éû„Çπ„Çø„Éº</strong> „Å†ÔºÅ
                </div>
                „Åï„ÅÑ„Åó„ÇÖ„ÅÜ „Çπ„Ç≥„Ç¢<br><span style="font-size: 2.5rem; color: #f1c40f; font-weight: bold;">${state.score}</span>
                ${isNewRecord ? '<div style="margin-top: 10px; color: #00f0ff; font-weight: bold;">„Éã„É•„Éº„É¨„Ç≥„Éº„ÉâÔºÅ</div>' : ''}
                ${!state.isRankEligible ? '<div style="margin-top: 10px; color: #a0aab5;">(„Ç¨„Ç§„Éâ„Çí‰Ωø„Å£„Åü„ÅÆ„Åß „É©„É≥„Ç≠„É≥„Ç∞„Å™„Åó)</div>' : ''}
                <button id="btn-result-ok-inner" class="btn btn-success" style="font-size: 1.2rem; padding: 10px 40px; margin-top: 20px;">„Çø„Ç§„Éà„É´„Å∏</button>
            </div>
        `;
    } else {
        ui.result.innerHTML = `
            <div class="overlay-content" style="background: #1a2035; border: 4px solid ${clearFlag ? '#f1c40f' : '#e74c3c'};">
                <h2 style="font-size: 2.5rem; color: ${clearFlag ? '#f1c40f' : '#e74c3c'}; margin: 0 0 20px 0;">${clearFlag ? "„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ" : "„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº"}</h2>
                <div style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 20px; color:#fff;">
                    ${clearFlag ? `„ÇÇ„Åè„Å≤„Çá„ÅÜ „Åü„Å£„Åõ„ÅÑÔºÅ` : `ÂõûÊï∞„Åå „Å™„Åè„Å™„Å£„Åü„Çà„ÄÇ`}
                </div>
                „Åï„ÅÑ„Åó„ÇÖ„ÅÜ „Çπ„Ç≥„Ç¢<br><span style="font-size: 2rem; color: #f1c40f; font-weight: bold;">${state.score}</span>
                ${isNewRecord ? '<div style="margin-top: 10px; color: #00f0ff; font-weight: bold;">„Éã„É•„Éº„É¨„Ç≥„Éº„ÉâÔºÅ</div>' : ''}
                ${!state.isRankEligible ? '<div style="margin-top: 10px; color: #a0aab5;">(„Ç¨„Ç§„Éâ„Çí‰Ωø„Å£„Åü„ÅÆ„Åß „É©„É≥„Ç≠„É≥„Ç∞„Å™„Åó)</div>' : ''}
                <button id="btn-result-ok-inner" class="btn btn-success" style="font-size: 1.2rem; padding: 10px 40px; margin-top: 20px;">„Çø„Ç§„Éà„É´„Å∏</button>
            </div>
        `;
    }
    
    ui.result.classList.remove('hidden');
    document.getElementById('btn-result-ok-inner').onclick = backToTitle;
}

function showContinueScreen() {
    if (state.round >= 5) { gameOver(true); return; }

    ui.continueScreen.classList.remove('hidden');
    
    document.getElementById('btn-continue-yes').onclick = () => {
        state.round++;
        let baseGoal = 0;
        if(state.difficulty === 'EASY') baseGoal = PRESET_EASY.scoreGoal;
        else if(state.difficulty === 'NORMAL') baseGoal = PRESET_NORMAL.scoreGoal;
        else if(state.difficulty === 'HARD') baseGoal = PRESET_HARD.scoreGoal;
        
        CONFIG.scoreGoal = baseGoal * state.round;
        addAction(10); updateUI();
        if(window.resolveContinue) window.resolveContinue(true);
    };
    
    document.getElementById('btn-continue-no').onclick = () => {
        ui.continueScreen.classList.add('hidden');
        if(window.resolveContinue) window.resolveContinue(false); 
        gameOver(true);
    };
}

window.showRankingScreen = async function() {
    ui.rankingScreen.classList.remove('hidden');
    ['rank-list-EASY', 'rank-list-NORMAL', 'rank-list-HARD'].forEach(id => {
        document.getElementById(id).innerHTML = '<li style="justify-content:center; color:#7f8c8d;">„Çà„Åø„Åì„Åø‰∏≠...</li>';
    });

    if (window.currentUser && window.fetchOnlineRankingGlobal) {
        ui.rankingHeaderTitle.textContent = "„É©„É≥„Ç≠„É≥„Ç∞ („Éà„ÉÉ„Éó10)";
        const renderOnlineList = async (diff, elementId) => {
            const listEl = document.getElementById(elementId);
            const ranking = await window.fetchOnlineRankingGlobal(diff);
            if (ranking.length === 0) { listEl.innerHTML = '<li style="justify-content:center; color:#7f8c8d;">„Éá„Éº„Çø„Å™„Åó</li>'; return; }
            let html = '';
            ranking.forEach((item, index) => {
                const rankText = index === 0 ? 'üëë' : index + 1;
                const scoreColor = index === 0 ? '#f1c40f' : 'white';
                html += `<li><span class="ranking-rank">${rankText}</span><span class="ranking-name">${item.name || 'ÂêçÁÑ°„Åó'}</span><span class="ranking-score" style="color:${scoreColor};">${item.score}</span></li>`;
            });
            listEl.innerHTML = html;
        };
        await Promise.all([renderOnlineList('EASY', 'rank-list-EASY'), renderOnlineList('NORMAL', 'rank-list-NORMAL'), renderOnlineList('HARD', 'rank-list-HARD')]);
    } else {
        ui.rankingHeaderTitle.textContent = "„É©„É≥„Ç≠„É≥„Ç∞ („É≠„Éº„Ç´„É´)";
        const renderLocalList = (diff, elementId) => {
            const listEl = document.getElementById(elementId);
            let ranking = getLocalRanking(diff);
            ranking = ranking.map(item => { if(typeof item === 'number') return { score: item, name: 'ÂêçÁÑ°„Åó„Åï„Çì' }; return item; });

            if (ranking.length === 0) { listEl.innerHTML = '<li style="justify-content:center; color:#7f8c8d;">„Éá„Éº„Çø„Å™„Åó</li>'; return; }
            let html = '';
            ranking.forEach((entry, index) => {
                const rankText = index === 0 ? 'üëë' : index + 1;
                const scoreColor = index === 0 ? '#f1c40f' : 'white';
                html += `<li><span class="ranking-rank">${rankText}</span><span class="ranking-name">${entry.name}</span><span class="ranking-score" style="color:${scoreColor};">${entry.score}</span></li>`;
            });
            listEl.innerHTML = html;
        };
        renderLocalList('EASY', 'rank-list-EASY'); renderLocalList('NORMAL', 'rank-list-NORMAL'); renderLocalList('HARD', 'rank-list-HARD');
    }
}

function backToTitle() {
    state.screen = 'TITLE';
    // Clear the canvas so game doesn't bleed through transparent title
    ctx.clearRect(0, 0, state.width, state.height);
    
    ui.result.classList.add('hidden'); ui.continueScreen.classList.add('hidden'); ui.title.classList.remove('hidden');
    ui.btnToTitle.classList.add('hidden'); ui.rightPanelContent.classList.add('invisible');
    ui.rankingScreen.classList.add('hidden'); 
    updateTitleScreenStats();
}

let lastUpdate = performance.now();
function gameLoop(timestamp) {
    const dt = (timestamp - lastUpdate) / 1000; lastUpdate = timestamp;
    if (state.screen !== 'PLAYING') return;
    
    for (let i = state.particles.length - 1; i >= 0; i--) {
        state.particles[i].update(dt);
        if (state.particles[i].life <= 0) state.particles.splice(i, 1);
    }
    
    const { cellSize } = getBoardLayout();
    const dropSpeed = cellSize * 15 * dt; 
    
    for(let i=0; i<state.boardSize; i++) {
        for(let j=0; j<state.boardSize; j++) {
            if (state.board[i][j].drawOffsetY < 0) {
                state.board[i][j].drawOffsetY += dropSpeed;
                if (state.board[i][j].drawOffsetY > 0) state.board[i][j].drawOffsetY = 0;
            }
        }
    }

    if (!state.isMatching && state.hand.filter(c => c !== null).length < 3 && !state.inputLocked) refillHand();
    
    updateUI(); drawGame(ctx);
    requestAnimationFrame(gameLoop);
}

function getCardAtPoint(x, y) {
    for (let i = 0; i < 3; i++) {
        const c = state.hand[i];
        if (c && x >= c.x && x <= c.x + c.width && y >= c.y && y <= c.y + c.height) return { card: c, index: i };
    }
    return null;
}

function startDrag(x, y) {
    if (state.screen !== 'PLAYING' || state.inputLocked) return;
    const hit = getCardAtPoint(x, y);
    if (hit) {
        state.dragInfo = { card: hit.card, idx: hit.index, ox: x - hit.card.x, oy: y - hit.card.y };
        hit.card.isDragging = true;
    }
}
function moveDrag(x, y) {
    if (!state.dragInfo) return;
    state.dragInfo.card.x = x - state.dragInfo.ox;
    state.dragInfo.card.y = y - state.dragInfo.oy;
}
function endDrag(x, y) {
    if (!state.dragInfo) return;
    const { card, idx } = state.dragInfo;
    card.isDragging = false;
    const cx = card.x + card.width/2; const cy = card.y + card.height/2;
    const { cellSize, startX, startY } = getBoardLayout();
    
    let dropped = false;
    if (cx >= startX && cx < startX + cellSize * state.boardSize && cy >= startY && cy < startY + cellSize * state.boardSize) {
        const col = Math.floor((cx - startX) / cellSize);
        const row = Math.floor((cy - startY) / cellSize);
        
        if (row >= 0 && row < state.boardSize && col >= 0 && col < state.boardSize) {
            if (state.board[row][col].type !== 'JAMMER') {
                applyCard(row, col, card);
                dropped = true;
            }
        }
    }
    if (!dropped) { card.x = card.baseX; card.y = card.baseY; }
    state.dragInfo = null;
}

// Interaction
function getTouchPos(e) {
    const r = canvas.getBoundingClientRect();
    const scaleX = canvas.width / r.width;
    const scaleY = canvas.height / r.height;
    return {
        x: ((e.changedTouches ? e.changedTouches[0].clientX : e.clientX) - r.left) * scaleX,
        y: ((e.changedTouches ? e.changedTouches[0].clientY : e.clientY) - r.top) * scaleY
    };
}

canvas.addEventListener('mousedown', e => { const {x, y} = getTouchPos(e); startDrag(x, y); });
canvas.addEventListener('mousemove', e => { const {x, y} = getTouchPos(e); moveDrag(x, y); });
canvas.addEventListener('mouseup', e => { const {x, y} = getTouchPos(e); endDrag(x, y); });
canvas.addEventListener('touchstart', e => { e.preventDefault(); const {x, y} = getTouchPos(e); startDrag(x, y); }, {passive:false});
canvas.addEventListener('touchmove', e => { e.preventDefault(); const {x, y} = getTouchPos(e); moveDrag(x, y); }, {passive:false});
canvas.addEventListener('touchend', e => { e.preventDefault(); const {x, y} = getTouchPos(e); endDrag(x, y); }, {passive:false});

// „Ç≤„Éº„É†ÈñãÂßãÂâç„ÅÆÊ§úË®º
function validateAndStart(difficulty, preset) {
    const nameInput = ui.nicknameInput.value.trim();
    if (!nameInput) { state.playerName = "ÂêçÁÑ°„Åó„Åï„Çì"; } 
    else {
        if (!/^[„ÅÅ-„Çì„Éº]+$/.test(nameInput)) { alert("„Åä„Å™„Åæ„Åà„ÅØ „Å≤„Çâ„Åå„Å™ „Å® „Äå„Éº„Äç „Å†„Åë„Åß „Åã„ÅÑ„Å¶„Å≠ÔºÅ"); return; }
        for (const ng of NG_WORDS_HIRAGANA) {
            if (nameInput.includes(ng)) { alert("„Åù„ÅÆ„Åä„Å™„Åæ„Åà„ÅØ „Å§„Åã„Åà„Åæ„Åõ„Çì„ÄÇ„Åπ„Å§„ÅÆ „Åä„Å™„Åæ„Åà„Å´ „Åó„Å¶„Å≠„ÄÇ"); return; }
        }
        state.playerName = nameInput;
    }
    state.difficulty = difficulty;
    CONFIG = Object.assign({}, preset);
    initGame();
}

function bindBtn(btn, cb) { if(btn) { btn.onclick = cb; } }

bindBtn(ui.btnEasy, () => validateAndStart('EASY', PRESET_EASY));
bindBtn(ui.btnNormal, () => validateAndStart('NORMAL', PRESET_NORMAL));
bindBtn(ui.btnHard, () => validateAndStart('HARD', PRESET_HARD));

bindBtn(ui.btnViewRanking, window.showRankingScreen);
bindBtn(ui.btnCloseRanking, () => ui.rankingScreen.classList.add('hidden'));
bindBtn(ui.btnToTitle, backToTitle);
bindBtn(ui.btnResultOk, backToTitle);
bindBtn(ui.btnContinueYes, () => { if(window.resolveContinue) window.resolveContinue(true); });
bindBtn(ui.btnContinueNo, () => { if(window.resolveContinue) window.resolveContinue(false); });
bindBtn(ui.btnLogin, window.handleLogin);
bindBtn(ui.btnLogout, window.handleLogout);
bindBtn(ui.btnIndex, () => window.location.href="index.html");

bindBtn(ui.btnGuideToggle, () => {
    if (!state.guideMode) {
        if (confirm("„Ç¨„Ç§„Éâ„ÇíON„Å´„Åô„Çã„Å® „Åì„Çì„Åã„ÅÑ„ÅØ „É©„É≥„Ç≠„É≥„Ç∞„Å´ „ÅÆ„Çâ„Å™„Åè„Å™„Çä„Åæ„Åô„Åå„ÄÅ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü")) {
            state.guideMode = true;
            state.isRankEligible = false;
            ui.btnGuideToggle.classList.add('guide-on');
            updateUI();
        }
    } else {
        // „Ç¨„Ç§„ÉâOFF„Å´„Åó„Å¶„ÇÇ‰ªäÂõû„ÅÆ„Éó„É¨„Ç§„Åß„ÅØ„É©„É≥„Ç≠„É≥„Ç∞ÁÑ°Âäπ„ÅÆ„Åæ„Åæ
        state.guideMode = false;
        ui.btnGuideToggle.classList.remove('guide-on');
    }
});

backToTitle();

</script>
</body>
</html>
