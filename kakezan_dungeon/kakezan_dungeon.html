<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ã‹ã‘ã–ã‚“ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³ï¼šåœ°åº•ã‹ã‚‰ã®è„±å‡º</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #2b1d0e;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            overflow: hidden;
        }

        #game-container {
            width: 1280px;
            height: 720px;
            background-color: #4e342e;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            background-image: url('images/title.png'); 
            background-size: cover;
            background-position: center;
        }

        canvas {
            display: block;
            background-color: #3e2723;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        canvas.hidden {
            display: none;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
        }
        
        #title-screen {
            background: rgba(43, 29, 14, 0.4);
            justify-content: flex-start;
            padding-top: 60px;
            box-sizing: border-box;
        }
        
        #title-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 10px;
            align-items: center;
        }

        #difficulty-screen {
            background-image: url('images/title.png');
            background-size: cover;
            background-position: center;
            background-color: rgba(43, 29, 14, 0.6);
            background-blend-mode: multiply;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 80px;
            color: #ffca28;
            margin-bottom: 0px;
            text-shadow: 4px 4px 0 #000, -2px -2px 0 #000;
            text-align: center;
            width: 100%;
            font-weight: 800;
            margin-top: 0;
            line-height: 1.1;
        }

        .subtitle {
            font-size: 40px; 
            color: #d7ccc8;
            display: block;
            margin-top: -10px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
        }

        h2 {
            font-size: 40px;
            color: #efebe9;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
        }

        #current-player-display {
            font-size: 24px;
            color: #ffffff;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            background-color: rgba(0,0,0,0.6);
            padding: 5px 20px;
            border-radius: 10px;
            border: 2px solid #ffca28;
            margin-bottom: 5px;
            min-width: 320px; 
            max-width: 320px;
            text-align: center;
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn {
            background-color: #5d4037;
            color: #efebe9;
            border: 2px solid #8d6e63;
            padding: 10px 0;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-weight: 800;
            box-shadow: 0 6px 0 #3e2723;
            transition: transform 0.1s, box-shadow 0.1s;
            width: 320px;
            text-align: center;
            box-sizing: border-box;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #3e2723;
        }

        .btn-success { background-color: #558b2f; border-color: #7cb342; box-shadow: 0 6px 0 #33691e; }
        .btn-success:active { box-shadow: 0 2px 0 #33691e; }

        .btn-danger { background-color: #c62828; border-color: #ef5350; box-shadow: 0 6px 0 #b71c1c; }
        .btn-danger:active { box-shadow: 0 2px 0 #b71c1c; }
        
        .btn-warning { background-color: #ef6c00; border-color: #ff9800; box-shadow: 0 6px 0 #e65100; color: #fff; }
        .btn-warning:active { box-shadow: 0 2px 0 #e65100; }
        
        .btn-google { background-color: #d32f2f; box-shadow: 0 6px 0 #b71c1c; }
        .btn-google:active { box-shadow: 0 2px 0 #b71c1c; }

        .btn-index { background-color: #78909c; box-shadow: 0 6px 0 #546e7a; }
        .btn-index:active { box-shadow: 0 2px 0 #546e7a; }

        .btn-small {
            padding: 5px 15px;
            font-size: 18px;
            width: auto;
            min-width: 80px;
            margin: 2px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }
        .btn-small:active {
            box-shadow: 0 1px 0 rgba(0,0,0,0.5);
        }

        #player-modal, #ranking-modal, #rule-modal {
            background: #4e342e; 
            border: 4px solid #ffca28;
            color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center;
            z-index: 200;
        }
        
        #player-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
        }
        
        #rule-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 900px;
            max-height: 80%;
            overflow-y: auto;
            text-align: left;
        }
        #rule-modal h3 {
            text-align: center;
            color: #ffca28;
            margin-top: 0;
            font-size: 32px;
        }
        #rule-modal p, #rule-modal li {
            font-size: 20px;
            line-height: 1.6;
        }

        #ranking-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            background-image: url('images/title.png');
            background-size: cover;
            background-position: center;
            background-color: rgba(43, 29, 14, 0.7);
            background-blend-mode: multiply;
        }

        #result-modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        #result-content {
            background: rgba(62, 39, 35, 0.95);
            border: 6px solid #ffca28;
            border-radius: 30px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 202, 40, 0.5);
            min-width: 500px;
        }

        /* Joker Selection Modal */
        #joker-selector {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #4e342e;
            border: 4px solid #ba68c8; /* Purple for Joker */
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center;
            z-index: 400;
            width: 500px;
        }
        #joker-selector h3 {
            color: #efebe9;
            margin-top: 0;
            font-size: 28px;
        }
        .num-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .num-btn {
            background: #fff;
            border: 2px solid #8d6e63;
            border-radius: 8px;
            font-size: 30px;
            font-weight: bold;
            color: #3e2723;
            cursor: pointer;
            padding: 15px 0;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            box-shadow: 0 4px 0 #a1887f;
        }
        .num-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #a1887f;
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #5d4037;
            padding: 10px 20px;
            margin: 5px 0;
            border-radius: 10px;
            border: 2px solid #8d6e63;
            font-size: 24px;
            color: #efebe9;
        }
        .player-row.selected {
            border-color: #ffca28;
            background-color: #4e342e;
            box-shadow: 0 0 10px #ffca28;
        }
        
        .input-group {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        input[type="text"] {
            font-size: 24px;
            padding: 5px 10px;
            border-radius: 10px;
            border: 2px solid #8d6e63;
            background: #efebe9;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            text-align: center;
            width: 250px;
            color: #3e2723;
        }

        #message-area {
            height: 30px;
            color: #ffab91;
            font-weight: bold;
            font-size: 20px;
            margin: 10px;
        }

        .ranking-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .ranking-tabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            border-radius: 10px 10px 0 0;
            background: #8d6e63;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            color: #efebe9;
        }
        .tab-btn.active {
            background: #ffca28;
            color: #3e2723;
        }
        .diff-tabs {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 10px;
        }
        .diff-btn {
            padding: 5px 15px;
            border: 2px solid #ffca28;
            background: #4e342e;
            border-radius: 20px;
            cursor: pointer;
            color: #ffca28;
            font-weight: bold;
        }
        .diff-btn.active {
            background: #ffca28;
            color: #3e2723;
        }
        
        #ranking-list {
            flex: 1;
            overflow-y: auto;
            background: rgba(93, 64, 55, 0.9);
            border-radius: 10px;
            padding: 10px;
            border: 2px solid #8d6e63;
        }
        .rank-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            border-bottom: 1px solid #795548;
            font-size: 22px;
            color: #efebe9;
        }
        .rank-row:nth-child(1) { color: #ffca28; font-weight: bold; }
        .rank-row:nth-child(2) { color: #d7ccc8; font-weight: bold; }
        .rank-row:nth-child(3) { color: #ffab91; font-weight: bold; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="1280" height="720" class="hidden"></canvas>

    <div id="title-screen" class="screen">
        <h1>ã‹ã‘ã–ã‚“ãƒ€ãƒ³ã‚¸ãƒ§ãƒ³</h1>
        <span class="subtitle">ï½åœ°åº•ã‹ã‚‰ã®è„±å‡ºï½</span>
        
        <div id="title-menu">
            <div id="current-player-display">ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’ãˆã‚‰ã‚“ã§ã­</div>
            <button class="btn btn-success" id="start-btn-trigger">ã¯ã˜ã‚ã‚‹</button>
            <button class="btn" onclick="openPlayerModal()">ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã›ã‚“ãŸã</button>
            <button class="btn btn-google" id="google-btn" onclick="handleGoogleAuth()">Googleã§ãƒ­ã‚°ã‚¤ãƒ³</button>
            <button class="btn btn-warning" onclick="showRanking()">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
            <button class="btn btn-index" onclick="location.href='../index.html'">INDEXã¸</button>
        </div>
    </div>

    <div id="player-modal" class="hidden">
        <h3>ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’ ãˆã‚‰ã‚“ã§ã­ï¼ˆ5ã«ã‚“ ã¾ã§ï¼‰</h3>
        <div id="player-list-container"></div>
        
        <div class="input-group">
            <input type="text" id="new-player-name" maxlength="8" placeholder="æ–°ã—ã„ãŠãªã¾ãˆ">
            <button class="btn btn-small btn-success" onclick="createPlayer()">ã¨ã†ã‚ã</button>
        </div>
        <div id="message-area"></div>
        <button class="btn btn-small btn-danger" style="margin-top:20px;" onclick="closePlayerModal()">ã¨ã˜ã‚‹</button>
    </div>

    <div id="rule-modal" class="hidden">
        <h3>ã‚ãã³ã‹ãŸ</h3>
        <ul>
            <li><strong>ã‚«ãƒ¼ãƒ‰ã§ã€Œé¢ç©ã€ã‚’ä½œã‚ã†ï¼</strong><br>
                æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰ã‚’2æšé¸ã‚“ã§ã€Œã‹ã‘ç®—ã€ã‚’ã—ã¾ã™ã€‚<br>
                ã§ããŸåºƒã•ï¼ˆé¢ç©ï¼‰ã®åˆ†ã ã‘ã€åœ°é¢ã«ã‚¿ã‚¤ãƒ«ã‚’ç½®ã‘ã¾ã™ã€‚
            </li>
            <li><strong>ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼(ğŸƒ)ã¯å¥½ããªæ•°å­—ã«ãªã‚Œã¾ã™ï¼</strong><br>
                ã‚¨ãƒªã‚¢ã«ç½®ãã¨ãã«1ï½10ã®å¥½ããªæ•°å­—ã‚’é¸ã¹ã¾ã™ã€‚
            </li>
            <li><strong>ã‚«ã‚®ã‚’é›†ã‚ã¦è„±å‡ºã ï¼</strong><br>
                ã‚¹ãƒ†ãƒ¼ã‚¸ã«ã‚ã‚‹ã€ŒğŸ—ï¸ ã‚«ã‚®ã€ã‚’é›†ã‚ã‚‹ã¨ã€æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã«é€²ã‚ã¾ã™ã€‚<br>
                ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸1ï½5ã¯5å€‹ã€6ä»¥é™ã¯ã‚¹ãƒ†ãƒ¼ã‚¸æ•°ã¨åŒã˜æ•°ãŒå¿…è¦ã§ã™ï¼‰
            </li>
            <li><strong>ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä½¿ãŠã†</strong><br>
                âš”ï¸ å‰£ï¼šãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å€’ã›ã¾ã™ï¼ˆ+200ç‚¹ï¼‰<br>
                â›ï¸ ã¤ã‚‹ã¯ã—ï¼šå²©ã‚’å£Šã›ã¾ã™ï¼ˆ+100ç‚¹ï¼‰<br>
                ğŸª„ é­”æ³•ã®æ–ï¼šæ•µã¨å²©ã‚’1/2ã®ç¢ºç‡ã§æ¶ˆæ»…ã•ã›ã¾ã™<br>
                ğŸƒ ã‚«ãƒ¼ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ï¼šå±±æœ­ãŒ1æšå¢—ãˆã¾ã™<br>
                ğŸ’° ãŠé‡‘ï¼šæ‹¾ã†ã¨ã‚¹ã‚³ã‚¢ãŒå¢—ãˆã¾ã™ï¼ˆ+300ç‚¹ï¼‰
            </li>
            <li><strong>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«æ³¨æ„</strong><br>
                æ‰‹æœ­ã¨å±±æœ­ã®ã‚«ãƒ¼ãƒ‰ãŒãªããªã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã§ã™ã€‚<br>
                ã‚«ãƒ¼ãƒ‰ã¯å¤§åˆ‡ã«ä½¿ãŠã†ï¼
            </li>
        </ul>
        <div style="text-align:center; margin-top:20px;">
            <button class="btn btn-small btn-danger" onclick="closeRules()">ã¨ã˜ã‚‹</button>
        </div>
    </div>

    <div id="difficulty-screen" class="screen hidden">
        <h2>ã©ã®ãƒ¢ãƒ¼ãƒ‰ã§ã¯ã˜ã‚ã‚‹ï¼Ÿ</h2>
        <div style="display:flex; flex-direction:column; gap:10px; align-items:center;">
            <button class="btn btn-success" onclick="startGame('EASY')">ã‹ã‚“ãŸã‚“</button>
            <button class="btn" onclick="startGame('NORMAL')">ãµã¤ã†</button>
            <button class="btn btn-danger" onclick="startGame('HARD')">ã‚€ãšã‹ã—ã„</button>
        </div>
        <button class="btn btn-index" style="margin-top: 50px;" onclick="backToTitle()">ã‚‚ã©ã‚‹</button>
    </div>

    <div id="joker-selector" class="hidden">
        <h3>ã™ããªã™ã†ã˜ã‚’ ãˆã‚‰ã‚“ã§ã­</h3>
        <div class="num-grid">
            <button class="num-btn" onclick="selectJokerValue(1)">1</button>
            <button class="num-btn" onclick="selectJokerValue(2)">2</button>
            <button class="num-btn" onclick="selectJokerValue(3)">3</button>
            <button class="num-btn" onclick="selectJokerValue(4)">4</button>
            <button class="num-btn" onclick="selectJokerValue(5)">5</button>
            <button class="num-btn" onclick="selectJokerValue(6)">6</button>
            <button class="num-btn" onclick="selectJokerValue(7)">7</button>
            <button class="num-btn" onclick="selectJokerValue(8)">8</button>
            <button class="num-btn" onclick="selectJokerValue(9)">9</button>
            <button class="num-btn" onclick="selectJokerValue(10)">10</button>
        </div>
    </div>

    <div id="result-modal" class="hidden">
        <div id="result-content">
            <h2 id="result-title" style="font-size:60px; color:#ffca28; margin:0 0 20px 0;">ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼</h2>
            <h1 id="final-score" style="color:#fff; font-size:50px; margin:0 0 10px 0;">SCORE: 0</h1>
            <div id="result-difficulty" style="font-size:24px; margin-bottom:30px; color:#d7ccc8;"></div>
            <button class="btn" onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
        </div>
    </div>

    <div id="ranking-modal" class="hidden">
        <div class="ranking-header">
            <h2>ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h2>
            <button class="btn btn-small btn-danger" onclick="closeRanking()">ã¨ã˜ã‚‹</button>
        </div>
        <div class="ranking-tabs">
            <button class="tab-btn active" id="tab-local" onclick="switchRankTab('local')">ã“ã®ãƒ‘ã‚½ã‚³ãƒ³</button>
            <button class="tab-btn" id="tab-world" onclick="switchRankTab('world')">ã¿ã‚“ãªã®è¨˜éŒ²</button>
        </div>
        <div class="diff-tabs">
            <button class="diff-btn active" id="rank-diff-easy" onclick="switchRankDiff('EASY')">ã‹ã‚“ãŸã‚“</button>
            <button class="diff-btn" id="rank-diff-normal" onclick="switchRankDiff('NORMAL')">ãµã¤ã†</button>
            <button class="diff-btn" id="rank-diff-hard" onclick="switchRankDiff('HARD')">ã‚€ãšã‹ã—ã„</button>
        </div>
        <div id="ranking-list">èª­ã¿è¾¼ã¿ä¸­...</div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getFirestore, collection, addDoc, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
        authDomain: "math-braves.firebaseapp.com",
        projectId: "math-braves",
        storageBucket: "math-braves.firebasestorage.app",
        messagingSenderId: "217117619290",
        appId: "1:217117619290:web:d227feb603970d3948d463"
    };

    try {
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹
        window.dbInstance = db;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;
        window.where = where;
        window.orderBy = orderBy;
        window.limit = limit;
        window.getDocs = getDocs;

        // èªè¨¼çŠ¶æ…‹ã®ç›£è¦–
        onAuthStateChanged(auth, (user) => {
            const btn = document.getElementById('google-btn');
            if (user && !user.isAnonymous) {
                // Googleãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿
                btn.textContent = "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ";
                btn.classList.remove("btn-google");
                btn.classList.add("btn-index"); // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆç”¨ã®è‰²ï¼ˆã‚°ãƒ¬ãƒ¼ç³»ï¼‰
                
                // ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼æƒ…å ±ã¯ä¸Šæ›¸ãã›ãšã€ãƒœã‚¿ãƒ³ã®è¦‹ãŸç›®ã ã‘å¤‰æ›´
            } else {
                // æœªãƒ­ã‚°ã‚¤ãƒ³ ã¾ãŸã¯ åŒ¿å
                btn.textContent = "Googleã§ãƒ­ã‚°ã‚¤ãƒ³";
                btn.classList.remove("btn-index");
                btn.classList.add("btn-google");
                
                if(!user) {
                    signInAnonymously(auth).catch(console.error);
                }
            }
        });

        // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
        window.handleGoogleAuth = async function() {
            const btn = document.getElementById('google-btn');
            if (auth.currentUser && !auth.currentUser.isAnonymous) {
                // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†
                try {
                    await signOut(auth);
                    alert("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ");
                } catch(e) {
                    alert("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                }
            } else {
                // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
                const provider = new GoogleAuthProvider();
                try {
                    await signInWithPopup(auth, provider);
                } catch(e) {
                    alert("ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                }
            }
        };

    } catch (err) {
        console.error("Firebase Init Error:", err);
    }
</script>

<script>
    // --- NG Words & Constants ---
    const NG_WORDS_HIRAGANA = [
        'ã—ã­', 'ã—ã¬', 'ã—ã«', 'ã“ã‚ã™', 'ã“ã‚ã›', 'ã•ã¤ãŒã„', 'ããŸã°ã‚Œ',
        'ã˜ã•ã¤', 'ãã•ã¤', 'ã¤ã‚‹ã™', 'ã‚Œã‚“ãŸã‚“', 'ã—ã«ãŸã„',
        'ã¦ã‚', 'ã¦ã‚ã‚Šã™ã¨', 'ã°ãã¯', 'ã°ãã ã‚“', 'ã»ã†ã‹',
        'ã¯ã‚“ã–ã„', 'ã”ã†ã¨ã†', 'ã‚†ã†ã‹ã„', 'ã‹ã‚“ãã‚“', 'ãŠãã†',
        'ã‚„ãã–', 'ã¼ã†ã‚Šã‚‡ã', 'ã¯ã‚“ãã‚Œ', 'ã¡ã‚“ã´ã‚‰', 'ã¾ãµãƒã‚',
        'ãŸã„ã¾', 'ã¾ã‚„ã', 'ã‹ãã›ã„ã–ã„', 'ã—ã‚ƒã¶', 'ã©ã‚‰ã£ã', 'ã“ã‹ã„ã‚“',
        'ã¸ã‚ã„ã‚“', 'ãˆãã™ãŸã—ãƒ¼', 'ã ã£ã½ã†', 'ãã‚ã›ã',
        'ã„ã˜ã‚', 'ãã‚ƒããŸã„',
        'ã°ã‹', 'ã‚ã»', 'ã¾ã¬ã‘', 'ãã¡ãŒã„', 'ãé•ã„',
        'ã†ã–ã„', 'ã†ã–', 'ãã‚‚ã„', 'ãã‚‚', 'ãã—ã‚‡ã„', 'ããˆã‚',
        'ããš', 'ã”ã¿', 'ã”ã¿ã‚€ã—', 'ã‹ã™', 'ã–ã“', 'ãœã¤',
        'ã¶ã™', 'ã§ã¶', 'ã¯ã’', 'ã¡ã³', 'ã§ã£ã±', 'ã„ãªã‹ã‚‚ã®',
        'ã†ã˜', 'ã¯ã„ã¼ã', 'ã¾ã‘ã„ã¬', 'ãŠã¤ã‚€', 'ã®ã†ãŸã‚Šã‚“',
        'ã¦ã„ã®ã†', 'ã¡ã—ã‚‡ã†', 'ã—ã‚‡ã†ãŒã„', 'ãŒã„ã˜', 'ã‹ãŸã‚', 'ã³ã£ã“',
        'ã‚ãã‚‰', 'ã¤ã‚“ã¼', 'ãŠã—', 'ã©ã˜ã‚“', 'ãˆãŸ', 'ã²ã«ã‚“',
        'ãŸã²', 'ãŸã²ã­', 'ã†ã›ã‚', 'ã ã¾ã‚Œ',
        'ã¡ã‚“ã¡ã‚“', 'ã¡ã‚“ã“', 'ã¡ã‚“ã½', 'ã¡ã‚“ã‹', 'ã¾ã‚‰', 'ã•ãŠ',
        'ã¾ã‚“ã“', 'ã¾ã‚“ã—ã‚…ã†', 'ã¾ã‚“ã’', 'ã‚ã‚Œã‚', 'ãŠã¾ãŸ',
        'ãã‚Š', 'ãã‚Šã¨ã‚Šã™', 'ã„ã‚“ã—ã‚“', 'ã„ã‚“ã‹ã', 'ã³ã‚‰ã³ã‚‰',
        'ã“ã†ãŒã‚“', 'ãŸã¾ãã‚“', 'ãã‚“ãŸã¾', 'ãµãã‚Š',
        'ãŠã£ã±ã„', 'ã¡ã¡', 'ã«ã‚…ã†ã‚Šã‚“', 'ã«ã‚…ã†ã¨ã†', 'ãã‚‡ã«ã‚…ã†', 'ã²ã‚“ã«ã‚…ã†',
        'ã‘ã¤', 'ã‚ãªã‚‹', 'ã“ã†ã‚‚ã‚“', 'ã‘ã¤ã®ã‚ãª',
        'ãˆã‚', 'ãˆã£ã¡', 'ã™ã‘ã¹', 'ã¸ã‚“ãŸã„', 'ã‚€ã£ã¤ã‚Š', 'ã—ã“',
        'ã›ã£ãã™', 'ã›ã„ã“ã†', 'ã¾ãã‚ã„', 'ãã†ã«ã‚…ã†', 'ã¯ã‚ã‚‹',
        'ãŠãªã«ãƒ¼', 'ã˜ã„', 'ã—ã“ã—ã“', 'ãµã‡ã‚‰', 'ã±ã„ãšã‚Š', 'ãã‚“ã«',
        'ã„ã‚‰ã¾', 'ã—ã£ã—ã‚“', 'ãªã‹ã ã—', 'ã”ã£ãã‚“', 'ã¶ã£ã‹ã‘',
        'ã—ãŠãµã', 'ãœã£ã¡ã‚‡ã†', 'ã„ã', 'ã„ã‹ã›ã‚', 'ã‚ãˆã',
        'ã©ã†ã¦ã„', 'ã—ã‚‡ã˜ã‚‡', 'ã‚„ã‚Šã¾ã‚“', 'ã‚„ã‚Šã¡ã‚“', 'ã³ã£ã¡',
        'ã›ãµã‚Œ', 'ã±ã“', 'ã±ã“ã±ã“', 'ã‚ã„ã›ã¤', 'ã‚ã‚Š', 'ã—ã‚‡ãŸ', 'ãºã©',
        'ãã‚“ã—ã‚“', 'ã˜ã‚…ã†ã‹ã‚“', 'ã‚Šã‚‡ã†ã˜ã‚‡ã', 'ã‚‰ã‚“ã“ã†', 'ã™ã‹ã‚“ã¨',
        'ã®ãƒ¼ã±ã‚“', 'ã±ã‚“ã¡ã‚‰',
        'ã‚Œã„ã·', 'ã”ã†ã‹ã‚“', 'ã¡ã‹ã‚“', 'ã¨ã†ã•ã¤', 'ã®ãã', 'ã‚ã—ã‚…ã¤',
        'ãµã†ãã', 'ããƒ¼ã·', 'ã¸ã‚‹ã™', 'ã§ã‚Šã¸ã‚‹', 'ã´ã‚“ã•ã‚', 'ã„ã‚ãã‚‰',
        'ã‚ã ã‚‹ã¨', 'ãˆãƒ¼ã¶ã„', 'ãˆã¶ã„', 'ã½ã‚‹ã®', 'ã†ã‚‰ã³ã§ãŠ', 'ã‚€ã—ã‚…ã†ã›ã„',
        'ãˆã‚“ã“ã†', 'ãˆã‚“ã˜ã‚‡', 'ã†ã‚Š', 'ã‹ã„ã—ã‚…ã‚“', 'ã°ã„ã—ã‚…ã‚“',
        'ã±ã±ã‹ã¤', 'ã¾ã¾ã‹ã¤', 'ã†ã‚Šã›ã‚“',
        'ã†ã‚“ã“', 'ã†ã‚“ã¡', 'ãã', 'ã’ã‚Š', 'ã¹ã‚“', 'ãµã‚“',
        'ã—ã£ã“', 'ã—ã‚‡ã‚“ã¹ã‚“', 'ã«ã‚‡ã†', 'ã»ã†ã«ã‚‡ã†',
        'ã¸', 'ãŠãªã‚‰', 'ã’ã‚', 'ãŸã‚“',
        'ã†ã‚“ãˆã„', 'ã“ã†ã—ã', 'ã™ãŸã£ãµ', 'ã‹ã‚“ã‚Š', 'ã±ã¨ã‚ãƒ¼ã‚‹',
        'ã˜ãˆã‚€', 'ã’ãƒ¼ã‚€ã¾ã™ãŸãƒ¼', 'ã¾ã™ãŸãƒ¼', 'ã‚ã©ã¿ã‚“', 'ã—ã™ã¦ã‚€',
        'ã•ãƒ¼ã°ãƒ¼', 'ã‚ã‹ã°ã‚“', 'ã°ã‚“', 'ã¡ãƒ¼ã¨', 'ã¡ãƒ¼ãŸãƒ¼', 'ã°ã',
        'ã‚‰ã„ã‚“', 'ã‹ã‹ãŠ', 'ã™ã‹ã„ã·', 'ã„ã‚“ã™ãŸ', 'ã¤ã„ã£ãŸãƒ¼', 'ã§ãƒã™ã“',
        'ã§ã‚“ã‚', 'ã°ã‚“ã”ã†', 'ã‘ã„ãŸã„', 'ã‚ã©ã‚Œã™', 'ã‚ã‚ã©', 'ã˜ã‚…ã†ã—ã‚‡',
        'ã‚ãŠ', 'ã‚ã„ãŸã„', 'ã¾ã¡ã‚ã‚ã›', 'ã»ã¦ã‚‹', 'ã‚‰ã¶ã»', 'ãŠãµã‹ã„',
        'ã±ã™ã‚ãƒ¼ã©', 'ã±ã™', 'ã‚ã‹ã†ã‚“ã¨', 'ã“ã˜ã‚“ã˜ã‚‡ã†ã»ã†'
    ];

    // --- Global Game State ---
    const CANVAS_WIDTH = 1280;
    const CANVAS_HEIGHT = 720;
    
    // Layout Constants
    const GRID_SIZE = 48; 
    const MAP_ROWS = 10;
    const MAP_COLS = 10;

    const LAYOUT = {
        sidebarW: 220,
        mapX: 250, 
        mapY: 40,
        mapW: 480, // 10 * 48
        itemY: 540,    
        calcX: 780,
        calcY: 40,     
        calcW: 420,
        calcH: 380, 
        deckX: 740,      
        deckY: 540,
        handStartX: 840, 
        handY: 540,
        cardW: 76,       
        cardH: 106,      
        cardGap: 86,
        rotateX: 780,
        rotateY: 440,
        rotateW: 200,
        rotateH: 80,
        trashX: 1000,
        trashY: 440, 
        trashW: 200,
        trashH: 80 
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- Patterns Generation (Deleted as requested) ---
    // Background patterns for monster and rock have been removed.
    
    let currentPlayer = null; 
    let gameState = "TITLE";
    let level = 1;
    let score = 0;
    let difficulty = "NORMAL"; 
    let currentDeck = 0; 
    let hand = []; // contains numbers or 'JOKER'
    let items = { sword: 0, pickaxe: 0, wand: 0, keys: 0 };
    let mapData = []; 
    let mapObjects = []; 
    
    let term1 = null; 
    let term2 = null; 
    let generatedRect = null; 
    let isDragging = null; 
    let dragPos = {x:0, y:0};
    let tapStartPos = {x:0, y:0}; 
    let floatingTexts = []; 
    
    // é…ç½®ç¢ºèªç”¨
    let placingState = null; 

    // ä¿ç•™ä¸­ã®ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼å‡¦ç†ç”¨
    let pendingJokerSlot = null; // 'term1' or 'term2'

    // ICONS
    const ICONS = {
        sword: 'âš”ï¸', pickaxe: 'â›ï¸', wand: 'ğŸª„', key: 'ğŸ—ï¸', 
        monster: 'ğŸ‘¾', rock: 'ğŸª¨', money: 'ğŸ’°', 
        trash: 'ğŸ—‘ï¸', rotate: 'ğŸ”„'
        // 'card' will be drawn manually
    };

    // --- Scaling ---
    function resize() {
        const container = document.getElementById('game-container');
        const scale = Math.min(window.innerWidth / CANVAS_WIDTH, window.innerHeight / CANVAS_HEIGHT);
        container.style.transform = `scale(${scale})`;
        const scaledWidth = CANVAS_WIDTH * scale;
        const scaledHeight = CANVAS_HEIGHT * scale;
        const left = (window.innerWidth - scaledWidth) / 2;
        const top = (window.innerHeight - scaledHeight) / 2;
        container.style.left = `${left}px`;
        container.style.top = `${top}px`;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Player Management ---
    let players = [];
    const MAX_PLAYERS = 5;

    function initPlayerSystem() {
        const stored = localStorage.getItem('kakezan_players');
        if (stored) players = JSON.parse(stored);
        else players = [];
        updatePlayerDisplay();
    }
    
    function updatePlayerDisplay() {
        const display = document.getElementById('current-player-display');
        if (currentPlayer) {
            display.textContent = `${currentPlayer.name} ã•ã‚“`;
            display.style.color = "#ffca28";
        } else {
            display.textContent = "ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’ãˆã‚‰ã‚“ã§ã­";
            display.style.color = "#ffffff";
        }
    }

    function renderPlayerList() {
        const container = document.getElementById('player-list-container');
        container.innerHTML = "";
        players.forEach((p, index) => {
            const div = document.createElement('div');
            div.className = `player-row ${currentPlayer && currentPlayer.id === p.id ? 'selected' : ''}`;
            div.innerHTML = `
                <span>${p.name}</span>
                <div>
                    <button class="btn btn-small btn-success" onclick="selectPlayer(${index})">ãˆã‚‰ã¶</button>
                    <button class="btn btn-small btn-danger" onclick="deletePlayer(${index})">ã‘ã™</button>
                </div>
            `;
            container.appendChild(div);
        });
        if (players.length === 0) container.innerHTML = "<p>ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ãŒã„ã¾ã›ã‚“ã€‚ã¨ã†ã‚ãã—ã¦ã­ã€‚</p>";
        else if (players.length >= MAX_PLAYERS) {
            document.getElementById('new-player-name').disabled = true;
            document.getElementById('new-player-name').placeholder = "5ã«ã‚“ ã¾ã§ã§ã™";
        } else {
            document.getElementById('new-player-name').disabled = false;
            document.getElementById('new-player-name').placeholder = "æ–°ã—ã„ãŠãªã¾ãˆ";
        }
    }

    window.openPlayerModal = function() {
        document.getElementById('player-modal').classList.remove('hidden');
        renderPlayerList();
    };
    window.closePlayerModal = function() {
        document.getElementById('player-modal').classList.add('hidden');
    };
    window.openRules = function() {
        document.getElementById('rule-modal').classList.remove('hidden');
    };
    window.closeRules = function() {
        document.getElementById('rule-modal').classList.add('hidden');
    };

    window.createPlayer = function() {
        const input = document.getElementById('new-player-name');
        const name = input.value.trim();
        const msg = document.getElementById('message-area');
        if (!name) { msg.textContent = "ãŠãªã¾ãˆã‚’ã„ã‚Œã¦ã­"; return; }
        if (name.length > 8) { msg.textContent = "8ã‚‚ã˜ ä»¥å†…ã§ã„ã‚Œã¦ã­"; return; }
        // ã²ã‚‰ãŒãªãƒã‚§ãƒƒã‚¯
        if (!/^[\u3040-\u309f]+$/.test(name)) {
             msg.textContent = "ã²ã‚‰ãŒãª ã ã‘ã§ ã„ã‚Œã¦ã­"; return;
        }
        if (players.length >= MAX_PLAYERS) { msg.textContent = "ã‚‚ã† ã„ã£ã±ã„ã§ã™"; return; }
        if (NG_WORDS_HIRAGANA.some(word => name.includes(word))) {
            msg.textContent = "ã¤ã‹ãˆãªã„ ã‚‚ã˜ãŒ ã¯ã„ã£ã¦ã„ã¾ã™"; return;
        }
        const newP = { name: name, id: Date.now().toString() };
        players.push(newP);
        localStorage.setItem('kakezan_players', JSON.stringify(players));
        input.value = "";
        msg.textContent = "";
        selectPlayer(players.length - 1);
    };

    window.selectPlayer = function(index) {
        currentPlayer = players[index];
        localStorage.setItem('kakezan_current_player_idx', index);
        updatePlayerDisplay();
        closePlayerModal();
    };

    window.deletePlayer = function(index) {
        if (!confirm("ã»ã‚“ã¨ã†ã« ã‘ã—ã¾ã™ã‹ï¼Ÿ")) return;
        if (currentPlayer && currentPlayer.id === players[index].id) {
            currentPlayer = null;
            updatePlayerDisplay();
        }
        players.splice(index, 1);
        localStorage.setItem('kakezan_players', JSON.stringify(players));
        renderPlayerList();
    };

    document.getElementById('start-btn-trigger').addEventListener('click', () => {
        if (!currentPlayer) {
            alert("ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’ ã›ã‚“ãŸã ã—ã¦ãã ã•ã„");
            openPlayerModal();
            return;
        }
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('difficulty-screen').classList.remove('hidden');
    });

    // --- Ranking System ---
    let rankTab = 'local';
    let rankDiff = 'EASY';

    window.showRanking = function() {
        document.getElementById('ranking-modal').classList.remove('hidden');
        loadRanking();
    };
    window.closeRanking = function() {
        document.getElementById('ranking-modal').classList.add('hidden');
    };
    window.switchRankTab = function(tab) {
        rankTab = tab;
        document.getElementById('tab-local').className = tab === 'local' ? 'tab-btn active' : 'tab-btn';
        document.getElementById('tab-world').className = tab === 'world' ? 'tab-btn active' : 'tab-btn';
        loadRanking();
    };
    window.switchRankDiff = function(diff) {
        rankDiff = diff;
        ['easy','normal','hard'].forEach(d => {
            document.getElementById(`rank-diff-${d}`).className = 
                diff === d.toUpperCase() ? 'diff-btn active' : 'diff-btn';
        });
        loadRanking();
    };

    async function loadRanking() {
        const list = document.getElementById('ranking-list');
        list.innerHTML = "èª­ã¿è¾¼ã¿ä¸­...";
        let data = [];
        if (rankTab === 'local') {
            const allScores = JSON.parse(localStorage.getItem('kakezan_local_scores') || '[]');
            data = allScores
                .filter(s => s.difficulty === rankDiff)
                .sort((a,b) => b.score - a.score)
                .slice(0, 10);
        } else {
            try {
                if(window.dbInstance && window.getDocs) {
                    const q = window.query(
                        window.collection(window.dbInstance, "scores_kakezan_dungeon"),
                        window.where("difficulty", "==", rankDiff),
                        window.orderBy("score", "desc"),
                        window.limit(10)
                    );
                    const snap = await window.getDocs(q);
                    snap.forEach(doc => data.push(doc.data()));
                }
            } catch(e) {
                console.error(e);
                list.innerHTML = "èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆå¾…ã¡ ã¾ãŸã¯ é€šä¿¡ã‚¨ãƒ©ãƒ¼ï¼‰";
                return;
            }
        }
        list.innerHTML = "";
        if (data.length === 0) {
            list.innerHTML = "<div style='text-align:center; padding:20px; color:#d7ccc8;'>ã¾ã  è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</div>";
            return;
        }
        data.forEach((d, i) => {
            const row = document.createElement('div');
            row.className = 'rank-row';
            row.innerHTML = `<span>${i+1}ä½</span> <span>${d.name}</span> <span>${d.score}ç‚¹</span>`;
            list.appendChild(row);
        });
    }

    // --- Game Logic ---
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let clientX = evt.clientX;
        let clientY = evt.clientY;
        if(evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
        } else if (evt.changedTouches && evt.changedTouches.length > 0) {
            clientX = evt.changedTouches[0].clientX;
            clientY = evt.changedTouches[0].clientY;
        }
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    canvas.addEventListener('mousedown', handleInputStart);
    canvas.addEventListener('touchstart', handleInputStart, {passive: false});
    canvas.addEventListener('mousemove', handleInputMove);
    canvas.addEventListener('touchmove', handleInputMove, {passive: false});
    canvas.addEventListener('mouseup', handleInputEnd);
    canvas.addEventListener('touchend', handleInputEnd);
    
    function getRequiredKeys(lvl) {
        return lvl <= 5 ? 5 : lvl;
    }

    function handleTap(x, y) {
        if(gameState !== "PLAYING") return;

        if (placingState) {
            const { pixelX, pixelY } = placingState;
            if (x >= pixelX + 10 && x <= pixelX + 110 && y >= pixelY - 20 && y <= pixelY + 20) {
                finalizePlacement();
                return;
            }
            if (x >= pixelX - 110 && x <= pixelX - 10 && y >= pixelY - 20 && y <= pixelY + 20) {
                placingState = null; 
                return;
            }
            return;
        }

        const reqKeys = getRequiredKeys(level);
        // Changed hitbox to match new button position (offset +220)
        if (x > LAYOUT.mapX + 220 && x < LAYOUT.mapX + 470 && y > LAYOUT.itemY + 80 && y < LAYOUT.itemY + 130) {
             if(items.keys >= reqKeys) nextStage();
        }
        
        if (x > 20 && x < 200 && y > 570 && y < 620) {
            openRules();
        }

        if (x > 20 && x < 200 && y > 640 && y < 690) {
            if(confirm("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚Šã¾ã™ãŒã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) gameOver(false);
        }

        const btnW = 150;
        const iY = 550; 
        if (x > LAYOUT.mapX + 320 && x < LAYOUT.mapX + 320 + btnW && y > iY && y < iY + 50) {
            useWand();
        }
        
        // å…¨æ¶ˆã—ãƒœã‚¿ãƒ³åˆ¤å®š (æ å†…å³å´ã®ALLãƒœã‚¿ãƒ³)
        const swordX = LAYOUT.mapX;
        const pickX = LAYOUT.mapX + 160;
        
        // Sword ALL
        const monsterCount = mapObjects.filter(o => o.type === 'monster').length;
        if (items.sword >= monsterCount && monsterCount > 0) {
             if (x > swordX + 100 && x < swordX + 145 && y > iY + 10 && y < iY + 40) {
                 useAllSwords(monsterCount);
                 return;
             }
        }
        // Pickaxe ALL
        const rockCount = mapObjects.filter(o => o.type === 'rock').length;
        if (items.pickaxe >= rockCount && rockCount > 0) {
             if (x > pickX + 100 && x < pickX + 145 && y > iY + 10 && y < iY + 40) {
                 useAllPickaxes(rockCount);
                 return;
             }
        }
        
        if (generatedRect && !isDragging && !placingState) {
            if (x > LAYOUT.rotateX && x < LAYOUT.rotateX + LAYOUT.rotateW && 
                y > LAYOUT.rotateY && y < LAYOUT.rotateY + LAYOUT.rotateH) {
                 const temp = generatedRect.w;
                 generatedRect.w = generatedRect.h;
                 generatedRect.h = temp;
                 return;
            }
        }
    }

    function handleInputStart(e) {
        if(gameState !== 'PLAYING') return;
        if(e.type === 'touchstart') e.preventDefault();
        const pos = getMousePos(e);
        tapStartPos = pos;
        if(placingState) return;

        // Hand
        for(let i=0; i<hand.length; i++) {
            const hx = LAYOUT.handStartX + i * LAYOUT.cardGap;
            const hy = LAYOUT.handY + 20;
            if (pos.x >= hx && pos.x <= hx + LAYOUT.cardW && pos.y >= hy && pos.y <= hy + LAYOUT.cardH) {
                isDragging = { type: 'card', index: i, val: hand[i] };
                dragPos = pos;
                return;
            }
        }

        // Generated Rect
        if (generatedRect) {
            const cx = LAYOUT.calcX + LAYOUT.calcW/2;
            const cy = LAYOUT.calcY + LAYOUT.calcH/2;
            const rw = generatedRect.w * GRID_SIZE;
            const rh = generatedRect.h * GRID_SIZE;
            if (pos.x >= cx - rw/2 && pos.x <= cx + rw/2 &&
                 pos.y >= cy - rh/2 && pos.y <= cy + rh/2) {
                 isDragging = { type: 'rect', obj: generatedRect };
                 dragPos = pos;
                 return;
            }
        }

        // Items
        const iY = 550;
        const btnW = 150;
        const swordX = LAYOUT.mapX;
        const pickX = LAYOUT.mapX + 160;

        // Sword Drag check (ALLãƒœã‚¿ãƒ³é ˜åŸŸã¯é™¤å¤–)
        if (items.sword > 0 && pos.x > swordX && pos.x < swordX + btnW && pos.y > iY && pos.y < iY + 50) {
             const mCount = mapObjects.filter(o => o.type === 'monster').length;
             // ALLãƒœã‚¿ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãã®ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã—ãªã„
             if (items.sword >= mCount && mCount > 0) {
                 if (pos.x > swordX + 100 && pos.x < swordX + 145 && pos.y > iY + 10 && pos.y < iY + 40) {
                     return; 
                 }
             }
             isDragging = { type: 'item', itemType: 'sword' };
             dragPos = pos;
             return;
        }
        // Pickaxe Drag check (ALLãƒœã‚¿ãƒ³é ˜åŸŸã¯é™¤å¤–)
        if (items.pickaxe > 0 && pos.x > pickX && pos.x < pickX + btnW && pos.y > iY && pos.y < iY + 50) {
             const rCount = mapObjects.filter(o => o.type === 'rock').length;
             if (items.pickaxe >= rCount && rCount > 0) {
                 if (pos.x > pickX + 100 && pos.x < pickX + 145 && pos.y > iY + 10 && pos.y < iY + 40) {
                     return;
                 }
             }
             isDragging = { type: 'item', itemType: 'pickaxe' };
             dragPos = pos;
             return;
        }
    }

    function handleInputMove(e) {
        if (!isDragging) return;
        if(e.type === 'touchmove') e.preventDefault();
        dragPos = getMousePos(e);
    }

    function handleInputEnd(e) {
        if (!isDragging) {
            const endPos = getMousePos(e);
            const dist = Math.hypot(endPos.x - tapStartPos.x, endPos.y - tapStartPos.y);
            if (dist < 20) {
                handleTap(endPos.x, endPos.y);
            }
            return;
        }

        const dropX = dragPos.x;
        const dropY = dragPos.y;

        // Trash
        if (dropX > LAYOUT.trashX && dropX < LAYOUT.trashX + LAYOUT.trashW &&
            dropY > LAYOUT.trashY && dropY < LAYOUT.trashY + LAYOUT.trashH) {
            if (isDragging.type === 'card') {
                hand.splice(isDragging.index, 1);
                replenishHand();
            } else if (isDragging.type === 'rect') {
                resetCalc();
            }
            isDragging = null;
            checkGameOver();
            return;
        }

        // Calc Zone
        if (isDragging.type === 'card' && 
            dropX > LAYOUT.calcX && dropX < LAYOUT.calcX + LAYOUT.calcW &&
            dropY > LAYOUT.calcY && dropY < LAYOUT.calcY + LAYOUT.calcH) {
            
            if (!generatedRect) {
                // Determine logic for Joker or Number
                const cardVal = isDragging.val;
                
                if (cardVal === 'JOKER') {
                    // Show Selector
                    if (term1 === null) pendingJokerSlot = 'term1';
                    else if (term2 === null) pendingJokerSlot = 'term2';
                    else { isDragging = null; return; } // Full

                    document.getElementById('joker-selector').classList.remove('hidden');
                    // Remove card now
                    hand.splice(isDragging.index, 1);
                    replenishHand();
                    isDragging = null;
                    return;
                } else {
                    // Normal Number
                    if (term1 === null) {
                        term1 = cardVal;
                        hand.splice(isDragging.index, 1);
                        replenishHand();
                    } else if (term2 === null) {
                        term2 = cardVal;
                        hand.splice(isDragging.index, 1);
                        replenishHand();
                        startCalculation();
                    }
                }
            }
        }

        // Map Zone
        const mapW = MAP_COLS * GRID_SIZE;
        const mapH = MAP_ROWS * GRID_SIZE;
        if (dropX > LAYOUT.mapX && dropX < LAYOUT.mapX + mapW &&
            dropY > LAYOUT.mapY && dropY < LAYOUT.mapY + mapH) {
            
            if (isDragging.type === 'rect') {
                startPlacing(dropX, dropY);
            } else if (isDragging.type === 'item') {
                const gx = Math.floor((dropX - LAYOUT.mapX) / GRID_SIZE);
                const gy = Math.floor((dropY - LAYOUT.mapY) / GRID_SIZE);
                tryUseItem(gx, gy, isDragging.itemType);
            }
        }

        isDragging = null;
        checkGameOver();
    }

    // Joker selection
    window.selectJokerValue = function(val) {
        document.getElementById('joker-selector').classList.add('hidden');
        if (pendingJokerSlot === 'term1') {
            term1 = val;
        } else if (pendingJokerSlot === 'term2') {
            term2 = val;
            startCalculation();
        }
        pendingJokerSlot = null;
    }

    // Logic
    function startCalculation() {
        generatedRect = {
            w: term1,
            h: term2,
            color: getRandomColor(),
            value: term1 * term2
        };
    }
    
    function resetCalc() {
        generatedRect = null;
        term1 = null;
        term2 = null;
    }

    function getRandomColor() {
        const colors = ['#e57373', '#ffb74d', '#fff176', '#81c784', '#64b5f6', '#ba68c8', '#4db6ac'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    function replenishHand() {
        while (hand.length < 5 && currentDeck > 0) {
            // 20åˆ†ã®1 (5%) ã§ JOKER
            if (Math.random() < 0.05) {
                hand.push('JOKER');
            } else {
                hand.push(Math.floor(Math.random() * 10) + 1);
            }
            currentDeck--;
        }
    }

    function startPlacing(mouseX, mouseY) {
        const rect = { 
            w: generatedRect.w, 
            h: generatedRect.h, 
            color: generatedRect.color, 
            value: generatedRect.value 
        }; 

        const relX = mouseX - LAYOUT.mapX;
        const relY = mouseY - LAYOUT.mapY;
        const gridCenterX = relX / GRID_SIZE;
        const gridCenterY = relY / GRID_SIZE;
        
        let gx = Math.round(gridCenterX - rect.w / 2);
        let gy = Math.round(gridCenterY - rect.h / 2);
        
        if (gx < 0) gx = 0;
        if (gy < 0) gy = 0;
        if (gx + rect.w > MAP_COLS) gx = MAP_COLS - rect.w;
        if (gy + rect.h > MAP_ROWS) gy = MAP_ROWS - rect.h;

        const pixelX = LAYOUT.mapX + gx * GRID_SIZE + (rect.w * GRID_SIZE) / 2;
        const pixelY = LAYOUT.mapY + gy * GRID_SIZE + (rect.h * GRID_SIZE) / 2;

        placingState = {
            rect: rect,
            gx: gx,
            gy: gy,
            pixelX: pixelX,
            pixelY: pixelY
        };
    }

    function finalizePlacement() {
        if (!placingState) return;
        const { rect, gx, gy } = placingState;

        if (gx + rect.w > MAP_COLS || gy + rect.h > MAP_ROWS) {
            alert("ãã“ã«ã¯ ãŠã‘ã¾ã›ã‚“ï¼ˆã¯ã¿ã ã—ã¦ã„ã¾ã™ï¼‰");
            return;
        }

        for(let y=0; y<rect.h; y++) {
            for(let x=0; x<rect.w; x++) {
                const tx = gx + x;
                const ty = gy + y;
                if (mapData[ty][tx]) {
                    alert("ãã“ã«ã¯ ã™ã§ã« ãªã«ã‹ã‚ã‚Šã¾ã™");
                    return; 
                }
                const obj = mapObjects.find(o => o.x === tx && o.y === ty);
                if (obj && (obj.type === 'monster' || obj.type === 'rock')) {
                    alert("ã˜ã‚ƒã¾ãªã‚‚ã®ï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‹å²©ï¼‰ãŒ ã‚ã‚Šã¾ã™");
                    return;
                }
            }
        }

        const area = rect.w * rect.h;
        let scoreAdd = area * area;

        for(let y=0; y<rect.h; y++) {
            for(let x=0; x<rect.w; x++) {
                const tx = gx + x;
                const ty = gy + y;
                mapData[ty][tx] = { color: rect.color };
                
                const objIndex = mapObjects.findIndex(o => o.x === tx && o.y === ty);
                if (objIndex !== -1) {
                    const obj = mapObjects[objIndex];
                    collectItem(obj);
                    mapObjects.splice(objIndex, 1);
                }
            }
        }
        score += scoreAdd;
        
        addFloatingText(LAYOUT.mapX + gx*GRID_SIZE + (rect.w*GRID_SIZE)/2 - 30, 
                        LAYOUT.mapY + gy*GRID_SIZE + (rect.h*GRID_SIZE)/2, 
                        `+${area*area}`, "#ffffff");

        resetCalc();
        placingState = null;
        checkGameOver();
    }

    function collectItem(obj) {
        if (obj.type === 'key') items.keys++;
        else if (obj.type === 'sword') items.sword++;
        else if (obj.type === 'pickaxe') items.pickaxe++;
        else if (obj.type === 'wand') items.wand++;
        else if (obj.type === 'money') {
            score += 300;
            addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+300G", "#fff176");
        }
        else if (obj.type === 'card') {
            currentDeck += 1;
            addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+1æš", "#81c784");
            if (hand.length <= 4) replenishHand();
        }
    }

    function tryUseItem(gx, gy, itemType) {
        const objIndex = mapObjects.findIndex(o => o.x === gx && o.y === gy);
        if (objIndex === -1) return;
        const obj = mapObjects[objIndex];

        if (itemType === 'sword' && obj.type === 'monster') {
            mapObjects.splice(objIndex, 1);
            items.sword--;
            score += 200;
            addFloatingText(LAYOUT.mapX + gx*GRID_SIZE, LAYOUT.mapY + gy*GRID_SIZE, "+200", "#e57373");
        } else if (itemType === 'pickaxe' && obj.type === 'rock') {
            mapObjects.splice(objIndex, 1);
            items.pickaxe--;
            score += 100;
            addFloatingText(LAYOUT.mapX + gx*GRID_SIZE, LAYOUT.mapY + gy*GRID_SIZE, "+100", "#90a4ae");
        }
    }

    function useWand() {
        if (items.wand <= 0) return;
        if (!confirm("ã¾ã»ã†ã®ã¤ãˆ ã‚’ ã¤ã‹ã„ã¾ã™ã‹ï¼Ÿ\nï¼ˆã¦ã ã¨ ã„ã‚ ãŒ 50%ã®ã‹ãã‚Šã¤ã§ ããˆã¾ã™ï¼‰")) return;
        items.wand--;
        
        let removedCount = 0;
        for (let i = mapObjects.length - 1; i >= 0; i--) {
            const obj = mapObjects[i];
            if (obj.type === 'monster' || obj.type === 'rock') {
                if (Math.random() < 0.5) {
                    addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "æ¶ˆæ»…ï¼", "#ba68c8");
                    mapObjects.splice(i, 1);
                    removedCount++;
                }
            }
        }
        if (removedCount === 0) {
             addFloatingText(LAYOUT.mapX + LAYOUT.mapW/2 - 50, LAYOUT.mapY + 240, "ãƒŸã‚¹ï¼", "#fff");
        }
    }
    
    function useAllSwords(count) {
        if (!confirm("ã¦ãã‚’ãœã‚“ã¶ãŸãŠã—ã¾ã™ã‹ï¼Ÿ")) return;
        items.sword -= count;
        score += count * 200;
        
        for (let i = mapObjects.length - 1; i >= 0; i--) {
            if (mapObjects[i].type === 'monster') {
                const obj = mapObjects[i];
                addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+200", "#e57373");
                mapObjects.splice(i, 1);
            }
        }
    }

    function useAllPickaxes(count) {
        if (!confirm("ã„ã‚ã‚’ãœã‚“ã¶ã“ã‚ã—ã¾ã™ã‹ï¼Ÿ")) return;
        items.pickaxe -= count;
        score += count * 100;
        
        for (let i = mapObjects.length - 1; i >= 0; i--) {
            if (mapObjects[i].type === 'rock') {
                const obj = mapObjects[i];
                addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+100", "#90a4ae");
                mapObjects.splice(i, 1);
            }
        }
    }

    function addFloatingText(x, y, text, color) {
        if (gameState !== "PLAYING") return;
        floatingTexts.push({x, y, text, color, life: 60});
    }

    function checkGameOver() {
        // ã‚¹ãƒ†ãƒ¼ã‚¸10ã§éµãŒæƒã£ã¦ã„ã‚‹å ´åˆã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šã—ãªã„ï¼ˆã‚¯ãƒªã‚¢å¾…ã¡ï¼‰
        if (level === 10 && items.keys >= getRequiredKeys(level)) {
            return;
        }

        if (hand.length <= 1 && currentDeck === 0 && !generatedRect && term1 === null) {
            gameOver(false);
        }
    }

    function nextStage() {
        level++;
        if (level > 10) {
            gameOver(true);
        } else {
            replenishHand();
            initLevel();
        }
    }

    function gameOver(cleared) {
        gameState = cleared ? "CLEARED" : "GAMEOVER";
        document.getElementById('result-modal').classList.remove('hidden');
        document.getElementById('result-title').textContent = cleared ? "ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼" : "ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼";
        document.getElementById('final-score').textContent = "SCORE: " + score;
        document.getElementById('result-difficulty').textContent = `é›£æ˜“åº¦: ${difficulty === 'EASY' ? 'ã‹ã‚“ãŸã‚“' : difficulty === 'NORMAL' ? 'ãµã¤ã†' : 'ã‚€ãšã‹ã—ã„'}`;
        saveLocalScore();
        saveFirebaseScore();
    }

    function saveLocalScore() {
        let scores = JSON.parse(localStorage.getItem('kakezan_local_scores') || '[]');
        scores.push({
            name: currentPlayer.name,
            score: score,
            difficulty: difficulty,
            date: new Date().toISOString()
        });
        localStorage.setItem('kakezan_local_scores', JSON.stringify(scores));
    }

    function saveFirebaseScore() {
        if(window.addDoc && window.collection && window.dbInstance) {
            window.addDoc(window.collection(window.dbInstance, "scores_kakezan_dungeon"), {
                name: currentPlayer.name,
                score: score,
                difficulty: difficulty,
                date: new Date()
            }).catch(e => console.warn("Score save failed", e));
        }
    }

    window.backToTitle = function() {
        gameState = "TITLE";
        document.getElementById('result-modal').classList.add('hidden');
        document.getElementById('difficulty-screen').classList.add('hidden');
        document.getElementById('title-screen').classList.remove('hidden');
        canvas.classList.add('hidden');
    };

    window.startGame = function(diffMode) {
        difficulty = diffMode;
        if (diffMode === 'EASY') currentDeck = 20;
        else if (diffMode === 'NORMAL') currentDeck = 15;
        else currentDeck = 10;
        
        items = { sword: 2, pickaxe: 2, wand: 0, keys: 0 };
        score = 0;
        level = 1;
        
        hand = [];
        replenishHand(); 
        floatingTexts = []; 

        document.getElementById('difficulty-screen').classList.add('hidden');
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('result-modal').classList.add('hidden');
        canvas.classList.remove('hidden');
        
        gameState = "PLAYING";
        initLevel();
        requestAnimationFrame(gameLoop);
    }

    function getObjectProbabilities(n, diff) {
        let probs = {
            monster: 0, rock: 0, sword: 0, pickaxe: 0,
            wand: 0, card: 0, money: 0
        };

        // å…±é€šãƒ»åŸºæœ¬è¨­å®š
        probs.wand = 0.1 * n; // å¤‰æ›´ç‚¹

        if (diff === 'EASY') {
            probs.monster = 3 + 0.2 * n;
            probs.rock    = 3 + 0.2 * n;
            probs.sword   = 3 + 0.1 * n;
            probs.pickaxe = 3 + 0.1 * n;
            probs.card    = 6; // å¤‰æ›´ç‚¹
            probs.money   = 10;
        } else if (diff === 'NORMAL') {
            probs.monster = 3 + 0.3 * n;
            probs.rock    = 3 + 0.3 * n;
            probs.sword   = 3 + 0.15 * n;
            probs.pickaxe = 3 + 0.15 * n;
            probs.card    = 5; // å¤‰æ›´ç‚¹
            probs.money   = 20;
        } else { // HARD
            probs.monster = 3 + 0.4 * n; 
            probs.rock    = 3 + 0.4 * n;
            probs.sword   = 3 + 0.2 * n;
            probs.pickaxe = 3 + 0.2 * n;
            probs.card    = 4; // å¤‰æ›´ç‚¹
            probs.money   = 30;
        }

        return probs;
    }

    function initLevel() {
        mapData = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(null));
        mapObjects = [];
        items.keys = 0;
        resetCalc();

        let emptySpots = [];
        for(let r=0; r<MAP_ROWS; r++) {
            for(let c=0; c<MAP_COLS; c++) {
                emptySpots.push({x:c, y:r});
            }
        }
        function popRandSpot() {
            if(emptySpots.length === 0) return null;
            const idx = Math.floor(Math.random() * emptySpots.length);
            return emptySpots.splice(idx, 1)[0];
        }

        // éµã®æ•°ã‚’æ±ºå®šï¼ˆã‚¹ãƒ†ãƒ¼ã‚¸1-5ã¯5å€‹ã€6ä»¥é™ã¯ã‚¹ãƒ†ãƒ¼ã‚¸æ•°ï¼‰
        const keyCount = getRequiredKeys(level);

        for(let i=0; i<keyCount; i++) {
            let p = popRandSpot(); 
            if(p) mapObjects.push({x: p.x, y: p.y, type: 'key'});
        }
        
        const probs = getObjectProbabilities(level, difficulty);
        
        const table = [
            { type: 'monster', p: probs.monster },
            { type: 'rock',    p: probs.rock },
            { type: 'sword',   p: probs.sword },
            { type: 'pickaxe', p: probs.pickaxe },
            { type: 'wand',    p: probs.wand },
            { type: 'card',    p: probs.card },
            { type: 'money',   p: probs.money }
        ];

        while(emptySpots.length > 0) {
            let p = popRandSpot();
            if(!p) break;

            let rand = Math.random() * 100; 
            let cumulative = 0;
            
            for(let t of table) {
                cumulative += t.p;
                if (rand < cumulative) {
                    mapObjects.push({x: p.x, y: p.y, type: t.type});
                    break; 
                }
            }
        }
    }

    // --- Drawing ---
    
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    }

    function gameLoop() {
        if (gameState !== "PLAYING" && gameState !== "GAMEOVER" && gameState !== "CLEARED") return;
        
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        // Background
        ctx.fillStyle = "#3e2723"; 
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Sidebar
        ctx.fillStyle = "#4e342e";
        ctx.fillRect(0, 0, LAYOUT.sidebarW, 720);
        ctx.strokeStyle = "#8d6e63";
        ctx.lineWidth = 4;
        ctx.strokeRect(10, 10, LAYOUT.sidebarW-20, 700);

        ctx.textAlign = "center";
        
        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼", LAYOUT.sidebarW/2, 40);
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 28px 'M PLUS Rounded 1c'";
        ctx.fillText(currentPlayer ? currentPlayer.name : "ã‚²ã‚¹ãƒˆ", LAYOUT.sidebarW/2, 75);

        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("ãªã‚“ã„ã©", LAYOUT.sidebarW/2, 125);
        let diffLabel = difficulty === 'EASY' ? 'ã‹ã‚“ãŸã‚“' : difficulty === 'NORMAL' ? 'ãµã¤ã†' : 'ã‚€ãšã‹ã—ã„';
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 28px 'M PLUS Rounded 1c'";
        ctx.fillText(diffLabel, LAYOUT.sidebarW/2, 160);

        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("ã‚¹ãƒ†ãƒ¼ã‚¸", LAYOUT.sidebarW/2, 220);
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 40px 'M PLUS Rounded 1c'"; 
        // 11ä»¥ä¸Šã®è¡¨ç¤ºã«ã¯ãªã‚‰ãªã„ã‚ˆã†ã«
        ctx.fillText(`${Math.min(level, 10)}/10`, LAYOUT.sidebarW/2, 280);
        
        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("ã‚¹ã‚³ã‚¢", LAYOUT.sidebarW/2, 350);
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 40px 'M PLUS Rounded 1c'";
        ctx.fillText(`${score}`, LAYOUT.sidebarW/2, 400);

        drawButton(20, 570, 180, 50, "ã‚ãã³ã‹ãŸ", "#5d4037");
        drawButton(20, 640, 180, 50, "ã‚¿ã‚¤ãƒˆãƒ«ã¸", "#78909c");

        // Map Area
        ctx.save();
        ctx.globalAlpha = 1.0; 
        ctx.translate(LAYOUT.mapX, LAYOUT.mapY);
        
        ctx.fillStyle = "#ffffff"; 
        ctx.fillRect(0, 0, MAP_COLS*GRID_SIZE, MAP_ROWS*GRID_SIZE);

        for(let r=0; r<=MAP_ROWS; r++) {
            ctx.lineWidth = (r % 5 === 0) ? 3 : 1; 
            ctx.strokeStyle = "#8d6e63";
            ctx.beginPath(); ctx.moveTo(0, r*GRID_SIZE); ctx.lineTo(MAP_COLS*GRID_SIZE, r*GRID_SIZE); ctx.stroke();
        }
        for(let c=0; c<=MAP_COLS; c++) {
            ctx.lineWidth = (c % 5 === 0) ? 3 : 1; 
            ctx.strokeStyle = "#8d6e63";
            ctx.beginPath(); ctx.moveTo(c*GRID_SIZE, 0); ctx.lineTo(c*GRID_SIZE, MAP_ROWS*GRID_SIZE); ctx.stroke();
        }

        // Draw Map Objects (Backgrounds)
        mapObjects.forEach(obj => {
            if (obj.type === 'money') return;

            let bgColor = null;
            // æ ç·šã®è¨­å®šï¼ˆãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãƒ»å²©ç”¨ï¼‰
            let borderColor = null;

            if (obj.type === 'monster') {
                bgColor = "#CC4D16";
                borderColor = "#1a1a1a"; 
            }
            else if (obj.type === 'rock') {
                bgColor = "rgba(62, 39, 35, 0.8)"; 
                borderColor = "#1a1a1a"; 
            }
            else if (obj.type === 'key') bgColor = "#F0EBB2";
            else if (obj.type === 'card') {
                bgColor = null; 
            }
            else if (obj.type === 'sword') bgColor = "#CFD0F0";
            else if (obj.type === 'pickaxe') bgColor = "#D0F0CF";
            else if (obj.type === 'wand') bgColor = "#B1E0DB";

            if (bgColor) {
                ctx.fillStyle = bgColor;
                ctx.fillRect(obj.x*GRID_SIZE+1, obj.y*GRID_SIZE+1, GRID_SIZE-2, GRID_SIZE-2);
            }

            // ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã¨å²©ã®æ ç·šæç”»
            if (borderColor) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2; 
                ctx.strokeRect(obj.x*GRID_SIZE+2, obj.y*GRID_SIZE+2, GRID_SIZE-4, GRID_SIZE-4);
            }
        });

        // Placed Rects
        for(let r=0; r<MAP_ROWS; r++) {
            for(let c=0; c<MAP_COLS; c++) {
                if (mapData[r][c]) {
                    ctx.fillStyle = mapData[r][c].color;
                    ctx.fillRect(c*GRID_SIZE + 1, r*GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    ctx.beginPath();
                    ctx.moveTo(c*GRID_SIZE + 1, r*GRID_SIZE + 1);
                    ctx.lineTo(c*GRID_SIZE + 15, r*GRID_SIZE + 1);
                    ctx.lineTo(c*GRID_SIZE + 1, r*GRID_SIZE + 15);
                    ctx.fill();
                }
            }
        }

        // Draw Map Objects (Icons)
        ctx.font = "32px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        mapObjects.forEach(obj => {
            if (obj.type === 'money') return;

            // ã‚«ãƒ¼ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚«ã‚¹ã‚¿ãƒ æç”»
            if (obj.type === 'card') {
                const cx = obj.x*GRID_SIZE + GRID_SIZE/2;
                const cy = obj.y*GRID_SIZE + GRID_SIZE/2;
                // ç™½ã„ã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ©ã‚¹ãƒˆ
                ctx.save();
                ctx.translate(cx, cy);
                ctx.fillStyle = "#fff";
                ctx.fillRect(-12, -16, 24, 32); // ã‚«ãƒ¼ãƒ‰æœ¬ä½“
                ctx.strokeStyle = "#4e342e";
                ctx.lineWidth = 1;
                ctx.strokeRect(-12, -16, 24, 32); // ã‚«ãƒ¼ãƒ‰æ 
                // ä¸­ã®æ¨¡æ§˜ï¼ˆãƒãƒ¼ãƒˆï¼‰
                ctx.fillStyle = "#e91e63";
                ctx.font = "16px sans-serif";
                ctx.fillText("â™¥", 0, 0); 
                ctx.restore();
            } else {
                let icon = ICONS[obj.type] || '?';
                ctx.fillStyle = "#000000"; 
                ctx.fillText(icon, obj.x*GRID_SIZE + GRID_SIZE/2, obj.y*GRID_SIZE + GRID_SIZE/2 + 2);
            }
        });
        
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 4;
        ctx.roundRect(0,0, MAP_COLS*GRID_SIZE, MAP_ROWS*GRID_SIZE, 8).stroke();
        
        ctx.restore();

        // Items Display
        const iY = 550; 
        const btnW = 150;
        const swordX = LAYOUT.mapX;
        const pickX = LAYOUT.mapX + 160;

        // Sword Icon
        drawItemIcon(swordX, iY, btnW, 50, 'sword', items.sword);
        // å…¨æ¶ˆã—ãƒœã‚¿ãƒ³ (Sword)
        const monsterCount = mapObjects.filter(o => o.type === 'monster').length;
        if (items.sword >= monsterCount && monsterCount > 0) {
            drawButton(swordX + 100, iY + 10, 45, 30, "ALL", "#d32f2f");
        }

        // Pickaxe Icon
        drawItemIcon(pickX, iY, btnW, 50, 'pickaxe', items.pickaxe);
        // å…¨æ¶ˆã—ãƒœã‚¿ãƒ³ (Pickaxe)
        const rockCount = mapObjects.filter(o => o.type === 'rock').length;
        if (items.pickaxe >= rockCount && rockCount > 0) {
            drawButton(pickX + 100, iY + 10, 45, 30, "ALL", "#78909c");
        }
        
        // Wand Icon
        drawItemIcon(LAYOUT.mapX + 320, iY, btnW, 50, 'wand', items.wand);
        
        // Keys
        ctx.fillStyle = "#ffca28";
        ctx.textAlign = "left";
        const reqKeys = getRequiredKeys(level);
        for(let i=0; i<reqKeys; i++) {
            ctx.save();
            ctx.globalAlpha = i < items.keys ? 1.0 : 0.2;
            ctx.font = "30px serif";
            // 2åˆ—ç›®åˆ¤å®š
            const col = i % 5;
            const row = Math.floor(i / 5);
            ctx.fillText("ğŸ—ï¸", LAYOUT.mapX + 10 + col * 35, iY + 100 + row * 35);
            ctx.restore();
        }

        // Updated button position (+220 offset)
        if (items.keys >= reqKeys) {
             drawButton(LAYOUT.mapX + 220, iY + 75, 250, 50, "ã¤ãã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸", "#558b2f");
        } else {
             drawButton(LAYOUT.mapX + 220, iY + 75, 250, 50, "ã‚«ã‚®ã‚’ã‚ã¤ã‚ã‚ˆã†", "#78909c");
        }

        // Calc Area
        ctx.fillStyle = "#4e342e";
        ctx.roundRect(LAYOUT.calcX, LAYOUT.calcY, LAYOUT.calcW, LAYOUT.calcH, 12).fill();
        ctx.strokeStyle = "#8d6e63";
        ctx.lineWidth = 5;
        ctx.roundRect(LAYOUT.calcX, LAYOUT.calcY, LAYOUT.calcW, LAYOUT.calcH, 12).stroke();

        ctx.fillStyle = "#efebe9";
        ctx.font = "80px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        let dispTerm1 = term1 === null ? "â–¡" : term1;
        let dispTerm2 = term2 === null ? "â–¡" : term2;
        let calcText = `${dispTerm1} Ã— ${dispTerm2}`;
        ctx.fillText(calcText, LAYOUT.calcX + LAYOUT.calcW/2, LAYOUT.calcY + LAYOUT.calcH/2);

        if (generatedRect && isDragging?.obj !== generatedRect && !placingState) {
             const cx = LAYOUT.calcX + LAYOUT.calcW/2;
             const cy = LAYOUT.calcY + LAYOUT.calcH/2;
             const rw = generatedRect.w * GRID_SIZE;
             const rh = generatedRect.h * GRID_SIZE;
             
             ctx.fillStyle = generatedRect.color;
             ctx.fillRect(cx - rw/2, cy - rh/2, rw, rh);
             ctx.strokeStyle = "#fff";
             ctx.lineWidth = 2;
             ctx.strokeRect(cx - rw/2, cy - rh/2, rw, rh);
        }

        drawButton(LAYOUT.rotateX, LAYOUT.rotateY, LAYOUT.rotateW, LAYOUT.rotateH, ICONS.rotate + " ã‹ã„ã¦ã‚“", "#558b2f");

        // Trash
        ctx.save();
        ctx.translate(LAYOUT.trashX, LAYOUT.trashY);
        ctx.fillStyle = "rgba(188, 170, 164, 0.1)"; 
        ctx.roundRect(0, 0, LAYOUT.trashW, LAYOUT.trashH, 10).fill();
        ctx.strokeStyle = "#8d6e63";
        ctx.lineWidth = 2;
        ctx.roundRect(0, 0, LAYOUT.trashW, LAYOUT.trashH, 10).stroke();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#bcaaa4";
        ctx.font = "bold 28px 'M PLUS Rounded 1c', sans-serif";
        ctx.fillText(ICONS.trash + " ã™ã¦ã‚‹", LAYOUT.trashW / 2, LAYOUT.trashH / 2);
        ctx.restore();

        // Deck
        drawCardBack(LAYOUT.deckX, LAYOUT.deckY + 20);
        ctx.font = "18px 'M PLUS Rounded 1c'";
        ctx.fillStyle = "#efebe9";
        ctx.textAlign = "center";
        ctx.textBaseline = "alphabetic";
        ctx.fillText(`ã‚ã¨${currentDeck}ã¾ã„`, LAYOUT.deckX + LAYOUT.cardW/2, LAYOUT.deckY + 145);

        // Hand
        hand.forEach((val, i) => {
            if (isDragging?.type === 'card' && isDragging.index === i) return;
            drawCardRect(LAYOUT.handStartX + i * LAYOUT.cardGap, LAYOUT.handY + 20, val);
        });

        // Placing State
        if (placingState) {
            const { rect, gx, gy, pixelX, pixelY } = placingState;
            const rw = rect.w * GRID_SIZE;
            const rh = rect.h * GRID_SIZE;
            
            ctx.save();
            ctx.translate(LAYOUT.mapX, LAYOUT.mapY);
            ctx.fillStyle = rect.color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(gx*GRID_SIZE, gy*GRID_SIZE, rw, rh);
            ctx.strokeStyle = "#ffeb3b";
            ctx.lineWidth = 3;
            ctx.strokeRect(gx*GRID_SIZE, gy*GRID_SIZE, rw, rh);
            ctx.globalAlpha = 1.0;
            ctx.restore();

            drawButton((pixelX + 60) - 50, pixelY - 20, 100, 40, "ã¯ã„", "#558b2f");
            drawButton((pixelX - 60) - 50, pixelY - 20, 100, 40, "ã„ã„ãˆ", "#c62828");
            
            ctx.fillStyle = "#fff";
            ctx.font = "bold 20px 'M PLUS Rounded 1c'";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText("ã“ã“ã§ã„ã„ï¼Ÿ", pixelX, pixelY - rh/2 - 10);
            ctx.fillText("ã“ã“ã§ã„ã„ï¼Ÿ", pixelX, pixelY - rh/2 - 10);
        }

        // Dragging
        if (isDragging) {
            if (isDragging.type === 'card') {
                drawCardRect(dragPos.x - LAYOUT.cardW/2, dragPos.y - LAYOUT.cardH/2, isDragging.val);
            } else if (isDragging.type === 'rect') {
                const r = isDragging.obj;
                const rw = r.w * GRID_SIZE;
                const rh = r.h * GRID_SIZE;
                ctx.fillStyle = r.color;
                ctx.globalAlpha = 0.5; 
                ctx.fillRect(dragPos.x - rw/2, dragPos.y - rh/2, rw, rh);
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.strokeRect(dragPos.x - rw/2, dragPos.y - rh/2, rw, rh);
                ctx.globalAlpha = 1.0;
            } else if (isDragging.type === 'item') {
                 ctx.font = "40px serif";
                 ctx.fillStyle = "#fff";
                 ctx.fillText(ICONS[isDragging.itemType], dragPos.x, dragPos.y);
            }
        }

        for(let i=floatingTexts.length-1; i>=0; i--) {
            const ft = floatingTexts[i];
            ctx.fillStyle = ft.color;
            ctx.shadowColor = "#000";
            ctx.shadowBlur = 4;
            ctx.font = "bold 26px 'M PLUS Rounded 1c'";
            ctx.fillText(ft.text, ft.x, ft.y);
            ctx.shadowBlur = 0;
            ft.y -= 1;
            ft.life--;
            if(ft.life <= 0) floatingTexts.splice(i, 1);
        }

        requestAnimationFrame(gameLoop);
    }

    function drawCardRect(x, y, val) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        const w = LAYOUT.cardW;
        const h = LAYOUT.cardH;
        
        ctx.fillStyle = "#efebe9";
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.strokeStyle = "#4e342e";
        ctx.lineWidth = 2;
        ctx.roundRect(x, y, w, h, 8).stroke();
        
        ctx.strokeStyle = "#bcaaa4";
        ctx.lineWidth = 1;
        ctx.strokeRect(x+5, y+5, w-10, h-10);

        ctx.fillStyle = "#3e2723";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        if (val === 'JOKER') {
            // Joker Design
            ctx.font = "50px 'M PLUS Rounded 1c'";
            ctx.fillText("ğŸƒ", x + w/2, y + h/2 + 2);
        } else {
            ctx.font = "46px 'M PLUS Rounded 1c'";
            ctx.fillText(val, x + w/2, y + h/2 + 2);
        }
        ctx.restore();
    }

    function drawCardBack(x, y) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        const w = LAYOUT.cardW;
        const h = LAYOUT.cardH;
        ctx.fillStyle = "#5d4037";
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.strokeStyle = "#efebe9";
        ctx.lineWidth = 2;
        ctx.stroke(); 
        
        ctx.fillStyle = "#8d6e63";
        ctx.beginPath();
        ctx.arc(x+w/2, y+h/2, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }

    function drawItemIcon(x, y, w, h, type, count) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "rgba(78, 52, 46, 0.9)";
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.strokeStyle = "#8d6e63";
        ctx.roundRect(x, y, w, h, 8).stroke();
        
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";

        // ã‚¢ã‚¤ã‚³ãƒ³ (å·¦å¯„ã›æ°—å‘³ã«é…ç½®)
        ctx.font = "30px serif";
        ctx.textAlign = "center"; 
        ctx.fillText(ICONS[type], x + 30, y + h/2 + 2); 

        // æ•°å€¤ (å·¦æƒãˆã§é…ç½®ã—ã€æ¡æ•°ãŒå¢—ãˆã¦ã‚‚å³ã®ãƒœã‚¿ãƒ³ã¨é‡ãªã‚‰ãªã„ã‚ˆã†ã«)
        ctx.font = "20px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(`Ã—${count}`, x + 55, y + h/2 + 2);
        
        ctx.restore();
    }

    function drawButton(x, y, w, h, text, color) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = color;
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowOffsetY = 4;
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.shadowColor = "transparent";
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = "#fff";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, x + w/2, y + h/2);
        ctx.restore();
    }

    initPlayerSystem();

</script>
</body>
</html>
