<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>„Åã„Åë„Åñ„Çì„ÉÄ„É≥„Ç∏„Éß„É≥ÔºöÂú∞Â∫ï„Åã„Çâ„ÅÆËÑ±Âá∫</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #2b1d0e;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            overflow: hidden;
        }

        #game-container {
            width: 1280px;
            height: 720px;
            background-color: #4e342e;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            background-image: url('images/title.png'); 
            background-size: cover;
            background-position: center;
        }

        canvas {
            display: block;
            background-color: #3e2723;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        canvas.hidden {
            display: none;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 100;
        }
        
        #title-screen {
            background: rgba(43, 29, 14, 0.4);
            justify-content: flex-start;
            padding-top: 60px;
            box-sizing: border-box;
        }
        
        #title-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 10px;
            align-items: center;
        }

        #difficulty-screen {
            background-image: url('images/title.png');
            background-size: cover;
            background-position: center;
            background-color: rgba(43, 29, 14, 0.6);
            background-blend-mode: multiply;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 80px;
            color: #ffca28;
            margin-bottom: 0px;
            text-shadow: 4px 4px 0 #000, -2px -2px 0 #000;
            text-align: center;
            width: 100%;
            font-weight: 800;
            margin-top: 0;
            line-height: 1.1;
        }

        .subtitle {
            font-size: 40px; 
            color: #d7ccc8;
            display: block;
            margin-top: -10px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
        }

        h2 {
            font-size: 40px;
            color: #efebe9;
            margin-bottom: 20px;
            text-shadow: 2px 2px 0 #000;
        }

        #current-player-display {
            font-size: 24px;
            color: #ffffff;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            background-color: rgba(0,0,0,0.6);
            padding: 5px 20px;
            border-radius: 10px;
            border: 2px solid #ffca28;
            margin-bottom: 5px;
            min-width: 320px; 
            max-width: 320px;
            text-align: center;
            box-sizing: border-box;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn {
            background-color: #5d4037;
            color: #efebe9;
            border: 2px solid #8d6e63;
            padding: 10px 0;
            font-size: 24px;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-weight: 800;
            box-shadow: 0 6px 0 #3e2723;
            transition: transform 0.1s, box-shadow 0.1s;
            width: 320px;
            text-align: center;
            box-sizing: border-box;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #3e2723;
        }

        .btn-success { background-color: #558b2f; border-color: #7cb342; box-shadow: 0 6px 0 #33691e; }
        .btn-success:active { box-shadow: 0 2px 0 #33691e; }

        .btn-danger { background-color: #c62828; border-color: #ef5350; box-shadow: 0 6px 0 #b71c1c; }
        .btn-danger:active { box-shadow: 0 2px 0 #b71c1c; }
        
        .btn-warning { background-color: #ef6c00; border-color: #ff9800; box-shadow: 0 6px 0 #e65100; color: #fff; }
        .btn-warning:active { box-shadow: 0 2px 0 #e65100; }
        
        .btn-google { background-color: #d32f2f; box-shadow: 0 6px 0 #b71c1c; }
        .btn-google:active { box-shadow: 0 2px 0 #b71c1c; }

        .btn-index { background-color: #78909c; box-shadow: 0 6px 0 #546e7a; }
        .btn-index:active { box-shadow: 0 2px 0 #546e7a; }

        .btn-small {
            padding: 5px 15px;
            font-size: 18px;
            width: auto;
            min-width: 80px;
            margin: 2px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }
        .btn-small:active {
            box-shadow: 0 1px 0 rgba(0,0,0,0.5);
        }

        #player-modal, #ranking-modal, #rule-modal {
            background: #4e342e; 
            border: 4px solid #ffca28;
            color: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center;
            z-index: 200;
        }
        
        #player-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
        }
        
        #rule-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 900px;
            max-height: 80%;
            overflow-y: auto;
            text-align: left;
        }
        #rule-modal h3 {
            text-align: center;
            color: #ffca28;
            margin-top: 0;
            font-size: 32px;
        }
        #rule-modal p, #rule-modal li {
            font-size: 20px;
            line-height: 1.6;
        }

        #ranking-modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            background-image: url('images/title.png');
            background-size: cover;
            background-position: center;
            background-color: rgba(43, 29, 14, 0.7);
            background-blend-mode: multiply;
        }

        #result-modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        #result-content {
            background: rgba(62, 39, 35, 0.95);
            border: 6px solid #ffca28;
            border-radius: 30px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 202, 40, 0.5);
            min-width: 500px;
        }

        /* Joker Selection Modal */
        #joker-selector {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #4e342e;
            border: 4px solid #ba68c8; /* Purple for Joker */
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            text-align: center;
            z-index: 400;
            width: 500px;
        }
        #joker-selector h3 {
            color: #efebe9;
            margin-top: 0;
            font-size: 28px;
        }
        .num-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 20px;
        }
        .num-btn {
            background: #fff;
            border: 2px solid #8d6e63;
            border-radius: 8px;
            font-size: 30px;
            font-weight: bold;
            color: #3e2723;
            cursor: pointer;
            padding: 15px 0;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            box-shadow: 0 4px 0 #a1887f;
        }
        .num-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #a1887f;
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #5d4037;
            padding: 10px 20px;
            margin: 5px 0;
            border-radius: 10px;
            border: 2px solid #8d6e63;
            font-size: 24px;
            color: #efebe9;
        }
        .player-row.selected {
            border-color: #ffca28;
            background-color: #4e342e;
            box-shadow: 0 0 10px #ffca28;
        }
        
        .input-group {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        input[type="text"] {
            font-size: 24px;
            padding: 5px 10px;
            border-radius: 10px;
            border: 2px solid #8d6e63;
            background: #efebe9;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            text-align: center;
            width: 250px;
            color: #3e2723;
        }

        #message-area {
            height: 30px;
            color: #ffab91;
            font-weight: bold;
            font-size: 20px;
            margin: 10px;
        }

        .ranking-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .ranking-tabs {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 10px;
        }
        .tab-btn {
            padding: 10px 20px;
            border-radius: 10px 10px 0 0;
            background: #8d6e63;
            border: none;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
            color: #efebe9;
        }
        .tab-btn.active {
            background: #ffca28;
            color: #3e2723;
        }
        .diff-tabs {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-bottom: 10px;
        }
        .diff-btn {
            padding: 5px 15px;
            border: 2px solid #ffca28;
            background: #4e342e;
            border-radius: 20px;
            cursor: pointer;
            color: #ffca28;
            font-weight: bold;
        }
        .diff-btn.active {
            background: #ffca28;
            color: #3e2723;
        }
        
        #ranking-list {
            flex: 1;
            overflow-y: auto;
            background: rgba(93, 64, 55, 0.9);
            border-radius: 10px;
            padding: 10px;
            border: 2px solid #8d6e63;
        }
        .rank-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            border-bottom: 1px solid #795548;
            font-size: 22px;
            color: #efebe9;
        }
        .rank-row:nth-child(1) { color: #ffca28; font-weight: bold; }
        .rank-row:nth-child(2) { color: #d7ccc8; font-weight: bold; }
        .rank-row:nth-child(3) { color: #ffab91; font-weight: bold; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="1280" height="720" class="hidden"></canvas>

    <div id="title-screen" class="screen">
        <h1>„Åã„Åë„Åñ„Çì„ÉÄ„É≥„Ç∏„Éß„É≥</h1>
        <span class="subtitle">ÔΩûÂú∞Â∫ï„Åã„Çâ„ÅÆËÑ±Âá∫ÔΩû</span>
        
        <div id="title-menu">
            <div id="current-player-display">„Éó„É¨„Éº„É§„Éº„Çí„Åà„Çâ„Çì„Åß„Å≠</div>
            <button class="btn btn-success" id="start-btn-trigger">„ÅØ„Åò„ÇÅ„Çã</button>
            <button class="btn" onclick="openPlayerModal()">„Éó„É¨„Éº„É§„Éº„Åõ„Çì„Åü„Åè</button>
            <button class="btn btn-google" onclick="alert('Google„É≠„Ç∞„Ç§„É≥Ê©üËÉΩ„ÅØË®≠ÂÆö„ÅåÂøÖË¶Å„Åß„Åô')">Google„Åß„É≠„Ç∞„Ç§„É≥</button>
            <button class="btn btn-warning" onclick="showRanking()">„É©„É≥„Ç≠„É≥„Ç∞</button>
            <button class="btn btn-index" onclick="location.href='index.html'">INDEX„Å∏</button>
        </div>
    </div>

    <div id="player-modal" class="hidden">
        <h3>„Éó„É¨„Éº„É§„Éº„Çí „Åà„Çâ„Çì„Åß„Å≠Ôºà5„Å´„Çì „Åæ„ÅßÔºâ</h3>
        <div id="player-list-container"></div>
        
        <div class="input-group">
            <input type="text" id="new-player-name" maxlength="8" placeholder="Êñ∞„Åó„ÅÑ„Åä„Å™„Åæ„Åà">
            <button class="btn btn-small btn-success" onclick="createPlayer()">„Å®„ÅÜ„Çç„Åè</button>
        </div>
        <div id="message-area"></div>
        <button class="btn btn-small btn-danger" style="margin-top:20px;" onclick="closePlayerModal()">„Å®„Åò„Çã</button>
    </div>

    <div id="rule-modal" class="hidden">
        <h3>„ÅÇ„Åù„Å≥„Åã„Åü</h3>
        <ul>
            <li><strong>„Ç´„Éº„Éâ„Åß„ÄåÈù¢Á©ç„Äç„Çí‰Ωú„Çç„ÅÜÔºÅ</strong><br>
                ÊâãÊú≠„ÅÆ„Ç´„Éº„Éâ„Çí2ÊûöÈÅ∏„Çì„Åß„Äå„Åã„ÅëÁÆó„Äç„Çí„Åó„Åæ„Åô„ÄÇ<br>
                „Åß„Åç„ÅüÂ∫É„ÅïÔºàÈù¢Á©çÔºâ„ÅÆÂàÜ„Å†„Åë„ÄÅÂú∞Èù¢„Å´„Çø„Ç§„É´„ÇíÁΩÆ„Åë„Åæ„Åô„ÄÇ
            </li>
            <li><strong>„Ç∏„Éß„Éº„Ç´„Éº(üÉè)„ÅØÂ•Ω„Åç„Å™Êï∞Â≠ó„Å´„Å™„Çå„Åæ„ÅôÔºÅ</strong><br>
                „Ç®„É™„Ç¢„Å´ÁΩÆ„Åè„Å®„Åç„Å´1ÔΩû10„ÅÆÂ•Ω„Åç„Å™Êï∞Â≠ó„ÇíÈÅ∏„Åπ„Åæ„Åô„ÄÇ
            </li>
            <li><strong>„Ç´„ÇÆ„ÇíÈõÜ„ÇÅ„Å¶ËÑ±Âá∫„Å†ÔºÅ</strong><br>
                „Çπ„ÉÜ„Éº„Ç∏„Å´„ÅÇ„Çã„ÄåüóùÔ∏è „Ç´„ÇÆ„Äç„ÇíÈõÜ„ÇÅ„Çã„Å®„ÄÅÊ¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å´ÈÄ≤„ÇÅ„Åæ„Åô„ÄÇ<br>
                Ôºà„Çπ„ÉÜ„Éº„Ç∏1ÔΩû5„ÅØ5ÂÄã„ÄÅ6‰ª•Èôç„ÅØ„Çπ„ÉÜ„Éº„Ç∏Êï∞„Å®Âêå„ÅòÊï∞„ÅåÂøÖË¶Å„Åß„ÅôÔºâ
            </li>
            <li><strong>„Ç¢„Ç§„ÉÜ„É†„Çí‰Ωø„Åä„ÅÜ</strong><br>
                ‚öîÔ∏è Ââ£Ôºö„É¢„É≥„Çπ„Çø„Éº„ÇíÂÄí„Åõ„Åæ„ÅôÔºà+200ÁÇπÔºâ<br>
                ‚õèÔ∏è „Å§„Çã„ÅØ„ÅóÔºöÂ≤©„ÇíÂ£ä„Åõ„Åæ„ÅôÔºà+100ÁÇπÔºâ<br>
                ü™Ñ È≠îÊ≥ï„ÅÆÊùñÔºöÊïµ„Å®Â≤©„Çí1/2„ÅÆÁ¢∫Áéá„ÅßÊ∂àÊªÖ„Åï„Åõ„Åæ„Åô<br>
                üÉè „Ç´„Éº„Éâ„Ç¢„Ç§„ÉÜ„É†ÔºöÂ±±Êú≠„Åå1ÊûöÂ¢ó„Åà„Åæ„Åô<br>
                üí∞ „ÅäÈáëÔºöÊãæ„ÅÜ„Å®„Çπ„Ç≥„Ç¢„ÅåÂ¢ó„Åà„Åæ„ÅôÔºà+300ÁÇπÔºâ
            </li>
            <li><strong>„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Å´Ê≥®ÊÑè</strong><br>
                ÊâãÊú≠„Å®Â±±Êú≠„ÅÆ„Ç´„Éº„Éâ„Åå„Å™„Åè„Å™„Çã„Å®„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Åß„Åô„ÄÇ<br>
                „Ç´„Éº„Éâ„ÅØÂ§ßÂàá„Å´‰Ωø„Åä„ÅÜÔºÅ
            </li>
        </ul>
        <div style="text-align:center; margin-top:20px;">
            <button class="btn btn-small btn-danger" onclick="closeRules()">„Å®„Åò„Çã</button>
        </div>
    </div>

    <div id="difficulty-screen" class="screen hidden">
        <h2>„Å©„ÅÆ„É¢„Éº„Éâ„Åß„ÅØ„Åò„ÇÅ„ÇãÔºü</h2>
        <div style="display:flex; flex-direction:column; gap:10px; align-items:center;">
            <button class="btn btn-success" onclick="startGame('EASY')">„Åã„Çì„Åü„Çì</button>
            <button class="btn" onclick="startGame('NORMAL')">„Åµ„Å§„ÅÜ</button>
            <button class="btn btn-danger" onclick="startGame('HARD')">„ÇÄ„Åö„Åã„Åó„ÅÑ</button>
        </div>
        <button class="btn btn-index" style="margin-top: 50px;" onclick="backToTitle()">„ÇÇ„Å©„Çã</button>
    </div>

    <div id="joker-selector" class="hidden">
        <h3>„Åô„Åç„Å™„Åô„ÅÜ„Åò„Çí „Åà„Çâ„Çì„Åß„Å≠</h3>
        <div class="num-grid">
            <button class="num-btn" onclick="selectJokerValue(1)">1</button>
            <button class="num-btn" onclick="selectJokerValue(2)">2</button>
            <button class="num-btn" onclick="selectJokerValue(3)">3</button>
            <button class="num-btn" onclick="selectJokerValue(4)">4</button>
            <button class="num-btn" onclick="selectJokerValue(5)">5</button>
            <button class="num-btn" onclick="selectJokerValue(6)">6</button>
            <button class="num-btn" onclick="selectJokerValue(7)">7</button>
            <button class="num-btn" onclick="selectJokerValue(8)">8</button>
            <button class="num-btn" onclick="selectJokerValue(9)">9</button>
            <button class="num-btn" onclick="selectJokerValue(10)">10</button>
        </div>
    </div>

    <div id="result-modal" class="hidden">
        <div id="result-content">
            <h2 id="result-title" style="font-size:60px; color:#ffca28; margin:0 0 20px 0;">„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ</h2>
            <h1 id="final-score" style="color:#fff; font-size:50px; margin:0 0 10px 0;">SCORE: 0</h1>
            <div id="result-difficulty" style="font-size:24px; margin-bottom:30px; color:#d7ccc8;"></div>
            <button class="btn" onclick="backToTitle()">„Çø„Ç§„Éà„É´„Å∏</button>
        </div>
    </div>

    <div id="ranking-modal" class="hidden">
        <div class="ranking-header">
            <h2>„É©„É≥„Ç≠„É≥„Ç∞</h2>
            <button class="btn btn-small btn-danger" onclick="closeRanking()">„Å®„Åò„Çã</button>
        </div>
        <div class="ranking-tabs">
            <button class="tab-btn active" id="tab-local" onclick="switchRankTab('local')">„Åì„ÅÆ„Éë„ÇΩ„Ç≥„É≥</button>
            <button class="tab-btn" id="tab-world" onclick="switchRankTab('world')">„Åø„Çì„Å™„ÅÆË®òÈå≤</button>
        </div>
        <div class="diff-tabs">
            <button class="diff-btn active" id="rank-diff-easy" onclick="switchRankDiff('EASY')">„Åã„Çì„Åü„Çì</button>
            <button class="diff-btn" id="rank-diff-normal" onclick="switchRankDiff('NORMAL')">„Åµ„Å§„ÅÜ</button>
            <button class="diff-btn" id="rank-diff-hard" onclick="switchRankDiff('HARD')">„ÇÄ„Åö„Åã„Åó„ÅÑ</button>
        </div>
        <div id="ranking-list">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getFirestore, collection, addDoc, query, where, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
        authDomain: "math-braves.firebaseapp.com",
        projectId: "math-braves",
        storageBucket: "math-braves.firebasestorage.app",
        messagingSenderId: "217117619290",
        appId: "1:217117619290:web:d227feb603970d3948d463"
    };

    try {
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        signInAnonymously(auth).catch((e) => {
            console.warn("Firebase Auth Error: „É≠„Ç∞„Ç§„É≥„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü", e.code);
        });

        window.dbInstance = db;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;
        window.where = where;
        window.orderBy = orderBy;
        window.limit = limit;
        window.getDocs = getDocs;
    } catch (err) {
        console.error("Firebase Init Error:", err);
    }
</script>

<script>
    // --- NG Words & Constants ---
    const NG_WORDS_HIRAGANA = [
        '„Åó„Å≠', '„Åó„Å¨', '„Åó„Å´', '„Åì„Çç„Åô', '„Åì„Çç„Åõ', '„Åï„Å§„Åå„ÅÑ', '„Åè„Åü„Å∞„Çå', '„Åò„Åï„Å§', '„Åé„Åï„Å§', '„Å§„Çã„Åô', '„Çå„Çì„Åü„Çì', '„Åó„Å´„Åü„ÅÑ',
        '„Å¶„Çç', '„Å¶„Çç„Çä„Åô„Å®', '„Å∞„Åè„ÅØ', '„Å∞„Åè„Å†„Çì', '„Åª„ÅÜ„Åã', '„ÅØ„Çì„Åñ„ÅÑ', '„Åî„ÅÜ„Å®„ÅÜ', '„ÇÜ„ÅÜ„Åã„ÅÑ', '„Åã„Çì„Åç„Çì', '„Åä„Åù„ÅÜ',
        '„ÇÑ„Åè„Åñ', '„Åº„ÅÜ„Çä„Çá„Åè', '„ÅØ„Çì„Åê„Çå', '„Å°„Çì„Å¥„Çâ', '„Åæ„Åµ„ÅÉ„ÅÇ', '„Åü„ÅÑ„Åæ', '„Åæ„ÇÑ„Åè', '„Åã„Åè„Åõ„ÅÑ„Åñ„ÅÑ', '„Åó„ÇÉ„Å∂', '„Å©„Çâ„Å£„Åê',
        '„Åì„Åã„ÅÑ„Çì', '„Å∏„Çç„ÅÑ„Çì', '„Åà„Åè„Åô„Åü„Åó„Éº', '„Å†„Å£„ÅΩ„ÅÜ', '„Åç„ÇÅ„Åõ„Åè', '„ÅÑ„Åò„ÇÅ', '„Åé„ÇÉ„Åè„Åü„ÅÑ', '„Å∞„Åã', '„ÅÇ„Åª', '„Åæ„Å¨„Åë',
        '„Åç„Å°„Åå„ÅÑ', '„ÅçÈÅï„ÅÑ', '„ÅÜ„Åñ„ÅÑ', '„ÅÜ„Åñ', '„Åç„ÇÇ„ÅÑ', '„Åç„ÇÇ', '„Åç„Åó„Çá„ÅÑ', '„Åç„Åà„Çç', '„Åè„Åö', '„Åî„Åø', '„Åî„Åø„ÇÄ„Åó', '„Åã„Åô',
        '„Åñ„Åì', '„Åú„Å§', '„Å∂„Åô', '„Åß„Å∂', '„ÅØ„Åí', '„Å°„Å≥', '„Åß„Å£„Å±', '„ÅÑ„Å™„Åã„ÇÇ„ÅÆ', '„ÅÜ„Åò', '„ÅØ„ÅÑ„Åº„Åè', '„Åæ„Åë„ÅÑ„Å¨', '„Åä„Å§„ÇÄ',
        '„ÅÆ„ÅÜ„Åü„Çä„Çì', '„Å¶„ÅÑ„ÅÆ„ÅÜ', '„Å°„Åó„Çá„ÅÜ', '„Åó„Çá„ÅÜ„Åå„ÅÑ', '„Åå„ÅÑ„Åò', '„Åã„Åü„Çè', '„Å≥„Å£„Åì', '„ÇÅ„Åè„Çâ', '„Å§„Çì„Åº', '„Åä„Åó', '„Å©„Åò„Çì',
        '„Åà„Åü', '„Å≤„Å´„Çì', '„Åü„Å≤', '„Åü„Å≤„Å≠', '„ÅÜ„Åõ„Çç', '„Å†„Åæ„Çå', '„Å°„Çì„Å°„Çì', '„Å°„Çì„Åì', '„Å°„Çì„ÅΩ', '„Å°„Çì„Åã', '„Åæ„Çâ', '„Åï„Åä',
        '„Åæ„Çì„Åì', '„Åæ„Çì„Åó„ÇÖ„ÅÜ', '„Åæ„Çì„Åí', '„Çè„Çå„ÇÅ', '„Åä„Åæ„Åü', '„Åè„Çä', '„Åè„Çä„Å®„Çä„Åô', '„ÅÑ„Çì„Åó„Çì', '„ÅÑ„Çì„Åã„Åè', '„Å≥„Çâ„Å≥„Çâ',
        '„Åì„ÅÜ„Åå„Çì', '„Åü„Åæ„Åç„Çì', '„Åç„Çì„Åü„Åæ', '„Åµ„Åê„Çä', '„Åä„Å£„Å±„ÅÑ', '„Å°„Å°', '„Å´„ÇÖ„ÅÜ„Çä„Çì', '„Å´„ÇÖ„ÅÜ„Å®„ÅÜ', '„Åç„Çá„Å´„ÇÖ„ÅÜ', '„Å≤„Çì„Å´„ÇÖ„ÅÜ',
        '„Åë„Å§', '„ÅÇ„Å™„Çã', '„Åì„ÅÜ„ÇÇ„Çì', '„Åë„Å§„ÅÆ„ÅÇ„Å™', '„Åà„Çç', '„Åà„Å£„Å°', '„Åô„Åë„Åπ', '„Å∏„Çì„Åü„ÅÑ', '„ÇÄ„Å£„Å§„Çä', '„Åó„Åì', '„Åõ„Å£„Åè„Åô',
        '„Åõ„ÅÑ„Åì„ÅÜ', '„Åæ„Åê„Çè„ÅÑ', '„Åù„ÅÜ„Å´„ÇÖ„ÅÜ', '„ÅØ„ÇÅ„Çã', '„Åä„Å™„Å´„Éº', '„Åò„ÅÑ', '„Åó„Åì„Åó„Åì', '„Åµ„Åá„Çâ', '„Å±„ÅÑ„Åö„Çä', '„Åè„Çì„Å´', '„ÅÑ„Çâ„Åæ',
        '„Åó„Å£„Åó„Çì', '„Å™„Åã„Å†„Åó', '„Åî„Å£„Åè„Çì', '„Å∂„Å£„Åã„Åë', '„Åó„Åä„Åµ„Åç', '„Åú„Å£„Å°„Çá„ÅÜ', '„ÅÑ„Åè', '„ÅÑ„Åã„Åõ„Çç', '„ÅÇ„Åà„Åé', '„Å©„ÅÜ„Å¶„ÅÑ', '„Åó„Çá„Åò„Çá',
        '„ÇÑ„Çä„Åæ„Çì', '„ÇÑ„Çä„Å°„Çì', '„Å≥„Å£„Å°', '„Åõ„Åµ„Çå', '„Å±„Åì', '„Å±„Åì„Å±„Åì', '„Çè„ÅÑ„Åõ„Å§', '„Çç„Çä', '„Åó„Çá„Åü', '„Å∫„Å©', '„Åç„Çì„Åó„Çì', '„Åò„ÇÖ„ÅÜ„Åã„Çì',
        '„Çä„Çá„ÅÜ„Åò„Çá„Åè', '„Çâ„Çì„Åì„ÅÜ', '„Åô„Åã„Çì„Å®', '„ÅÆ„Éº„Å±„Çì', '„Å±„Çì„Å°„Çâ', '„Çå„ÅÑ„Å∑', '„Åî„ÅÜ„Åã„Çì', '„Å°„Åã„Çì', '„Å®„ÅÜ„Åï„Å§', '„ÅÆ„Åû„Åç', '„Çç„Åó„ÇÖ„Å§',
        '„Åµ„ÅÜ„Åû„Åè', '„Åù„Éº„Å∑', '„Å∏„Çã„Åô', '„Åß„Çä„Å∏„Çã', '„Å¥„Çì„Åï„Çç', '„ÅÑ„ÇÅ„Åè„Çâ', '„ÅÇ„Å†„Çã„Å®', '„Åà„Éº„Å∂„ÅÑ', '„Åà„Å∂„ÅÑ', '„ÅΩ„Çã„ÅÆ', '„ÅÜ„Çâ„Å≥„Åß„Åä',
        '„ÇÄ„Åó„ÇÖ„ÅÜ„Åõ„ÅÑ', '„Åà„Çì„Åì„ÅÜ', '„Åà„Çì„Åò„Çá', '„ÅÜ„Çä', '„Åã„ÅÑ„Åó„ÇÖ„Çì', '„Å∞„ÅÑ„Åó„ÇÖ„Çì', '„Å±„Å±„Åã„Å§', '„Åæ„Åæ„Åã„Å§', '„ÅÜ„Çä„Åõ„Çì', '„ÅÜ„Çì„Åì', '„ÅÜ„Çì„Å°',
        '„Åè„Åù', '„Åí„Çä', '„Åπ„Çì', '„Åµ„Çì', '„Åó„Å£„Åì', '„Åó„Çá„Çì„Åπ„Çì', '„Å´„Çá„ÅÜ', '„Åª„ÅÜ„Å´„Çá„ÅÜ', '„Å∏', '„Åä„Å™„Çâ', '„Åí„Çç', '„Åü„Çì', '„ÅÜ„Çì„Åà„ÅÑ',
        '„Åì„ÅÜ„Åó„Åç', '„Åô„Åü„Å£„Åµ', '„Åã„Çì„Çä', '„Å±„Å®„Çç„Éº„Çã', '„Åò„Åà„ÇÄ', '„Åí„Éº„ÇÄ„Åæ„Åô„Åü„Éº', '„Åæ„Åô„Åü„Éº', '„ÅÇ„Å©„Åø„Çì', '„Åó„Åô„Å¶„ÇÄ', '„Åï„Éº„Å∞„Éº', '„ÅÇ„Åã„Å∞„Çì',
        '„Å∞„Çì', '„Å°„Éº„Å®', '„Å°„Éº„Åü„Éº', '„Å∞„Åê', '„Çâ„ÅÑ„Çì', '„Åã„Åã„Åä', '„Åô„Åã„ÅÑ„Å∑', '„ÅÑ„Çì„Åô„Åü', '„Å§„ÅÑ„Å£„Åü„Éº', '„Åß„ÅÉ„Åô„Åì', '„Åß„Çì„Çè', '„Å∞„Çì„Åî„ÅÜ',
        '„Åë„ÅÑ„Åü„ÅÑ', '„ÅÇ„Å©„Çå„Åô', '„ÇÅ„ÅÇ„Å©', '„Åò„ÇÖ„ÅÜ„Åó„Çá', '„ÅÇ„Åä', '„ÅÇ„ÅÑ„Åü„ÅÑ', '„Åæ„Å°„ÅÇ„Çè„Åõ', '„Åª„Å¶„Çã', '„Çâ„Å∂„Åª', '„Åä„Åµ„Åã„ÅÑ', '„Å±„Åô„Çè„Éº„Å©',
        '„Å±„Åô', '„ÅÇ„Åã„ÅÜ„Çì„Å®', '„Åì„Åò„Çì„Åò„Çá„ÅÜ„Åª„ÅÜ'
    ];

    // --- Global Game State ---
    const CANVAS_WIDTH = 1280;
    const CANVAS_HEIGHT = 720;
    
    // Layout Constants
    const GRID_SIZE = 48; 
    const MAP_ROWS = 10;
    const MAP_COLS = 10;

    const LAYOUT = {
        sidebarW: 220,
        mapX: 250, 
        mapY: 40,
        mapW: 480, // 10 * 48
        itemY: 540,    
        calcX: 780,
        calcY: 40,     
        calcW: 420,
        calcH: 380, 
        deckX: 740,      
        deckY: 540,
        handStartX: 840, 
        handY: 540,
        cardW: 76,       
        cardH: 106,      
        cardGap: 86,
        rotateX: 780,
        rotateY: 440,
        rotateW: 200,
        rotateH: 80,
        trashX: 1000,
        trashY: 440, 
        trashW: 200,
        trashH: 80 
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- Patterns Generation (Deleted as requested) ---
    // Background patterns for monster and rock have been removed.
    
    let currentPlayer = null; 
    let gameState = "TITLE";
    let level = 1;
    let score = 0;
    let difficulty = "NORMAL"; 
    let currentDeck = 0; 
    let hand = []; // contains numbers or 'JOKER'
    let items = { sword: 0, pickaxe: 0, wand: 0, keys: 0 };
    let mapData = []; 
    let mapObjects = []; 
    
    let term1 = null; 
    let term2 = null; 
    let generatedRect = null; 
    let isDragging = null; 
    let dragPos = {x:0, y:0};
    let tapStartPos = {x:0, y:0}; 
    let floatingTexts = []; 
    
    // ÈÖçÁΩÆÁ¢∫Ë™çÁî®
    let placingState = null; 

    // ‰øùÁïô‰∏≠„ÅÆ„Ç∏„Éß„Éº„Ç´„ÉºÂá¶ÁêÜÁî®
    let pendingJokerSlot = null; // 'term1' or 'term2'

    // ICONS
    const ICONS = {
        sword: '‚öîÔ∏è', pickaxe: '‚õèÔ∏è', wand: 'ü™Ñ', key: 'üóùÔ∏è', 
        monster: 'üëæ', rock: 'ü™®', money: 'üí∞', 
        trash: 'üóëÔ∏è', rotate: 'üîÑ'
        // 'card' will be drawn manually
    };

    // --- Scaling ---
    function resize() {
        const container = document.getElementById('game-container');
        const scale = Math.min(window.innerWidth / CANVAS_WIDTH, window.innerHeight / CANVAS_HEIGHT);
        container.style.transform = `scale(${scale})`;
        const scaledWidth = CANVAS_WIDTH * scale;
        const scaledHeight = CANVAS_HEIGHT * scale;
        const left = (window.innerWidth - scaledWidth) / 2;
        const top = (window.innerHeight - scaledHeight) / 2;
        container.style.left = `${left}px`;
        container.style.top = `${top}px`;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Player Management ---
    let players = [];
    const MAX_PLAYERS = 5;

    function initPlayerSystem() {
        const stored = localStorage.getItem('kakezan_players');
        if (stored) players = JSON.parse(stored);
        else players = [];
        updatePlayerDisplay();
    }
    
    function updatePlayerDisplay() {
        const display = document.getElementById('current-player-display');
        if (currentPlayer) {
            display.textContent = `${currentPlayer.name} „Åï„Çì`;
            display.style.color = "#ffca28";
        } else {
            display.textContent = "„Éó„É¨„Éº„É§„Éº„Çí„Åà„Çâ„Çì„Åß„Å≠";
            display.style.color = "#ffffff";
        }
    }

    function renderPlayerList() {
        const container = document.getElementById('player-list-container');
        container.innerHTML = "";
        players.forEach((p, index) => {
            const div = document.createElement('div');
            div.className = `player-row ${currentPlayer && currentPlayer.id === p.id ? 'selected' : ''}`;
            div.innerHTML = `
                <span>${p.name}</span>
                <div>
                    <button class="btn btn-small btn-success" onclick="selectPlayer(${index})">„Åà„Çâ„Å∂</button>
                    <button class="btn btn-small btn-danger" onclick="deletePlayer(${index})">„Åë„Åô</button>
                </div>
            `;
            container.appendChild(div);
        });
        if (players.length === 0) container.innerHTML = "<p>„Éó„É¨„Éº„É§„Éº„Åå„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Å®„ÅÜ„Çç„Åè„Åó„Å¶„Å≠„ÄÇ</p>";
        else if (players.length >= MAX_PLAYERS) {
            document.getElementById('new-player-name').disabled = true;
            document.getElementById('new-player-name').placeholder = "5„Å´„Çì „Åæ„Åß„Åß„Åô";
        } else {
            document.getElementById('new-player-name').disabled = false;
            document.getElementById('new-player-name').placeholder = "Êñ∞„Åó„ÅÑ„Åä„Å™„Åæ„Åà";
        }
    }

    window.openPlayerModal = function() {
        document.getElementById('player-modal').classList.remove('hidden');
        renderPlayerList();
    };
    window.closePlayerModal = function() {
        document.getElementById('player-modal').classList.add('hidden');
    };
    window.openRules = function() {
        document.getElementById('rule-modal').classList.remove('hidden');
    };
    window.closeRules = function() {
        document.getElementById('rule-modal').classList.add('hidden');
    };

    window.createPlayer = function() {
        const input = document.getElementById('new-player-name');
        const name = input.value.trim();
        const msg = document.getElementById('message-area');
        if (!name) { msg.textContent = "„Åä„Å™„Åæ„Åà„Çí„ÅÑ„Çå„Å¶„Å≠"; return; }
        if (name.length > 8) { msg.textContent = "8„ÇÇ„Åò ‰ª•ÂÜÖ„Åß„ÅÑ„Çå„Å¶„Å≠"; return; }
        if (players.length >= MAX_PLAYERS) { msg.textContent = "„ÇÇ„ÅÜ „ÅÑ„Å£„Å±„ÅÑ„Åß„Åô"; return; }
        if (NG_WORDS_HIRAGANA.some(word => name.includes(word))) {
            msg.textContent = "„Å§„Åã„Åà„Å™„ÅÑ „ÇÇ„Åò„Åå „ÅØ„ÅÑ„Å£„Å¶„ÅÑ„Åæ„Åô"; return;
        }
        const newP = { name: name, id: Date.now().toString() };
        players.push(newP);
        localStorage.setItem('kakezan_players', JSON.stringify(players));
        input.value = "";
        msg.textContent = "";
        selectPlayer(players.length - 1);
    };

    window.selectPlayer = function(index) {
        currentPlayer = players[index];
        localStorage.setItem('kakezan_current_player_idx', index);
        updatePlayerDisplay();
        closePlayerModal();
    };

    window.deletePlayer = function(index) {
        if (!confirm("„Åª„Çì„Å®„ÅÜ„Å´ „Åë„Åó„Åæ„Åô„ÅãÔºü")) return;
        if (currentPlayer && currentPlayer.id === players[index].id) {
            currentPlayer = null;
            updatePlayerDisplay();
        }
        players.splice(index, 1);
        localStorage.setItem('kakezan_players', JSON.stringify(players));
        renderPlayerList();
    };

    document.getElementById('start-btn-trigger').addEventListener('click', () => {
        if (!currentPlayer) {
            alert("„Éó„É¨„Éº„É§„Éº„Çí „Åõ„Çì„Åü„Åè „Åó„Å¶„Åè„Å†„Åï„ÅÑ");
            openPlayerModal();
            return;
        }
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('difficulty-screen').classList.remove('hidden');
    });

    // --- Ranking System ---
    let rankTab = 'local';
    let rankDiff = 'EASY';

    window.showRanking = function() {
        document.getElementById('ranking-modal').classList.remove('hidden');
        loadRanking();
    };
    window.closeRanking = function() {
        document.getElementById('ranking-modal').classList.add('hidden');
    };
    window.switchRankTab = function(tab) {
        rankTab = tab;
        document.getElementById('tab-local').className = tab === 'local' ? 'tab-btn active' : 'tab-btn';
        document.getElementById('tab-world').className = tab === 'world' ? 'tab-btn active' : 'tab-btn';
        loadRanking();
    };
    window.switchRankDiff = function(diff) {
        rankDiff = diff;
        ['easy','normal','hard'].forEach(d => {
            document.getElementById(`rank-diff-${d}`).className = 
                diff === d.toUpperCase() ? 'diff-btn active' : 'diff-btn';
        });
        loadRanking();
    };

    async function loadRanking() {
        const list = document.getElementById('ranking-list');
        list.innerHTML = "Ë™≠„ÅøËæº„Åø‰∏≠...";
        let data = [];
        if (rankTab === 'local') {
            const allScores = JSON.parse(localStorage.getItem('kakezan_local_scores') || '[]');
            data = allScores
                .filter(s => s.difficulty === rankDiff)
                .sort((a,b) => b.score - a.score)
                .slice(0, 10);
        } else {
            try {
                if(window.dbInstance) {
                    const q = window.query(
                        window.collection(window.dbInstance, "scores_kakezan_dungeon"),
                        window.where("difficulty", "==", rankDiff),
                        window.orderBy("score", "desc"),
                        window.limit(10)
                    );
                    const snap = await window.getDocs(q);
                    snap.forEach(doc => data.push(doc.data()));
                }
            } catch(e) {
                console.error(e);
                list.innerHTML = "Ë™≠„ÅøËæº„Åø„Ç®„É©„ÉºÔºà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰ΩúÊàêÂæÖ„Å° „Åæ„Åü„ÅØ ÈÄö‰ø°„Ç®„É©„ÉºÔºâ";
                return;
            }
        }
        list.innerHTML = "";
        if (data.length === 0) {
            list.innerHTML = "<div style='text-align:center; padding:20px; color:#d7ccc8;'>„Åæ„Å† Ë®òÈå≤„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>";
            return;
        }
        data.forEach((d, i) => {
            const row = document.createElement('div');
            row.className = 'rank-row';
            row.innerHTML = `<span>${i+1}‰Ωç</span> <span>${d.name}</span> <span>${d.score}ÁÇπ</span>`;
            list.appendChild(row);
        });
    }

    // --- Game Logic ---
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        let clientX = evt.clientX;
        let clientY = evt.clientY;
        if(evt.touches && evt.touches.length > 0) {
            clientX = evt.touches[0].clientX;
            clientY = evt.touches[0].clientY;
        } else if (evt.changedTouches && evt.changedTouches.length > 0) {
            clientX = evt.changedTouches[0].clientX;
            clientY = evt.changedTouches[0].clientY;
        }
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    canvas.addEventListener('mousedown', handleInputStart);
    canvas.addEventListener('touchstart', handleInputStart, {passive: false});
    canvas.addEventListener('mousemove', handleInputMove);
    canvas.addEventListener('touchmove', handleInputMove, {passive: false});
    canvas.addEventListener('mouseup', handleInputEnd);
    canvas.addEventListener('touchend', handleInputEnd);
    
    function getRequiredKeys(lvl) {
        return lvl <= 5 ? 5 : lvl;
    }

    function handleTap(x, y) {
        if(gameState !== "PLAYING") return;

        if (placingState) {
            const { pixelX, pixelY } = placingState;
            if (x >= pixelX + 10 && x <= pixelX + 110 && y >= pixelY - 20 && y <= pixelY + 20) {
                finalizePlacement();
                return;
            }
            if (x >= pixelX - 110 && x <= pixelX - 10 && y >= pixelY - 20 && y <= pixelY + 20) {
                placingState = null; 
                return;
            }
            return;
        }

        const reqKeys = getRequiredKeys(level);
        // Changed hitbox to match new button position (offset +220)
        if (x > LAYOUT.mapX + 220 && x < LAYOUT.mapX + 470 && y > LAYOUT.itemY + 80 && y < LAYOUT.itemY + 130) {
             if(items.keys >= reqKeys) nextStage();
        }
        
        if (x > 20 && x < 200 && y > 570 && y < 620) {
            openRules();
        }

        if (x > 20 && x < 200 && y > 640 && y < 690) {
            if(confirm("„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Å´„Å™„Çä„Åæ„Åô„Åå„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü")) gameOver(false);
        }

        const btnW = 150;
        const iY = 550; 
        if (x > LAYOUT.mapX + 320 && x < LAYOUT.mapX + 320 + btnW && y > iY && y < iY + 50) {
            useWand();
        }
        
        // ÂÖ®Ê∂à„Åó„Éú„Çø„É≥Âà§ÂÆö (Êû†ÂÜÖÂè≥ÂÅ¥„ÅÆALL„Éú„Çø„É≥)
        const swordX = LAYOUT.mapX;
        const pickX = LAYOUT.mapX + 160;
        
        // Sword ALL
        const monsterCount = mapObjects.filter(o => o.type === 'monster').length;
        if (items.sword >= monsterCount && monsterCount > 0) {
             if (x > swordX + 100 && x < swordX + 145 && y > iY + 10 && y < iY + 40) {
                 useAllSwords(monsterCount);
                 return;
             }
        }
        // Pickaxe ALL
        const rockCount = mapObjects.filter(o => o.type === 'rock').length;
        if (items.pickaxe >= rockCount && rockCount > 0) {
             if (x > pickX + 100 && x < pickX + 145 && y > iY + 10 && y < iY + 40) {
                 useAllPickaxes(rockCount);
                 return;
             }
        }
        
        if (generatedRect && !isDragging && !placingState) {
            if (x > LAYOUT.rotateX && x < LAYOUT.rotateX + LAYOUT.rotateW && 
                y > LAYOUT.rotateY && y < LAYOUT.rotateY + LAYOUT.rotateH) {
                 const temp = generatedRect.w;
                 generatedRect.w = generatedRect.h;
                 generatedRect.h = temp;
                 return;
            }
        }
    }

    function handleInputStart(e) {
        if(gameState !== 'PLAYING') return;
        if(e.type === 'touchstart') e.preventDefault();
        const pos = getMousePos(e);
        tapStartPos = pos;
        if(placingState) return;

        // Hand
        for(let i=0; i<hand.length; i++) {
            const hx = LAYOUT.handStartX + i * LAYOUT.cardGap;
            const hy = LAYOUT.handY + 20;
            if (pos.x >= hx && pos.x <= hx + LAYOUT.cardW && pos.y >= hy && pos.y <= hy + LAYOUT.cardH) {
                isDragging = { type: 'card', index: i, val: hand[i] };
                dragPos = pos;
                return;
            }
        }

        // Generated Rect
        if (generatedRect) {
            const cx = LAYOUT.calcX + LAYOUT.calcW/2;
            const cy = LAYOUT.calcY + LAYOUT.calcH/2;
            const rw = generatedRect.w * GRID_SIZE;
            const rh = generatedRect.h * GRID_SIZE;
            if (pos.x >= cx - rw/2 && pos.x <= cx + rw/2 &&
                 pos.y >= cy - rh/2 && pos.y <= cy + rh/2) {
                 isDragging = { type: 'rect', obj: generatedRect };
                 dragPos = pos;
                 return;
            }
        }

        // Items
        const iY = 550;
        const btnW = 150;
        const swordX = LAYOUT.mapX;
        const pickX = LAYOUT.mapX + 160;

        // Sword Drag check (ALL„Éú„Çø„É≥È†òÂüü„ÅØÈô§Â§ñ)
        if (items.sword > 0 && pos.x > swordX && pos.x < swordX + btnW && pos.y > iY && pos.y < iY + 50) {
             const mCount = mapObjects.filter(o => o.type === 'monster').length;
             // ALL„Éú„Çø„É≥„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Åù„ÅÆ‰∏ä„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Åü„Çâ„Éâ„É©„ÉÉ„Ç∞„Åó„Å™„ÅÑ
             if (items.sword >= mCount && mCount > 0) {
                 if (pos.x > swordX + 100 && pos.x < swordX + 145 && pos.y > iY + 10 && pos.y < iY + 40) {
                     return; 
                 }
             }
             isDragging = { type: 'item', itemType: 'sword' };
             dragPos = pos;
             return;
        }
        // Pickaxe Drag check (ALL„Éú„Çø„É≥È†òÂüü„ÅØÈô§Â§ñ)
        if (items.pickaxe > 0 && pos.x > pickX && pos.x < pickX + btnW && pos.y > iY && pos.y < iY + 50) {
             const rCount = mapObjects.filter(o => o.type === 'rock').length;
             if (items.pickaxe >= rCount && rCount > 0) {
                 if (pos.x > pickX + 100 && pos.x < pickX + 145 && pos.y > iY + 10 && pos.y < iY + 40) {
                     return;
                 }
             }
             isDragging = { type: 'item', itemType: 'pickaxe' };
             dragPos = pos;
             return;
        }
    }

    function handleInputMove(e) {
        if (!isDragging) return;
        if(e.type === 'touchmove') e.preventDefault();
        dragPos = getMousePos(e);
    }

    function handleInputEnd(e) {
        if (!isDragging) {
            const endPos = getMousePos(e);
            const dist = Math.hypot(endPos.x - tapStartPos.x, endPos.y - tapStartPos.y);
            if (dist < 20) {
                handleTap(endPos.x, endPos.y);
            }
            return;
        }

        const dropX = dragPos.x;
        const dropY = dragPos.y;

        // Trash
        if (dropX > LAYOUT.trashX && dropX < LAYOUT.trashX + LAYOUT.trashW &&
            dropY > LAYOUT.trashY && dropY < LAYOUT.trashY + LAYOUT.trashH) {
            if (isDragging.type === 'card') {
                hand.splice(isDragging.index, 1);
                replenishHand();
            } else if (isDragging.type === 'rect') {
                resetCalc();
            }
            isDragging = null;
            checkGameOver();
            return;
        }

        // Calc Zone
        if (isDragging.type === 'card' && 
            dropX > LAYOUT.calcX && dropX < LAYOUT.calcX + LAYOUT.calcW &&
            dropY > LAYOUT.calcY && dropY < LAYOUT.calcY + LAYOUT.calcH) {
            
            if (!generatedRect) {
                // Determine logic for Joker or Number
                const cardVal = isDragging.val;
                
                if (cardVal === 'JOKER') {
                    // Show Selector
                    if (term1 === null) pendingJokerSlot = 'term1';
                    else if (term2 === null) pendingJokerSlot = 'term2';
                    else { isDragging = null; return; } // Full

                    document.getElementById('joker-selector').classList.remove('hidden');
                    // Remove card now
                    hand.splice(isDragging.index, 1);
                    replenishHand();
                    isDragging = null;
                    return;
                } else {
                    // Normal Number
                    if (term1 === null) {
                        term1 = cardVal;
                        hand.splice(isDragging.index, 1);
                        replenishHand();
                    } else if (term2 === null) {
                        term2 = cardVal;
                        hand.splice(isDragging.index, 1);
                        replenishHand();
                        startCalculation();
                    }
                }
            }
        }

        // Map Zone
        const mapW = MAP_COLS * GRID_SIZE;
        const mapH = MAP_ROWS * GRID_SIZE;
        if (dropX > LAYOUT.mapX && dropX < LAYOUT.mapX + mapW &&
            dropY > LAYOUT.mapY && dropY < LAYOUT.mapY + mapH) {
            
            if (isDragging.type === 'rect') {
                startPlacing(dropX, dropY);
            } else if (isDragging.type === 'item') {
                const gx = Math.floor((dropX - LAYOUT.mapX) / GRID_SIZE);
                const gy = Math.floor((dropY - LAYOUT.mapY) / GRID_SIZE);
                tryUseItem(gx, gy, isDragging.itemType);
            }
        }

        isDragging = null;
        checkGameOver();
    }

    // Joker selection
    window.selectJokerValue = function(val) {
        document.getElementById('joker-selector').classList.add('hidden');
        if (pendingJokerSlot === 'term1') {
            term1 = val;
        } else if (pendingJokerSlot === 'term2') {
            term2 = val;
            startCalculation();
        }
        pendingJokerSlot = null;
    }

    // Logic
    function startCalculation() {
        generatedRect = {
            w: term1,
            h: term2,
            color: getRandomColor(),
            value: term1 * term2
        };
    }
    
    function resetCalc() {
        generatedRect = null;
        term1 = null;
        term2 = null;
    }

    function getRandomColor() {
        const colors = ['#e57373', '#ffb74d', '#fff176', '#81c784', '#64b5f6', '#ba68c8', '#4db6ac'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    function replenishHand() {
        while (hand.length < 5 && currentDeck > 0) {
            // 20ÂàÜ„ÅÆ1 (5%) „Åß JOKER
            if (Math.random() < 0.05) {
                hand.push('JOKER');
            } else {
                hand.push(Math.floor(Math.random() * 10) + 1);
            }
            currentDeck--;
        }
    }

    function startPlacing(mouseX, mouseY) {
        const rect = { 
            w: generatedRect.w, 
            h: generatedRect.h, 
            color: generatedRect.color, 
            value: generatedRect.value 
        }; 

        const relX = mouseX - LAYOUT.mapX;
        const relY = mouseY - LAYOUT.mapY;
        const gridCenterX = relX / GRID_SIZE;
        const gridCenterY = relY / GRID_SIZE;
        
        let gx = Math.round(gridCenterX - rect.w / 2);
        let gy = Math.round(gridCenterY - rect.h / 2);
        
        if (gx < 0) gx = 0;
        if (gy < 0) gy = 0;
        if (gx + rect.w > MAP_COLS) gx = MAP_COLS - rect.w;
        if (gy + rect.h > MAP_ROWS) gy = MAP_ROWS - rect.h;

        const pixelX = LAYOUT.mapX + gx * GRID_SIZE + (rect.w * GRID_SIZE) / 2;
        const pixelY = LAYOUT.mapY + gy * GRID_SIZE + (rect.h * GRID_SIZE) / 2;

        placingState = {
            rect: rect,
            gx: gx,
            gy: gy,
            pixelX: pixelX,
            pixelY: pixelY
        };
    }

    function finalizePlacement() {
        if (!placingState) return;
        const { rect, gx, gy } = placingState;

        if (gx + rect.w > MAP_COLS || gy + rect.h > MAP_ROWS) {
            alert("„Åù„Åì„Å´„ÅØ „Åä„Åë„Åæ„Åõ„ÇìÔºà„ÅØ„Åø„Å†„Åó„Å¶„ÅÑ„Åæ„ÅôÔºâ");
            return;
        }

        for(let y=0; y<rect.h; y++) {
            for(let x=0; x<rect.w; x++) {
                const tx = gx + x;
                const ty = gy + y;
                if (mapData[ty][tx]) {
                    alert("„Åù„Åì„Å´„ÅØ „Åô„Åß„Å´ „Å™„Å´„Åã„ÅÇ„Çä„Åæ„Åô");
                    return; 
                }
                const obj = mapObjects.find(o => o.x === tx && o.y === ty);
                if (obj && (obj.type === 'monster' || obj.type === 'rock')) {
                    alert("„Åò„ÇÉ„Åæ„Å™„ÇÇ„ÅÆÔºà„É¢„É≥„Çπ„Çø„Éº„ÅãÂ≤©Ôºâ„Åå „ÅÇ„Çä„Åæ„Åô");
                    return;
                }
            }
        }

        const area = rect.w * rect.h;
        let scoreAdd = area * area;

        for(let y=0; y<rect.h; y++) {
            for(let x=0; x<rect.w; x++) {
                const tx = gx + x;
                const ty = gy + y;
                mapData[ty][tx] = { color: rect.color };
                
                const objIndex = mapObjects.findIndex(o => o.x === tx && o.y === ty);
                if (objIndex !== -1) {
                    const obj = mapObjects[objIndex];
                    collectItem(obj);
                    mapObjects.splice(objIndex, 1);
                }
            }
        }
        score += scoreAdd;
        
        addFloatingText(LAYOUT.mapX + gx*GRID_SIZE + (rect.w*GRID_SIZE)/2 - 30, 
                        LAYOUT.mapY + gy*GRID_SIZE + (rect.h*GRID_SIZE)/2, 
                        `+${area*area}`, "#ffffff");

        resetCalc();
        placingState = null;
        checkGameOver();
    }

    function collectItem(obj) {
        if (obj.type === 'key') items.keys++;
        else if (obj.type === 'sword') items.sword++;
        else if (obj.type === 'pickaxe') items.pickaxe++;
        else if (obj.type === 'wand') items.wand++;
        else if (obj.type === 'money') {
            score += 300;
            addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+300G", "#fff176");
        }
        else if (obj.type === 'card') {
            currentDeck += 1;
            addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+1Êûö", "#81c784");
            if (hand.length <= 4) replenishHand();
        }
    }

    function tryUseItem(gx, gy, itemType) {
        const objIndex = mapObjects.findIndex(o => o.x === gx && o.y === gy);
        if (objIndex === -1) return;
        const obj = mapObjects[objIndex];

        if (itemType === 'sword' && obj.type === 'monster') {
            mapObjects.splice(objIndex, 1);
            items.sword--;
            score += 200;
            addFloatingText(LAYOUT.mapX + gx*GRID_SIZE, LAYOUT.mapY + gy*GRID_SIZE, "+200", "#e57373");
        } else if (itemType === 'pickaxe' && obj.type === 'rock') {
            mapObjects.splice(objIndex, 1);
            items.pickaxe--;
            score += 100;
            addFloatingText(LAYOUT.mapX + gx*GRID_SIZE, LAYOUT.mapY + gy*GRID_SIZE, "+100", "#90a4ae");
        }
    }

    function useWand() {
        if (items.wand <= 0) return;
        if (!confirm("„Åæ„Åª„ÅÜ„ÅÆ„Å§„Åà „Çí „Å§„Åã„ÅÑ„Åæ„Åô„ÅãÔºü\nÔºà„Å¶„Åç „Å® „ÅÑ„Çè „Åå 50%„ÅÆ„Åã„Åè„Çä„Å§„Åß „Åç„Åà„Åæ„ÅôÔºâ")) return;
        items.wand--;
        
        let removedCount = 0;
        for (let i = mapObjects.length - 1; i >= 0; i--) {
            const obj = mapObjects[i];
            if (obj.type === 'monster' || obj.type === 'rock') {
                if (Math.random() < 0.5) {
                    addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "Ê∂àÊªÖÔºÅ", "#ba68c8");
                    mapObjects.splice(i, 1);
                    removedCount++;
                }
            }
        }
        if (removedCount === 0) {
             addFloatingText(LAYOUT.mapX + LAYOUT.mapW/2 - 50, LAYOUT.mapY + 240, "„Éü„ÇπÔºÅ", "#fff");
        }
    }
    
    function useAllSwords(count) {
        if (!confirm("„Å¶„Åç„Çí„Åú„Çì„Å∂„Åü„Åä„Åó„Åæ„Åô„ÅãÔºü")) return;
        items.sword -= count;
        score += count * 200;
        
        for (let i = mapObjects.length - 1; i >= 0; i--) {
            if (mapObjects[i].type === 'monster') {
                const obj = mapObjects[i];
                addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+200", "#e57373");
                mapObjects.splice(i, 1);
            }
        }
    }

    function useAllPickaxes(count) {
        if (!confirm("„ÅÑ„Çè„Çí„Åú„Çì„Å∂„Åì„Çè„Åó„Åæ„Åô„ÅãÔºü")) return;
        items.pickaxe -= count;
        score += count * 100;
        
        for (let i = mapObjects.length - 1; i >= 0; i--) {
            if (mapObjects[i].type === 'rock') {
                const obj = mapObjects[i];
                addFloatingText(LAYOUT.mapX + obj.x*GRID_SIZE, LAYOUT.mapY + obj.y*GRID_SIZE, "+100", "#90a4ae");
                mapObjects.splice(i, 1);
            }
        }
    }

    function addFloatingText(x, y, text, color) {
        if (gameState !== "PLAYING") return;
        floatingTexts.push({x, y, text, color, life: 60});
    }

    function checkGameOver() {
        // „Çπ„ÉÜ„Éº„Ç∏10„ÅßÈçµ„ÅåÊèÉ„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂà§ÂÆö„Åó„Å™„ÅÑÔºà„ÇØ„É™„Ç¢ÂæÖ„Å°Ôºâ
        if (level === 10 && items.keys >= getRequiredKeys(level)) {
            return;
        }

        if (hand.length <= 1 && currentDeck === 0 && !generatedRect && term1 === null) {
            gameOver(false);
        }
    }

    function nextStage() {
        level++;
        if (level > 10) {
            gameOver(true);
        } else {
            replenishHand();
            initLevel();
        }
    }

    function gameOver(cleared) {
        gameState = cleared ? "CLEARED" : "GAMEOVER";
        document.getElementById('result-modal').classList.remove('hidden');
        document.getElementById('result-title').textContent = cleared ? "„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ" : "„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº";
        document.getElementById('final-score').textContent = "SCORE: " + score;
        document.getElementById('result-difficulty').textContent = `Èõ£ÊòìÂ∫¶: ${difficulty === 'EASY' ? '„Åã„Çì„Åü„Çì' : difficulty === 'NORMAL' ? '„Åµ„Å§„ÅÜ' : '„ÇÄ„Åö„Åã„Åó„ÅÑ'}`;
        saveLocalScore();
        saveFirebaseScore();
    }

    function saveLocalScore() {
        let scores = JSON.parse(localStorage.getItem('kakezan_local_scores') || '[]');
        scores.push({
            name: currentPlayer.name,
            score: score,
            difficulty: difficulty,
            date: new Date().toISOString()
        });
        localStorage.setItem('kakezan_local_scores', JSON.stringify(scores));
    }

    function saveFirebaseScore() {
        if(window.addDoc && window.collection && window.dbInstance) {
            window.addDoc(window.collection(window.dbInstance, "scores_kakezan_dungeon"), {
                name: currentPlayer.name,
                score: score,
                difficulty: difficulty,
                date: new Date()
            }).catch(e => console.warn("Score save failed", e));
        }
    }

    window.backToTitle = function() {
        gameState = "TITLE";
        document.getElementById('result-modal').classList.add('hidden');
        document.getElementById('difficulty-screen').classList.add('hidden');
        document.getElementById('title-screen').classList.remove('hidden');
        canvas.classList.add('hidden');
    };

    window.startGame = function(diffMode) {
        difficulty = diffMode;
        if (diffMode === 'EASY') currentDeck = 20;
        else if (diffMode === 'NORMAL') currentDeck = 15;
        else currentDeck = 10;
        
        items = { sword: 2, pickaxe: 2, wand: 0, keys: 0 };
        score = 0;
        level = 1;
        
        hand = [];
        replenishHand(); 
        floatingTexts = []; 

        document.getElementById('difficulty-screen').classList.add('hidden');
        document.getElementById('title-screen').classList.add('hidden');
        document.getElementById('result-modal').classList.add('hidden');
        canvas.classList.remove('hidden');
        
        gameState = "PLAYING";
        initLevel();
        requestAnimationFrame(gameLoop);
    }

    function getObjectProbabilities(n, diff) {
        let probs = {
            monster: 0, rock: 0, sword: 0, pickaxe: 0,
            wand: 0, card: 0, money: 0
        };

        // ÂÖ±ÈÄö„ÉªÂü∫Êú¨Ë®≠ÂÆö
        probs.wand = 0.1 * n; // Â§âÊõ¥ÁÇπ

        if (diff === 'EASY') {
            probs.monster = 3 + 0.2 * n;
            probs.rock    = 3 + 0.2 * n;
            probs.sword   = 3 + 0.1 * n;
            probs.pickaxe = 3 + 0.1 * n;
            probs.card    = 6; // Â§âÊõ¥ÁÇπ
            probs.money   = 10;
        } else if (diff === 'NORMAL') {
            probs.monster = 3 + 0.3 * n;
            probs.rock    = 3 + 0.3 * n;
            probs.sword   = 3 + 0.15 * n;
            probs.pickaxe = 3 + 0.15 * n;
            probs.card    = 5; // Â§âÊõ¥ÁÇπ
            probs.money   = 20;
        } else { // HARD
            probs.monster = 3 + 0.4 * n; 
            probs.rock    = 3 + 0.4 * n;
            probs.sword   = 3 + 0.2 * n;
            probs.pickaxe = 3 + 0.2 * n;
            probs.card    = 4; // Â§âÊõ¥ÁÇπ
            probs.money   = 30;
        }

        return probs;
    }

    function initLevel() {
        mapData = Array(MAP_ROWS).fill(null).map(() => Array(MAP_COLS).fill(null));
        mapObjects = [];
        items.keys = 0;
        resetCalc();

        let emptySpots = [];
        for(let r=0; r<MAP_ROWS; r++) {
            for(let c=0; c<MAP_COLS; c++) {
                emptySpots.push({x:c, y:r});
            }
        }
        function popRandSpot() {
            if(emptySpots.length === 0) return null;
            const idx = Math.floor(Math.random() * emptySpots.length);
            return emptySpots.splice(idx, 1)[0];
        }

        // Èçµ„ÅÆÊï∞„ÇíÊ±∫ÂÆöÔºà„Çπ„ÉÜ„Éº„Ç∏1-5„ÅØ5ÂÄã„ÄÅ6‰ª•Èôç„ÅØ„Çπ„ÉÜ„Éº„Ç∏Êï∞Ôºâ
        const keyCount = getRequiredKeys(level);

        for(let i=0; i<keyCount; i++) {
            let p = popRandSpot(); 
            if(p) mapObjects.push({x: p.x, y: p.y, type: 'key'});
        }
        
        const probs = getObjectProbabilities(level, difficulty);
        
        const table = [
            { type: 'monster', p: probs.monster },
            { type: 'rock',    p: probs.rock },
            { type: 'sword',   p: probs.sword },
            { type: 'pickaxe', p: probs.pickaxe },
            { type: 'wand',    p: probs.wand },
            { type: 'card',    p: probs.card },
            { type: 'money',   p: probs.money }
        ];

        while(emptySpots.length > 0) {
            let p = popRandSpot();
            if(!p) break;

            let rand = Math.random() * 100; 
            let cumulative = 0;
            
            for(let t of table) {
                cumulative += t.p;
                if (rand < cumulative) {
                    mapObjects.push({x: p.x, y: p.y, type: t.type});
                    break; 
                }
            }
        }
    }

    // --- Drawing ---
    
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    }

    function gameLoop() {
        if (gameState !== "PLAYING" && gameState !== "GAMEOVER" && gameState !== "CLEARED") return;
        
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';

        // Background
        ctx.fillStyle = "#3e2723"; 
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Sidebar
        ctx.fillStyle = "#4e342e";
        ctx.fillRect(0, 0, LAYOUT.sidebarW, 720);
        ctx.strokeStyle = "#8d6e63";
        ctx.lineWidth = 4;
        ctx.strokeRect(10, 10, LAYOUT.sidebarW-20, 700);

        ctx.textAlign = "center";
        
        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("„Éó„É¨„Éº„É§„Éº", LAYOUT.sidebarW/2, 40);
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 28px 'M PLUS Rounded 1c'";
        ctx.fillText(currentPlayer ? currentPlayer.name : "„Ç≤„Çπ„Éà", LAYOUT.sidebarW/2, 75);

        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("„Å™„Çì„ÅÑ„Å©", LAYOUT.sidebarW/2, 125);
        let diffLabel = difficulty === 'EASY' ? '„Åã„Çì„Åü„Çì' : difficulty === 'NORMAL' ? '„Åµ„Å§„ÅÜ' : '„ÇÄ„Åö„Åã„Åó„ÅÑ';
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 28px 'M PLUS Rounded 1c'";
        ctx.fillText(diffLabel, LAYOUT.sidebarW/2, 160);

        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("„Çπ„ÉÜ„Éº„Ç∏", LAYOUT.sidebarW/2, 220);
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 40px 'M PLUS Rounded 1c'"; 
        // 11‰ª•‰∏ä„ÅÆË°®Á§∫„Å´„ÅØ„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´
        ctx.fillText(`${Math.min(level, 10)}/10`, LAYOUT.sidebarW/2, 280);
        
        ctx.fillStyle = "#efebe9";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("„Çπ„Ç≥„Ç¢", LAYOUT.sidebarW/2, 350);
        ctx.fillStyle = "#ffca28";
        ctx.font = "bold 40px 'M PLUS Rounded 1c'";
        ctx.fillText(`${score}`, LAYOUT.sidebarW/2, 400);

        drawButton(20, 570, 180, 50, "„ÅÇ„Åù„Å≥„Åã„Åü", "#5d4037");
        drawButton(20, 640, 180, 50, "„Çø„Ç§„Éà„É´„Å∏", "#78909c");

        // Map Area
        ctx.save();
        ctx.globalAlpha = 1.0; 
        ctx.translate(LAYOUT.mapX, LAYOUT.mapY);
        
        ctx.fillStyle = "#ffffff"; 
        ctx.fillRect(0, 0, MAP_COLS*GRID_SIZE, MAP_ROWS*GRID_SIZE);

        for(let r=0; r<=MAP_ROWS; r++) {
            ctx.lineWidth = (r % 5 === 0) ? 3 : 1; 
            ctx.strokeStyle = "#8d6e63";
            ctx.beginPath(); ctx.moveTo(0, r*GRID_SIZE); ctx.lineTo(MAP_COLS*GRID_SIZE, r*GRID_SIZE); ctx.stroke();
        }
        for(let c=0; c<=MAP_COLS; c++) {
            ctx.lineWidth = (c % 5 === 0) ? 3 : 1; 
            ctx.strokeStyle = "#8d6e63";
            ctx.beginPath(); ctx.moveTo(c*GRID_SIZE, 0); ctx.lineTo(c*GRID_SIZE, MAP_ROWS*GRID_SIZE); ctx.stroke();
        }

        // Draw Map Objects (Backgrounds)
        mapObjects.forEach(obj => {
            if (obj.type === 'money') return;

            let bgColor = null;
            // Êû†Á∑ö„ÅÆË®≠ÂÆöÔºà„É¢„É≥„Çπ„Çø„Éº„ÉªÂ≤©Áî®Ôºâ
            let borderColor = null;

            if (obj.type === 'monster') {
                bgColor = "#CC4D16";
                borderColor = "#1a1a1a"; 
            }
            else if (obj.type === 'rock') {
                bgColor = "rgba(62, 39, 35, 0.8)"; 
                borderColor = "#1a1a1a"; 
            }
            else if (obj.type === 'key') bgColor = "#F0EBB2";
            else if (obj.type === 'card') {
                bgColor = null; 
            }
            else if (obj.type === 'sword') bgColor = "#CFD0F0";
            else if (obj.type === 'pickaxe') bgColor = "#D0F0CF";
            else if (obj.type === 'wand') bgColor = "#B1E0DB";

            if (bgColor) {
                ctx.fillStyle = bgColor;
                ctx.fillRect(obj.x*GRID_SIZE+1, obj.y*GRID_SIZE+1, GRID_SIZE-2, GRID_SIZE-2);
            }

            // „É¢„É≥„Çπ„Çø„Éº„Å®Â≤©„ÅÆÊû†Á∑öÊèèÁîª
            if (borderColor) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2; 
                ctx.strokeRect(obj.x*GRID_SIZE+2, obj.y*GRID_SIZE+2, GRID_SIZE-4, GRID_SIZE-4);
            }
        });

        // Placed Rects
        for(let r=0; r<MAP_ROWS; r++) {
            for(let c=0; c<MAP_COLS; c++) {
                if (mapData[r][c]) {
                    ctx.fillStyle = mapData[r][c].color;
                    ctx.fillRect(c*GRID_SIZE + 1, r*GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    ctx.beginPath();
                    ctx.moveTo(c*GRID_SIZE + 1, r*GRID_SIZE + 1);
                    ctx.lineTo(c*GRID_SIZE + 15, r*GRID_SIZE + 1);
                    ctx.lineTo(c*GRID_SIZE + 1, r*GRID_SIZE + 15);
                    ctx.fill();
                }
            }
        }

        // Draw Map Objects (Icons)
        ctx.font = "32px serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        mapObjects.forEach(obj => {
            if (obj.type === 'money') return;

            // „Ç´„Éº„Éâ„Ç¢„Ç§„ÉÜ„É†„ÅØ„Ç´„Çπ„Çø„É†ÊèèÁîª
            if (obj.type === 'card') {
                const cx = obj.x*GRID_SIZE + GRID_SIZE/2;
                const cy = obj.y*GRID_SIZE + GRID_SIZE/2;
                // ÁôΩ„ÅÑ„Ç´„Éº„Éâ„ÅÆ„Ç§„É©„Çπ„Éà
                ctx.save();
                ctx.translate(cx, cy);
                ctx.fillStyle = "#fff";
                ctx.fillRect(-12, -16, 24, 32); // „Ç´„Éº„ÉâÊú¨‰Ωì
                ctx.strokeStyle = "#4e342e";
                ctx.lineWidth = 1;
                ctx.strokeRect(-12, -16, 24, 32); // „Ç´„Éº„ÉâÊû†
                // ‰∏≠„ÅÆÊ®°ÊßòÔºà„Éè„Éº„ÉàÔºâ
                ctx.fillStyle = "#e91e63";
                ctx.font = "16px sans-serif";
                ctx.fillText("‚ô•", 0, 0); 
                ctx.restore();
            } else {
                let icon = ICONS[obj.type] || '?';
                ctx.fillStyle = "#000000"; 
                ctx.fillText(icon, obj.x*GRID_SIZE + GRID_SIZE/2, obj.y*GRID_SIZE + GRID_SIZE/2 + 2);
            }
        });
        
        ctx.strokeStyle = "#5d4037";
        ctx.lineWidth = 4;
        ctx.roundRect(0,0, MAP_COLS*GRID_SIZE, MAP_ROWS*GRID_SIZE, 8).stroke();
        
        ctx.restore();

        // Items Display
        const iY = 550; 
        const btnW = 150;
        const swordX = LAYOUT.mapX;
        const pickX = LAYOUT.mapX + 160;

        // Sword Icon
        drawItemIcon(swordX, iY, btnW, 50, 'sword', items.sword);
        // ÂÖ®Ê∂à„Åó„Éú„Çø„É≥ (Sword)
        const monsterCount = mapObjects.filter(o => o.type === 'monster').length;
        if (items.sword >= monsterCount && monsterCount > 0) {
            drawButton(swordX + 100, iY + 10, 45, 30, "ALL", "#d32f2f");
        }

        // Pickaxe Icon
        drawItemIcon(pickX, iY, btnW, 50, 'pickaxe', items.pickaxe);
        // ÂÖ®Ê∂à„Åó„Éú„Çø„É≥ (Pickaxe)
        const rockCount = mapObjects.filter(o => o.type === 'rock').length;
        if (items.pickaxe >= rockCount && rockCount > 0) {
            drawButton(pickX + 100, iY + 10, 45, 30, "ALL", "#78909c");
        }
        
        // Wand Icon
        drawItemIcon(LAYOUT.mapX + 320, iY, btnW, 50, 'wand', items.wand);
        
        // Keys
        ctx.fillStyle = "#ffca28";
        ctx.textAlign = "left";
        const reqKeys = getRequiredKeys(level);
        for(let i=0; i<reqKeys; i++) {
            ctx.save();
            ctx.globalAlpha = i < items.keys ? 1.0 : 0.2;
            ctx.font = "30px serif";
            // 2ÂàóÁõÆÂà§ÂÆö
            const col = i % 5;
            const row = Math.floor(i / 5);
            ctx.fillText("üóùÔ∏è", LAYOUT.mapX + 10 + col * 35, iY + 100 + row * 35);
            ctx.restore();
        }

        // Updated button position (+220 offset)
        if (items.keys >= reqKeys) {
             drawButton(LAYOUT.mapX + 220, iY + 75, 250, 50, "„Å§„Åé„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å∏", "#558b2f");
        } else {
             drawButton(LAYOUT.mapX + 220, iY + 75, 250, 50, "„Ç´„ÇÆ„Çí„ÅÇ„Å§„ÇÅ„Çà„ÅÜ", "#78909c");
        }

        // Calc Area
        ctx.fillStyle = "#4e342e";
        ctx.roundRect(LAYOUT.calcX, LAYOUT.calcY, LAYOUT.calcW, LAYOUT.calcH, 12).fill();
        ctx.strokeStyle = "#8d6e63";
        ctx.lineWidth = 5;
        ctx.roundRect(LAYOUT.calcX, LAYOUT.calcY, LAYOUT.calcW, LAYOUT.calcH, 12).stroke();

        ctx.fillStyle = "#efebe9";
        ctx.font = "80px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        let dispTerm1 = term1 === null ? "‚ñ°" : term1;
        let dispTerm2 = term2 === null ? "‚ñ°" : term2;
        let calcText = `${dispTerm1} √ó ${dispTerm2}`;
        ctx.fillText(calcText, LAYOUT.calcX + LAYOUT.calcW/2, LAYOUT.calcY + LAYOUT.calcH/2);

        if (generatedRect && isDragging?.obj !== generatedRect && !placingState) {
             const cx = LAYOUT.calcX + LAYOUT.calcW/2;
             const cy = LAYOUT.calcY + LAYOUT.calcH/2;
             const rw = generatedRect.w * GRID_SIZE;
             const rh = generatedRect.h * GRID_SIZE;
             
             ctx.fillStyle = generatedRect.color;
             ctx.fillRect(cx - rw/2, cy - rh/2, rw, rh);
             ctx.strokeStyle = "#fff";
             ctx.lineWidth = 2;
             ctx.strokeRect(cx - rw/2, cy - rh/2, rw, rh);
        }

        drawButton(LAYOUT.rotateX, LAYOUT.rotateY, LAYOUT.rotateW, LAYOUT.rotateH, ICONS.rotate + " „Åã„ÅÑ„Å¶„Çì", "#558b2f");

        // Trash
        ctx.save();
        ctx.translate(LAYOUT.trashX, LAYOUT.trashY);
        ctx.fillStyle = "rgba(188, 170, 164, 0.1)"; 
        ctx.roundRect(0, 0, LAYOUT.trashW, LAYOUT.trashH, 10).fill();
        ctx.strokeStyle = "#8d6e63";
        ctx.lineWidth = 2;
        ctx.roundRect(0, 0, LAYOUT.trashW, LAYOUT.trashH, 10).stroke();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#bcaaa4";
        ctx.font = "bold 28px 'M PLUS Rounded 1c', sans-serif";
        ctx.fillText(ICONS.trash + " „Åô„Å¶„Çã", LAYOUT.trashW / 2, LAYOUT.trashH / 2);
        ctx.restore();

        // Deck
        drawCardBack(LAYOUT.deckX, LAYOUT.deckY + 20);
        ctx.font = "18px 'M PLUS Rounded 1c'";
        ctx.fillStyle = "#efebe9";
        ctx.textAlign = "center";
        ctx.textBaseline = "alphabetic";
        ctx.fillText(`„ÅÇ„Å®${currentDeck}„Åæ„ÅÑ`, LAYOUT.deckX + LAYOUT.cardW/2, LAYOUT.deckY + 145);

        // Hand
        hand.forEach((val, i) => {
            if (isDragging?.type === 'card' && isDragging.index === i) return;
            drawCardRect(LAYOUT.handStartX + i * LAYOUT.cardGap, LAYOUT.handY + 20, val);
        });

        // Placing State
        if (placingState) {
            const { rect, gx, gy, pixelX, pixelY } = placingState;
            const rw = rect.w * GRID_SIZE;
            const rh = rect.h * GRID_SIZE;
            
            ctx.save();
            ctx.translate(LAYOUT.mapX, LAYOUT.mapY);
            ctx.fillStyle = rect.color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(gx*GRID_SIZE, gy*GRID_SIZE, rw, rh);
            ctx.strokeStyle = "#ffeb3b";
            ctx.lineWidth = 3;
            ctx.strokeRect(gx*GRID_SIZE, gy*GRID_SIZE, rw, rh);
            ctx.globalAlpha = 1.0;
            ctx.restore();

            drawButton((pixelX + 60) - 50, pixelY - 20, 100, 40, "„ÅØ„ÅÑ", "#558b2f");
            drawButton((pixelX - 60) - 50, pixelY - 20, 100, 40, "„ÅÑ„ÅÑ„Åà", "#c62828");
            
            ctx.fillStyle = "#fff";
            ctx.font = "bold 20px 'M PLUS Rounded 1c'";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.strokeText("„Åì„Åì„Åß„ÅÑ„ÅÑÔºü", pixelX, pixelY - rh/2 - 10);
            ctx.fillText("„Åì„Åì„Åß„ÅÑ„ÅÑÔºü", pixelX, pixelY - rh/2 - 10);
        }

        // Dragging
        if (isDragging) {
            if (isDragging.type === 'card') {
                drawCardRect(dragPos.x - LAYOUT.cardW/2, dragPos.y - LAYOUT.cardH/2, isDragging.val);
            } else if (isDragging.type === 'rect') {
                const r = isDragging.obj;
                const rw = r.w * GRID_SIZE;
                const rh = r.h * GRID_SIZE;
                ctx.fillStyle = r.color;
                ctx.globalAlpha = 0.5; 
                ctx.fillRect(dragPos.x - rw/2, dragPos.y - rh/2, rw, rh);
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.strokeRect(dragPos.x - rw/2, dragPos.y - rh/2, rw, rh);
                ctx.globalAlpha = 1.0;
            } else if (isDragging.type === 'item') {
                 ctx.font = "40px serif";
                 ctx.fillStyle = "#fff";
                 ctx.fillText(ICONS[isDragging.itemType], dragPos.x, dragPos.y);
            }
        }

        for(let i=floatingTexts.length-1; i>=0; i--) {
            const ft = floatingTexts[i];
            ctx.fillStyle = ft.color;
            ctx.shadowColor = "#000";
            ctx.shadowBlur = 4;
            ctx.font = "bold 26px 'M PLUS Rounded 1c'";
            ctx.fillText(ft.text, ft.x, ft.y);
            ctx.shadowBlur = 0;
            ft.y -= 1;
            ft.life--;
            if(ft.life <= 0) floatingTexts.splice(i, 1);
        }

        requestAnimationFrame(gameLoop);
    }

    function drawCardRect(x, y, val) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        const w = LAYOUT.cardW;
        const h = LAYOUT.cardH;
        
        ctx.fillStyle = "#efebe9";
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.strokeStyle = "#4e342e";
        ctx.lineWidth = 2;
        ctx.roundRect(x, y, w, h, 8).stroke();
        
        ctx.strokeStyle = "#bcaaa4";
        ctx.lineWidth = 1;
        ctx.strokeRect(x+5, y+5, w-10, h-10);

        ctx.fillStyle = "#3e2723";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        if (val === 'JOKER') {
            // Joker Design
            ctx.font = "50px 'M PLUS Rounded 1c'";
            ctx.fillText("üÉè", x + w/2, y + h/2 + 2);
        } else {
            ctx.font = "46px 'M PLUS Rounded 1c'";
            ctx.fillText(val, x + w/2, y + h/2 + 2);
        }
        ctx.restore();
    }

    function drawCardBack(x, y) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        const w = LAYOUT.cardW;
        const h = LAYOUT.cardH;
        ctx.fillStyle = "#5d4037";
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.strokeStyle = "#efebe9";
        ctx.lineWidth = 2;
        ctx.stroke(); 
        
        ctx.fillStyle = "#8d6e63";
        ctx.beginPath();
        ctx.arc(x+w/2, y+h/2, 15, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }

    function drawItemIcon(x, y, w, h, type, count) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "rgba(78, 52, 46, 0.9)";
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.strokeStyle = "#8d6e63";
        ctx.roundRect(x, y, w, h, 8).stroke();
        
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";

        // „Ç¢„Ç§„Ç≥„É≥ (Â∑¶ÂØÑ„ÅõÊ∞óÂë≥„Å´ÈÖçÁΩÆ)
        ctx.font = "30px serif";
        ctx.textAlign = "center"; 
        ctx.fillText(ICONS[type], x + 30, y + h/2 + 2); 

        // Êï∞ÂÄ§ (Â∑¶ÊèÉ„Åà„ÅßÈÖçÁΩÆ„Åó„ÄÅÊ°ÅÊï∞„ÅåÂ¢ó„Åà„Å¶„ÇÇÂè≥„ÅÆ„Éú„Çø„É≥„Å®Èáç„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´)
        ctx.font = "20px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText(`√ó${count}`, x + 55, y + h/2 + 2);
        
        ctx.restore();
    }

    function drawButton(x, y, w, h, text, color) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = color;
        ctx.shadowColor = "rgba(0,0,0,0.5)";
        ctx.shadowOffsetY = 4;
        ctx.roundRect(x, y, w, h, 8).fill();
        ctx.shadowColor = "transparent";
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = "#fff";
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, x + w/2, y + h/2);
        ctx.restore();
    }

    initPlayerSystem();

</script>
</body>
</html>