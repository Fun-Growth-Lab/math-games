<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Braves ÔΩûÂ∞èÊï∞ÔΩû</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap" rel="stylesheet">
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <style>
        :root {
            --primary-bg: #FFF9E6; 
            --main-font: 'M PLUS Rounded 1c', sans-serif;
            --text-dark: #5D4037; 
            --btn-blue: #81D4FA;
            --btn-blue-hover: #4FC3F7;
            --btn-red: #F48FB1;
            --btn-red-hover: #F06292;
            --btn-green: #A5D6A7;
            --btn-green-hover: #81C784;
            --btn-yellow: #FFF59D;
            --btn-yellow-hover: #FFF176;
            --game-width: 1280px;
            --game-height: 720px;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #333; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: var(--main-font);
            touch-action: none;
        }

        #game-wrapper {
            position: absolute;
            left: 50%;
            top: 50%;
            width: var(--game-width);
            height: var(--game-height);
            background-color: var(--primary-bg);
            transform: translate(-50%, -50%) scale(1);
            transform-origin: center center;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlays (Menus) */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: transparent;
            background-size: cover;
            background-position: center;
        }

        .hidden { display: none !important; }

        .title-container {
            background: rgba(255, 255, 255, 0.85);
            padding: 30px 50px;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 4px solid #FFECB3;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-size: 64px;
            color: var(--text-dark);
            text-shadow: 2px 2px 0 #fff, -2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff;
            margin: 0;
            font-weight: 800;
        }

        h2.subtitle {
            font-size: 32px;
            color: var(--text-dark);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 700;
        }

        .menu-btn {
            width: 320px;
            padding: 10px 20px;
            margin: 8px;
            font-size: 22px;
            font-weight: 700;
            font-family: var(--main-font);
            color: var(--text-dark);
            background-color: var(--btn-blue);
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 5px 0 var(--btn-blue-hover);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .menu-btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        .menu-btn.blue { background-color: var(--btn-blue); box-shadow: 0 5px 0 var(--btn-blue-hover); }
        .menu-btn.red { background-color: var(--btn-red); box-shadow: 0 5px 0 var(--btn-red-hover); }
        .menu-btn.green { background-color: var(--btn-green); box-shadow: 0 5px 0 var(--btn-green-hover); }
        .menu-btn.yellow { background-color: var(--btn-yellow); box-shadow: 0 5px 0 var(--btn-yellow-hover); }
        .menu-btn.gray { background-color: #E0E0E0; box-shadow: 0 5px 0 #BDBDBD; }

        #current-player-display {
            margin-bottom: 15px;
            font-size: 20px;
            color: var(--text-dark);
            font-weight: bold;
            background: rgba(255, 249, 230, 0.9);
            padding: 8px 25px;
            border-radius: 20px;
            border: 2px solid #FFE082;
        }

        /* Player Select Screen */
        .panel {
            background: rgba(255, 255, 255, 0.85);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
            width: 800px;
            max-height: 90%;
            overflow-y: auto;
            color: var(--text-dark);
            border: 4px solid #FFECB3;
        }

        .player-list { display: flex; flex-direction: column; gap: 10px; margin: 20px 0; }
        .player-item {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(255, 249, 230, 0.9); padding: 12px 20px; border-radius: 15px;
            font-size: 22px; font-weight: bold; cursor: pointer; border: 3px solid transparent;
        }
        .player-item:hover { background: rgba(255, 236, 179, 0.9); }
        .player-item.selected { border-color: #FFB74D; background: rgba(255, 224, 130, 0.9); }
        
        input[type="text"] {
            font-family: var(--main-font); font-size: 22px; padding: 10px;
            border: 3px solid #FFCC80; border-radius: 15px; width: 320px; text-align: center;
            color: var(--text-dark); outline: none;
        }

        /* Custom Popup (System Errors etc) */
        .popup-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fff; padding: 30px; border-radius: 20px;
            box-shadow: 0 0 0 1000px rgba(0,0,0,0.4); z-index: 100;
            text-align: center; font-size: 22px; width: 500px; color: var(--text-dark);
            border: 4px solid #FFECB3; font-weight: bold;
        }

        /* Ranking Table */
        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 18px; }
        th, td { border: 2px solid #FFECB3; padding: 10px; text-align: center; }
        th { background-color: #FFCC80; color: var(--text-dark); border-color: #FFB74D; }
        tr:nth-child(even) { background-color: rgba(255, 249, 230, 0.5); }
        
        .tabs { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
        .tab-btn {
            padding: 10px 20px; font-size: 18px; cursor: pointer; color: var(--text-dark);
            border: none; border-radius: 15px; background: #FFF9E6; font-weight: 700;
        }
        .tab-btn.active#tab-world, .tab-btn.active#tab-local { background: var(--btn-yellow); }
        .tab-btn.active#tab-easy { background: var(--btn-green); }
        .tab-btn.active#tab-normal { background: var(--btn-blue); }
        .tab-btn.active#tab-hard { background: var(--btn-red); }

    </style>
</head>
<body>

<div id="game-wrapper">
    <canvas id="gameCanvas" width="1280" height="720"></canvas>

    <div id="screen-title" class="ui-layer">
        <div class="title-container">
            <h1>Math Braves</h1>
            <h2 class="subtitle">ÔΩûÂ∞èÊï∞ÔΩû</h2>
            <div id="current-player-display">ÁèæÂú®„ÅÆ„Éó„É¨„Éº„É§„Éº: „Ç≤„Çπ„Éà</div>
            <button class="menu-btn green" onclick="goToDifficulty()">„ÅØ„Åò„ÇÅ„Çã</button>
            <button class="menu-btn blue" onclick="showScreen('screen-player')">„Éó„É¨„Éº„É§„ÉºÈÅ∏Êäû</button>
            <button class="menu-btn red" onclick="loginGoogle()">Google„Åß„É≠„Ç∞„Ç§„É≥</button>
            <button class="menu-btn yellow" onclick="showRanking()">„É©„É≥„Ç≠„É≥„Ç∞</button>
            <button class="menu-btn gray" onclick="location.href='../index.html'">INDEX„Å∏Êàª„Çã</button>
        </div>
    </div>

    <div id="screen-difficulty" class="ui-layer hidden">
        <div class="title-container">
            <h1 style="font-size: 40px; margin-bottom: 20px;">Èõ£ÊòìÂ∫¶ÈÅ∏Êäû</h1>
            <button class="menu-btn green" onclick="startGame('„ÇÑ„Åï„Åó„ÅÑ')">„ÇÑ„Åï„Åó„ÅÑ (HP 3.0)</button>
            <button class="menu-btn blue" onclick="startGame('„Åµ„Å§„ÅÜ')">„Åµ„Å§„ÅÜ (HP 2.0)</button>
            <button class="menu-btn red" onclick="startGame('„ÇÄ„Åö„Åã„Åó„ÅÑ')">„ÇÄ„Åö„Åã„Åó„ÅÑ (HP 1.0)</button>
            <button class="menu-btn gray" style="margin-top: 20px;" onclick="showScreen('screen-title')">Êàª„Çã</button>
        </div>
    </div>

    <div id="screen-player" class="ui-layer hidden">
        <div class="panel">
            <h2 style="font-size: 30px; margin-top: 0;">„Éó„É¨„Éº„É§„ÉºÈÅ∏Êäû</h2>
            <div id="player-list-container" class="player-list"></div>
            
            <div style="margin-top: 20px; border-top: 3px dashed #FFCC80; padding-top: 20px;">
                <h3 style="font-size: 24px; margin-bottom: 5px;">Êñ∞Ë¶èÁôªÈå≤ (ÊúÄÂ§ß5Âêç)</h3>
                <p style="font-size: 16px; color: #8D6E63;">‚Äª„Å≤„Çâ„Åå„Å™„Å®„Äå„Éº„Äç„ÅÆ„Åø„ÄÅ8ÊñáÂ≠ó„Åæ„Åß</p>
                <input type="text" id="new-player-name" maxlength="8" placeholder="„Å™„Åæ„Åà„Çí„ÅÑ„Çå„Å¶„Å≠">
                <button class="menu-btn green" style="width: auto; padding: 10px 25px; font-size: 20px;" onclick="registerPlayer()">ÁôªÈå≤</button>
            </div>
            
            <button id="btn-player-back" class="menu-btn gray" style="margin-top: 20px;" onclick="showScreen('screen-title')">ÈÅ∏Êäû„Åó„Å¶Êàª„Çã</button>
        </div>
    </div>

    <div id="screen-ranking" class="ui-layer hidden">
        <div class="panel" style="width: 1000px;">
            <h2 style="font-size: 30px; margin-top: 0;">„É©„É≥„Ç≠„É≥„Ç∞</h2>
            <div class="tabs">
                <button class="tab-btn active" id="tab-world" onclick="switchRankTab('world')">„ÉØ„Éº„É´„Éâ</button>
                <button class="tab-btn" id="tab-local" onclick="switchRankTab('local')">„É≠„Éº„Ç´„É´</button>
            </div>
            <div class="tabs" style="font-size: 16px;">
                <button class="tab-btn active" id="tab-easy" onclick="switchRankDiff('„ÇÑ„Åï„Åó„ÅÑ')">„ÇÑ„Åï„Åó„ÅÑ</button>
                <button class="tab-btn" id="tab-normal" onclick="switchRankDiff('„Åµ„Å§„ÅÜ')">„Åµ„Å§„ÅÜ</button>
                <button class="tab-btn" id="tab-hard" onclick="switchRankDiff('„ÇÄ„Åö„Åã„Åó„ÅÑ')">„ÇÄ„Åö„Åã„Åó„ÅÑ</button>
            </div>
            <div style="min-height: 350px;">
                <table id="ranking-table">
                    <thead><tr><th>È†Ü‰Ωç</th><th>ÂêçÂâç</th><th>„ÇØ„É™„Ç¢„Çπ„ÉÜ„Éº„Ç∏</th><th>„Çπ„Ç≥„Ç¢</th><th>ÊÆã„ÇäHP</th></tr></thead>
                    <tbody id="ranking-body"></tbody>
                </table>
                <div id="ranking-loading" style="font-size:20px; margin-top: 20px; display:none;">Ë™≠„ÅøËæº„Åø‰∏≠...</div>
            </div>
            <button class="menu-btn gray" style="margin-top: 20px;" onclick="showScreen('screen-title')">Êàª„Çã</button>
        </div>
    </div>

    <div id="screen-result" class="ui-layer hidden">
        <div class="title-container" style="width: 500px; padding: 40px 50px;">
            <h1 id="result-title" style="font-size: 56px; margin-bottom: 30px;"></h1>
            <div id="result-details" style="width: 100%; font-size: 26px; font-weight: bold; color: var(--text-dark); margin-bottom: 30px; text-align: left;">
                </div>
            <button class="menu-btn gray" onclick="showScreen('screen-title')">„Çø„Ç§„Éà„É´„Å∏„ÇÇ„Å©„Çã</button>
        </div>
    </div>

    <div id="custom-popup" class="popup-modal hidden">
        <p id="popup-message" style="margin-bottom: 20px; line-height: 1.6;"></p>
        <button class="menu-btn green" style="width: 180px;" onclick="closePopup()">OK</button>
    </div>

    <div id="change-popup" class="popup-modal hidden">
        <p style="margin-bottom: 20px; line-height: 1.6;">„ÉÄ„Ç§„É§üíé„Çí1„Å§Ê∂àË≤ª„Åó„Åæ„Åô„ÄÇ<br>„Å©„Å°„Çâ„Çí„ÉÅ„Çß„É≥„Ç∏„Åó„Åæ„Åô„ÅãÔºü</p>
        <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
            <button class="menu-btn blue" style="width: 250px;" onclick="confirmChangeHand()">ÊâãÊú≠„Çí„ÉÅ„Çß„É≥„Ç∏</button>
            <button class="menu-btn green" style="width: 250px;" onclick="confirmChangeField()">Â†¥„Çí„ÉÅ„Çß„É≥„Ç∏</button>
            <button class="menu-btn gray" style="width: 250px;" onclick="cancelChange()">„ÇÑ„ÇÅ„Çã</button>
        </div>
    </div>

    <div id="joker-popup" class="popup-modal hidden">
        <p style="margin-bottom: 10px; line-height: 1.6;">
            üÉè„Ç∏„Éß„Éº„Ç´„Éº„Çí„Å§„Åã„ÅÜÔºÅüÉè<br>
            Â•Ω„Åç„Å™„Åô„ÅÜ„Åò„ÇíÈÅ∏„Çì„Åß„Å≠<br>
            <span style="font-size: 16px;">Ôºà0.1 „Åã„Çâ 2.0 „Åæ„ÅßÔºâ</span>
        </p>
        <div style="display: flex; justify-content: center; align-items: center; gap: 15px; margin: 20px 0;">
            <button class="menu-btn blue" style="width: 70px; height: 70px; font-size: 40px; padding: 0; border-radius: 15px;" onclick="changeJokerVal(-0.1)">Ôºç</button>
            <div id="joker-display-val" style="font-size: 48px; font-weight: bold; width: 120px; color: var(--text-dark);">1.0</div>
            <button class="menu-btn red" style="width: 70px; height: 70px; font-size: 40px; padding: 0; border-radius: 15px;" onclick="changeJokerVal(0.1)">Ôºã</button>
        </div>
        <div style="display: flex; justify-content: center; gap: 15px; margin-top: 10px;">
            <button class="menu-btn green" style="width: 150px; font-size: 20px;" onclick="decideJoker()">„Åë„Å£„Å¶„ÅÑ</button>
            <button class="menu-btn gray" style="width: 150px; font-size: 20px;" onclick="cancelJoker()">„ÇÑ„ÇÅ„Çã</button>
        </div>
    </div>
</div>

<script>
    /* =========================================
       Firebase Initialization
    ========================================= */
    const firebaseConfig = {
        apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
        authDomain: "math-braves.firebaseapp.com",
        projectId: "math-braves",
        storageBucket: "math-braves.firebasestorage.app",
        messagingSenderId: "217117619290",
        appId: "1:217117619290:web:d227feb603970d3948d463"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    const COLLECTION_NAME = 'scores_math_braves_decimal';

    /* =========================================
       NG Word List (ÁúÅÁï•„Å™„Åó)
    ========================================= */
    const NG_WORDS_HIRAGANA = [
        '„Åó„Å≠', '„Åó„Å¨', '„Åó„Å´', '„Åì„Çç„Åô', '„Åì„Çç„Åõ', '„Åï„Å§„Åå„ÅÑ', '„Åè„Åü„Å∞„Çå', '„Åò„Åï„Å§', '„Åé„Åï„Å§', '„Å§„Çã„Åô', '„Çå„Çì„Åü„Çì', '„Åó„Å´„Åü„ÅÑ',
        '„Å¶„Çç', '„Å¶„Çç„Çä„Åô„Å®', '„Å∞„Åè„ÅØ', '„Å∞„Åè„Å†„Çì', '„Åª„ÅÜ„Åã', '„ÅØ„Çì„Åñ„ÅÑ', '„Åî„ÅÜ„Å®„ÅÜ', '„ÇÜ„ÅÜ„Åã„ÅÑ', '„Åã„Çì„Åç„Çì', '„Åä„Åù„ÅÜ', '„ÇÑ„Åè„Åñ', '„Åº„ÅÜ„Çä„Çá„Åè',
        '„ÅØ„Çì„Åê„Çå', '„Å°„Çì„Å¥„Çâ', '„Åæ„Åµ„ÅÉ„ÅÇ', '„Åü„ÅÑ„Åæ', '„Åæ„ÇÑ„Åè', '„Åã„Åè„Åõ„ÅÑ„Åñ„ÅÑ', '„Åó„ÇÉ„Å∂', '„Å©„Çâ„Å£„Åê', '„Åì„Åã„ÅÑ„Çì', '„Å∏„Çç„ÅÑ„Çì', '„Åà„Åè„Åô„Åü„Åó„Éº',
        '„Å†„Å£„ÅΩ„ÅÜ', '„Åç„ÇÅ„Åõ„Åè', '„ÅÑ„Åò„ÇÅ', '„Åé„ÇÉ„Åè„Åü„ÅÑ', '„Å∞„Åã', '„ÅÇ„Åª', '„Åæ„Å¨„Åë', '„Åç„Å°„Åå„ÅÑ', '„ÅçÈÅï„ÅÑ', '„ÅÜ„Åñ„ÅÑ', '„ÅÜ„Åñ', '„Åç„ÇÇ„ÅÑ', '„Åç„ÇÇ',
        '„Åç„Åó„Çá„ÅÑ', '„Åç„Åà„Çç', '„Åè„Åö', '„Åî„Åø', '„Åî„Åø„ÇÄ„Åó', '„Åã„Åô', '„Åñ„Åì', '„Åú„Å§', '„Å∂„Åô', '„Åß„Å∂', '„ÅØ„Åí', '„Å°„Å≥', '„Åß„Å£„Å±', '„ÅÑ„Å™„Åã„ÇÇ„ÅÆ',
        '„ÅÜ„Åò', '„ÅØ„ÅÑ„Åº„Åè', '„Åæ„Åë„ÅÑ„Å¨', '„Åä„Å§„ÇÄ', '„ÅÆ„ÅÜ„Åü„Çä„Çì', '„Å¶„ÅÑ„ÅÆ„ÅÜ', '„Å°„Åó„Çá„ÅÜ', '„Åó„Çá„ÅÜ„Åå„ÅÑ', '„Åå„ÅÑ„Åò', '„Åã„Åü„Çè', '„Å≥„Å£„Åì', '„ÇÅ„Åè„Çâ',
        '„Å§„Çì„Åº', '„Åä„Åó', '„Å©„Åò„Çì', '„Åà„Åü', '„Å≤„Å´„Çì', '„Åü„Å≤', '„Åü„Å≤„Å≠', '„ÅÜ„Åõ„Çç', '„Å†„Åæ„Çå', '„Å°„Çì„Å°„Çì', '„Å°„Çì„Åì', '„Å°„Çì„ÅΩ', '„Å°„Çì„Åã',
        '„Åæ„Çâ', '„Åï„Åä', '„Åæ„Çì„Åì', '„Åæ„Çì„Åó„ÇÖ„ÅÜ', '„Åæ„Çì„Åí', '„Çè„Çå„ÇÅ', '„Åä„Åæ„Åü', '„Åè„Çä', '„Åè„Çä„Å®„Çä„Åô', '„ÅÑ„Çì„Åó„Çì', '„ÅÑ„Çì„Åã„Åè', '„Å≥„Çâ„Å≥„Çâ',
        '„Åì„ÅÜ„Åå„Çì', '„Åü„Åæ„Åç„Çì', '„Åç„Çì„Åü„Åæ', '„Åµ„Åê„Çä', '„Åä„Å£„Å±„ÅÑ', '„Å°„Å°', '„Å´„ÇÖ„ÅÜ„Çä„Çì', '„Å´„ÇÖ„ÅÜ„Å®„ÅÜ', '„Åç„Çá„Å´„ÇÖ„ÅÜ', '„Å≤„Çì„Å´„ÇÖ„ÅÜ',
        '„Åë„Å§', '„ÅÇ„Å™„Çã', '„Åì„ÅÜ„ÇÇ„Çì', '„Åë„Å§„ÅÆ„ÅÇ„Å™', '„Åà„Çç', '„Åà„Å£„Å°', '„Åô„Åë„Åπ', '„Å∏„Çì„Åü„ÅÑ', '„ÇÄ„Å£„Å§„Çä', '„Åó„Åì', '„Åõ„Å£„Åè„Åô', '„Åõ„ÅÑ„Åì„ÅÜ',
        '„Åæ„Åê„Çè„ÅÑ', '„Åù„ÅÜ„Å´„ÇÖ„ÅÜ', '„ÅØ„ÇÅ„Çã', '„Åä„Å™„Å´„Éº', '„Åò„ÅÑ', '„Åó„Åì„Åó„Åì', '„Åµ„Åá„Çâ', '„Å±„ÅÑ„Åö„Çä', '„Åè„Çì„Å´', '„ÅÑ„Çâ„Åæ', '„Åó„Å£„Åó„Çì', '„Å™„Åã„Å†„Åó',
        '„Åî„Å£„Åè„Çì', '„Å∂„Å£„Åã„Åë', '„Åó„Åä„Åµ„Åç', '„Åú„Å£„Å°„Çá„ÅÜ', '„ÅÑ„Åè', '„ÅÑ„Åã„Åõ„Çç', '„ÅÇ„Åà„Åé', '„Å©„ÅÜ„Å¶„ÅÑ', '„Åó„Çá„Åò„Çá', '„ÇÑ„Çä„Åæ„Çì', '„ÇÑ„Çä„Å°„Çì',
        '„Å≥„Å£„Å°', '„Åõ„Åµ„Çå', '„Å±„Åì', '„Å±„Åì„Å±„Åì', '„Çè„ÅÑ„Åõ„Å§', '„Çç„Çä', '„Åó„Çá„Åü', '„Å∫„Å©', '„Åç„Çì„Åó„Çì', '„Åò„ÇÖ„ÅÜ„Åã„Çì', '„Çä„Çá„ÅÜ„Åò„Çá„Åè', '„Çâ„Çì„Åì„ÅÜ',
        '„Åô„Åã„Çì„Å®', '„ÅÆ„Éº„Å±„Çì', '„Å±„Çì„Å°„Çâ', '„Çå„ÅÑ„Å∑', '„Åî„ÅÜ„Åã„Çì', '„Å°„Åã„Çì', '„Å®„ÅÜ„Åï„Å§', '„ÅÆ„Åû„Åç', '„Çç„Åó„ÇÖ„Å§', '„Åµ„ÅÜ„Åû„Åè', '„Åù„Éº„Å∑',
        '„Å∏„Çã„Åô', '„Åß„Çä„Å∏„Çã', '„Å¥„Çì„Åï„Çç', '„ÅÑ„ÇÅ„Åè„Çâ', '„ÅÇ„Å†„Çã„Å®', '„Åà„Éº„Å∂„ÅÑ', '„Åà„Å∂„ÅÑ', '„ÅΩ„Çã„ÅÆ', '„ÅÜ„Çâ„Å≥„Åß„Åä', '„ÇÄ„Åó„ÇÖ„ÅÜ„Åõ„ÅÑ', '„Åà„Çì„Åì„ÅÜ',
        '„Åà„Çì„Åò„Çá', '„ÅÜ„Çä', '„Åã„ÅÑ„Åó„ÇÖ„Çì', '„Å∞„ÅÑ„Åó„ÇÖ„Çì', '„Å±„Å±„Åã„Å§', '„Åæ„Åæ„Åã„Å§', '„ÅÜ„Çä„Åõ„Çì', '„ÅÜ„Çì„Åì', '„ÅÜ„Çì„Å°', '„Åè„Åù', '„Åí„Çä', '„Åπ„Çì',
        '„Åµ„Çì', '„Åó„Å£„Åì', '„Åó„Çá„Çì„Åπ„Çì', '„Å´„Çá„ÅÜ', '„Åª„ÅÜ„Å´„Çá„ÅÜ', '„Å∏', '„Åä„Å™„Çâ', '„Åí„Çç', '„Åü„Çì', '„ÅÜ„Çì„Åà„ÅÑ', '„Åì„ÅÜ„Åó„Åç', '„Åô„Åü„Å£„Åµ',
        '„Åã„Çì„Çä', '„Å±„Å®„Çç„Éº„Çã', '„Åò„Åà„ÇÄ', '„Åí„Éº„ÇÄ„Åæ„Åô„Åü„Éº', '„Åæ„Åô„Åü„Éº', '„ÅÇ„Å©„Åø„Çì', '„Åó„Åô„Å¶„ÇÄ', '„Åï„Éº„Å∞„Éº', '„ÅÇ„Åã„Å∞„Çì', '„Å∞„Çì', '„Å°„Éº„Å®',
        '„Å°„Éº„Åü„Éº', '„Å∞„Åê', '„Çâ„ÅÑ„Çì', '„Åã„Åã„Åä', '„Åô„Åã„ÅÑ„Å∑', '„ÅÑ„Çì„Åô„Åü', '„Å§„ÅÑ„Å£„Åü„Éº', '„Åß„ÅÉ„Åô„Åì', '„Åß„Çì„Çè', '„Å∞„Çì„Åî„ÅÜ', '„Åë„ÅÑ„Åü„ÅÑ',
        '„ÅÇ„Å©„Çå„Åô', '„ÇÅ„ÅÇ„Å©', '„Åò„ÇÖ„ÅÜ„Åó„Çá', '„ÅÇ„Åä', '„ÅÇ„ÅÑ„Åü„ÅÑ', '„Åæ„Å°„ÅÇ„Çè„Åõ', '„Åª„Å¶„Çã', '„Çâ„Å∂„Åª', '„Åä„Åµ„Åã„ÅÑ', '„Å±„Åô„Çè„Éº„Å©', '„Å±„Åô',
        '„ÅÇ„Åã„ÅÜ„Çì„Å®', '„Åì„Åò„Çì„Åò„Çá„ÅÜ„Åª„ÅÜ'
    ];

    /* =========================================
       Scaling & Canvas Setup
    ========================================= */
    const wrapper = document.getElementById('game-wrapper');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_W = 1280;
    const GAME_H = 720;
    let currentScale = 1;

    const FONT_FAMILY = "'M PLUS Rounded 1c', sans-serif";

    function resizeWindow() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        currentScale = Math.min(winW / GAME_W, winH / GAME_H);
        wrapper.style.transform = `translate(-50%, -50%) scale(${currentScale})`;
    }
    window.addEventListener('resize', resizeWindow);
    resizeWindow();

    /* =========================================
       Assets & Globals
    ========================================= */
    const titleImg = new Image();
    titleImg.src = 'images/title.png';
    titleImg.onload = () => { if(appState === 'TITLE') setScreenBackgrounds(); };

    const ALL_SNACKS = ['üç©', 'üéÇ', 'üç´', 'üç≠', 'üçπ', 'üç∏', 'üç™', 'üç®', 'üçß', 'üç¶', 'ü•ê', 'ü•û'];
    
    const TITLE_BTN = { x: 1040, y: 20, w: 200, h: 50 }; 
    const HOWTO_BTN = { x: 40,   y: 20, w: 200, h: 50 };
    const GEM_BTN   = { x: 55,   y: 605, w: 250, h: 60 }; 

    let appState = 'TITLE'; 
    let isHowToPlayActive = false; 
    let pendingJokerIndex = -1;
    let jokerCurrentVal = 1.0;
    
    let players = JSON.parse(localStorage.getItem('math_braves_players')) || [];
    let currentPlayer = players.length > 0 ? players[0].name : "„Ç≤„Çπ„Éà";

    let gameState = {
        difficulty: '',
        stage: 1,
        maxStage: 7,
        maxHp: 3.0,
        hp: 3.0,
        score: 0,
        gems: 0,
        snacksCollected: [],
        availableSnacks: [...ALL_SNACKS],
        ribbonValue: 0.0,
        displayRibbonValue: 0.0,
        targetRibbonValue: 0.0,
        isAnimating: false,
        cards: [],
        events: [],
        particles: []
    };

    let messageQueue = [];
    let gameMessage = { active: false, lines: [], callback: null };

    let draggingCardIndex = -1;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let mouseX = 0;
    let mouseY = 0;

    let animationId = null;

    /* =========================================
       Utility Functions
    ========================================= */
    function floatAdd(a, b) { return Math.round((a + b) * 10) / 10; }
    function floatSub(a, b) { return Math.round((a - b) * 10) / 10; }
    function randFloat(min, max) { return Math.round((Math.random() * (max - min) + min) * 10) / 10; }
    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

    /* =========================================
       UI & Screens
    ========================================= */
    function setScreenBackgrounds() {
        const bgs = document.querySelectorAll('.ui-layer');
        bgs.forEach(bg => {
            if(titleImg.complete && titleImg.naturalWidth !== 0) {
                bg.style.backgroundImage = `url('images/title.png')`;
                bg.style.backgroundColor = 'transparent';
                bg.style.backgroundBlendMode = 'normal';
            }
        });
    }

    function showScreen(screenId) {
        document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
        if(screenId) document.getElementById(screenId).classList.remove('hidden');
        if(screenId === 'screen-title') {
            appState = 'TITLE';
            updateCurrentPlayerDisplay();
            setScreenBackgrounds();
            ctx.clearRect(0, 0, GAME_W, GAME_H); 
        } else if (screenId === 'screen-player') {
            renderPlayerList();
        }
    }

    function systemAlert(msg) {
        document.getElementById('popup-message').innerHTML = msg.replace(/\n/g, '<br>');
        document.getElementById('custom-popup').classList.remove('hidden');
    }
    function closePopup() {
        document.getElementById('custom-popup').classList.add('hidden');
    }

    /* =========================================
       Player Management & Auth
    ========================================= */
    function updateCurrentPlayerDisplay() {
        document.getElementById('current-player-display').innerText = `ÁèæÂú®„ÅÆ„Éó„É¨„Éº„É§„Éº: ${currentPlayer}`;
    }

    function renderPlayerList() {
        const container = document.getElementById('player-list-container');
        container.innerHTML = '';
        players.forEach((p, index) => {
            const div = document.createElement('div');
            div.className = `player-item ${p.name === currentPlayer ? 'selected' : ''}`;
            div.innerHTML = `<span>${p.name}</span> <button class="menu-btn red" style="width:auto; padding:6px 12px; font-size:18px; margin:0;" onclick="deletePlayer(${index}, event)">ÂâäÈô§</button>`;
            div.onclick = () => selectPlayer(index);
            container.appendChild(div);
        });
        document.getElementById('btn-player-back').innerText = "ÈÅ∏Êäû„Åó„Å¶Êàª„Çã";
    }

    function registerPlayer() {
        if(players.length >= 5) { systemAlert('ÁôªÈå≤„Åß„Åç„Çã„ÅÆ„ÅØ5Âêç„Åæ„Åß„Åß„Åô„ÄÇ'); return; }
        const input = document.getElementById('new-player-name').value.trim();
        if(!input) return;
        if(!/^[„ÅÅ-„Çì„Éº]+$/.test(input)) { systemAlert('„Å≤„Çâ„Åå„Å™„Å®„Äå„Éº„Äç„ÅÆ„Åø‰Ωø„Åà„Åæ„Åô„ÄÇ'); return; }
        for(let word of NG_WORDS_HIRAGANA) {
            if(input.includes(word)) { systemAlert('„Åì„ÅÆ„Å™„Åæ„Åà„ÅØÁôªÈå≤„Åß„Åç„Åæ„Åõ„Çì„ÄÇ'); return; }
        }
        if(players.some(p => p.name === input)) { systemAlert('„Åô„Åß„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ'); return; }

        players.push({ name: input });
        localStorage.setItem('math_braves_players', JSON.stringify(players));
        currentPlayer = input;
        document.getElementById('new-player-name').value = '';
        renderPlayerList();
    }

    function selectPlayer(index) { currentPlayer = players[index].name; renderPlayerList(); }

    function deletePlayer(index, event) {
        event.stopPropagation();
        if(players[index].name === currentPlayer) currentPlayer = "„Ç≤„Çπ„Éà";
        players.splice(index, 1);
        localStorage.setItem('math_braves_players', JSON.stringify(players));
        if(players.length > 0 && currentPlayer === "„Ç≤„Çπ„Éà") currentPlayer = players[0].name;
        renderPlayerList();
    }

    function loginGoogle() {
        const provider = new firebase.auth.GoogleAuthProvider();
        auth.signInWithPopup(provider).then((result) => {
            systemAlert(`Google„Ç¢„Ç´„Ç¶„É≥„ÉàÈÄ£Êê∫ÂÆå‰∫ÜÔºÅ\n‚Äª„É©„É≥„Ç≠„É≥„Ç∞ÈÄÅ‰ø°ÊôÇ„ÅØÈÅ∏Êäû‰∏≠„ÅÆ„Éó„É¨„Éº„É§„ÉºÂêç(${currentPlayer})„Åå‰ΩøÁî®„Åï„Çå„Åæ„Åô„ÄÇ`);
        }).catch((error) => {
            systemAlert("„É≠„Ç∞„Ç§„É≥„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
        });
    }

    /* =========================================
       Ranking
    ========================================= */
    let currentRankTab = 'world';
    let currentRankDiff = '„Åµ„Å§„ÅÜ';

    function showRanking() { showScreen('screen-ranking'); loadRanking(); }
    function switchRankTab(tab) {
        currentRankTab = tab;
        document.querySelectorAll('#screen-ranking .tabs:nth-child(2) .tab-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`tab-${tab}`).classList.add('active');
        loadRanking();
    }
    function switchRankDiff(diff) {
        currentRankDiff = diff;
        const diffMap = {'„ÇÑ„Åï„Åó„ÅÑ':'easy', '„Åµ„Å§„ÅÜ':'normal', '„ÇÄ„Åö„Åã„Åó„ÅÑ':'hard'};
        document.querySelectorAll('#screen-ranking .tabs:nth-child(3) .tab-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`tab-${diffMap[diff]}`).classList.add('active');
        loadRanking();
    }

    function loadRanking() {
        const tbody = document.getElementById('ranking-body');
        tbody.innerHTML = '';
        document.getElementById('ranking-loading').style.display = 'block';

        if(currentRankTab === 'local') {
            document.getElementById('ranking-loading').style.display = 'none';
            let localScores = JSON.parse(localStorage.getItem('math_braves_scores')) || [];
            localScores = localScores.filter(s => s.difficulty === currentRankDiff);
            localScores.sort((a,b) => b.clearedStages - a.clearedStages || b.score - a.score || b.remainingHP - a.remainingHP);
            renderRankingTable(localScores.slice(0, 10));
        } else {
            db.collection(COLLECTION_NAME).where("difficulty", "==", currentRankDiff).get().then(snap => {
                let data = [];
                snap.forEach(doc => data.push(doc.data()));
                data.sort((a,b) => b.clearedStages - a.clearedStages || b.score - a.score || b.remainingHP - a.remainingHP);
                document.getElementById('ranking-loading').style.display = 'none';
                renderRankingTable(data.slice(0, 10));
            }).catch(err => {
                document.getElementById('ranking-loading').style.display = 'none';
                systemAlert("„É©„É≥„Ç≠„É≥„Ç∞„ÅÆÂèñÂæó„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
            });
        }
    }

    function renderRankingTable(data) {
        const tbody = document.getElementById('ranking-body');
        tbody.innerHTML = '';
        if(data.length === 0) { tbody.innerHTML = '<tr><td colspan="5">„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</td></tr>'; return; }
        data.forEach((d, i) => {
            tbody.innerHTML += `<tr><td>${i+1}</td><td>${d.playerName}</td><td>${d.clearedStages}</td><td>${d.score}</td><td>${d.remainingHP.toFixed(1)}</td></tr>`;
        });
    }

    function saveScore(cleared) {
        const scoreData = {
            playerName: currentPlayer,
            difficulty: gameState.difficulty,
            clearedStages: cleared ? gameState.stage : gameState.stage - 1,
            score: gameState.score,
            remainingHP: Math.max(0, gameState.hp),
            timestamp: new Date().getTime()
        };
        let local = JSON.parse(localStorage.getItem('math_braves_scores')) || [];
        local.push(scoreData);
        localStorage.setItem('math_braves_scores', JSON.stringify(local));

        if(auth.currentUser) {
            scoreData.timestamp = firebase.firestore.FieldValue.serverTimestamp();
            db.collection(COLLECTION_NAME).add(scoreData);
        }
    }

    /* =========================================
       In-Game Message Logic
    ========================================= */
    function showGameMessage(text, callback = null) {
        messageQueue.push({ text, callback });
        if(!gameMessage.active) advanceMessage();
    }

    function advanceMessage() {
        if(messageQueue.length > 0) {
            let msg = messageQueue.shift();
            gameMessage.active = true;
            gameMessage.lines = msg.text.split('\n');
            gameMessage.callback = msg.callback;
        } else {
            gameMessage.active = false;
            checkStageClear();
        }
    }

    /* =========================================
       Game Initialization & Flow
    ========================================= */
    function goToDifficulty() {
        if(currentPlayer === "„Ç≤„Çπ„Éà") systemAlert("„Éó„É¨„Éº„É§„Éº„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n„Äå„Ç≤„Çπ„Éà„Äç„Å®„Åó„Å¶„Éó„É¨„Ç§„Åó„Åæ„Åô„ÄÇ");
        showScreen('screen-difficulty');
    }

    function startGame(diff) {
        showScreen('');
        appState = 'PLAYING';
        isHowToPlayActive = false;
        pendingJokerIndex = -1;
        let initHp = diff === '„ÇÑ„Åï„Åó„ÅÑ' ? 3.0 : (diff === '„Åµ„Å§„ÅÜ' ? 2.0 : 1.0);
        
        gameState = {
            difficulty: diff, stage: 1, maxStage: 7, maxHp: initHp, hp: initHp,
            score: 0, gems: 0, snacksCollected: [], availableSnacks: [...ALL_SNACKS],
            ribbonValue: 0.0, displayRibbonValue: 0.0, targetRibbonValue: 0.0,
            isAnimating: false, cards: [], events: [], particles: []
        };
        
        messageQueue = []; gameMessage.active = false;
        initStage();
        if(!animationId) requestAnimationFrame(gameLoop);
    }

    function generateCard() {
        let isJoker = Math.random() < 0.02; // 2%„ÅÆÁ¢∫Áéá
        let val = isJoker ? 'üÉè' : randFloat(0.1, 2.0);
        return { value: val, isJoker: isJoker, sealedTurns: 0, x: 0, y: 0, targetX: 0, targetY: 0, isDragging: false };
    }

    function getCardBasePosition(index) {
        const startX = 346, gap = 120; 
        return { x: startX + index * gap, y: 530 };
    }

    function initStage() {
        gameState.ribbonValue = 0.0;
        gameState.displayRibbonValue = 0.0;
        gameState.targetRibbonValue = 0.0;
        
        if(gameState.stage === 1) {
            gameState.cards = [];
            for(let i=0; i<5; i++) {
                let c = generateCard();
                let pos = getCardBasePosition(i);
                c.x = pos.x; c.y = pos.y + 200; 
                c.targetX = pos.x; c.targetY = pos.y;
                gameState.cards.push(c);
            }
        } else {
            gameState.cards.forEach((c, i) => {
                let pos = getCardBasePosition(i);
                c.targetX = pos.x; c.targetY = pos.y;
            });
        }

        gameState.events = [];
        const zones = [
            { start: 0.0, end: 0.9 }, { start: 1.0, end: 1.9 }, { start: 2.0, end: 2.9 },
            { start: 3.0, end: 3.9 }, { start: 4.0, end: 4.9 }
        ];

        let stageAvailableSnacks = [...gameState.availableSnacks];

        zones.forEach(z => {
            let r = Math.random();
            let hasSnack = stageAvailableSnacks.length > 0;
            let type = ''; let subType = ''; let icon = '';
            
            if(hasSnack) {
                if(r < 0.2) type = 'enemy';
                else if(r < 0.4) type = 'gold';
                else if(r < 0.6) type = 'gem';
                else type = 'snack';
            } else {
                if(r < 0.333) type = 'enemy';
                else if(r < 0.666) type = 'gold';
                else type = 'gem';
            }

            if (type === 'gold') {
                if (Math.random() < 0.1) { subType = 'mega_gold'; icon = 'üí∞'; }
                else { subType = 'normal_gold'; icon = 'ü™ô'; }
            } else if (type === 'enemy') {
                if (Math.random() < 0.1) { subType = 'dragon'; icon = 'üê≤'; }
                else { subType = 'normal_enemy'; icon = 'üëæ'; }
            } else if (type === 'gem') {
                icon = 'üíé';
            } else if (type === 'snack') {
                let idx = randInt(0, stageAvailableSnacks.length - 1);
                icon = stageAvailableSnacks[idx];
                stageAvailableSnacks.splice(idx, 1);
            }

            let width = type === 'enemy' ? 0.9 : (type === 'snack' ? 0.2 : 0.4);
            let sInt = Math.round(z.start * 10);
            let eInt = Math.round(z.end * 10);
            let wInt = Math.round(width * 10);
            let maxStartInt = eInt - wInt;
            let startPosInt = randInt(sInt, maxStartInt);
            
            gameState.events.push({
                type: type, subType: subType, icon: icon,
                start: startPosInt / 10, end: (startPosInt + wInt) / 10,
                triggered: false, cleared: false
            });
        });
    }

    /* =========================================
       Game Logic Updates
    ========================================= */
    function confirmChangeHand() {
        document.getElementById('change-popup').classList.add('hidden');
        useGemForHand();
    }
    
    function confirmChangeField() {
        document.getElementById('change-popup').classList.add('hidden');
        useGemForField();
    }

    function cancelChange() {
        document.getElementById('change-popup').classList.add('hidden');
    }

    function useGemForHand() {
        if(gameState.gems <= 0) return;
        gameState.gems--;
        gameState.cards.forEach(c => {
            if(c.sealedTurns === 0) {
                let isJoker = Math.random() < 0.02;
                c.value = isJoker ? 'üÉè' : randFloat(0.1, 2.0);
                c.isJoker = isJoker;
                createParticles(c.x + 54, c.y + 72, '#81D4FA', 15);
            }
        });
    }

    function useGemForField() {
        if(gameState.gems <= 0) return;
        gameState.gems--;
        
        let currentVal = gameState.displayRibbonValue;
        let startReRollIndex = (currentVal === 0) ? 0 : Math.floor(currentVal) + 1;
        
        let newEvents = [];
        gameState.events.forEach(ev => {
            let zoneIdx = Math.floor(ev.start);
            if (zoneIdx < startReRollIndex) {
                newEvents.push(ev);
            }
        });
        
        const zones = [
            { start: 0.0, end: 0.9 }, { start: 1.0, end: 1.9 }, { start: 2.0, end: 2.9 },
            { start: 3.0, end: 3.9 }, { start: 4.0, end: 4.9 }
        ];
        
        let stageAvailableSnacks = [...gameState.availableSnacks];
        for (let i = startReRollIndex; i < 5; i++) {
            let z = zones[i];
            let r = Math.random();
            let hasSnack = stageAvailableSnacks.length > 0;
            let type = ''; let subType = ''; let icon = '';
            
            if(hasSnack) {
                if(r < 0.2) type = 'enemy';
                else if(r < 0.4) type = 'gold';
                else if(r < 0.6) type = 'gem';
                else type = 'snack';
            } else {
                if(r < 0.333) type = 'enemy';
                else if(r < 0.666) type = 'gold';
                else type = 'gem';
            }

            if (type === 'gold') {
                if (Math.random() < 0.1) { subType = 'mega_gold'; icon = 'üí∞'; }
                else { subType = 'normal_gold'; icon = 'ü™ô'; }
            } else if (type === 'enemy') {
                if (Math.random() < 0.1) { subType = 'dragon'; icon = 'üê≤'; }
                else { subType = 'normal_enemy'; icon = 'üëæ'; }
            } else if (type === 'gem') {
                icon = 'üíé';
            } else if (type === 'snack') {
                let idx = randInt(0, stageAvailableSnacks.length - 1);
                icon = stageAvailableSnacks[idx];
                stageAvailableSnacks.splice(idx, 1);
            }

            let width = type === 'enemy' ? 0.9 : (type === 'snack' ? 0.2 : 0.4);
            let sInt = Math.round(z.start * 10);
            let eInt = Math.round(z.end * 10);
            let wInt = Math.round(width * 10);
            let maxStartInt = eInt - wInt;
            let startPosInt = randInt(sInt, maxStartInt);
            
            newEvents.push({
                type: type, subType: subType, icon: icon,
                start: startPosInt / 10, end: (startPosInt + wInt) / 10,
                triggered: false, cleared: false
            });
        }
        gameState.events = newEvents;
        
        createParticles(640, 240, '#A5D6A7', 60);
    }

    function processDrop(cardIndex) {
        let c = gameState.cards[cardIndex];
        if(c.isJoker) {
            pendingJokerIndex = cardIndex;
            jokerCurrentVal = 1.0;
            document.getElementById('joker-display-val').innerText = '1.0';
            document.getElementById('joker-popup').classList.remove('hidden');
            return;
        }
        applyCardValue(cardIndex, c.value);
    }

    function applyCardValue(cardIndex, value) {
        let c = gameState.cards[cardIndex];
        let oldVal = gameState.ribbonValue;
        let newVal = floatAdd(oldVal, value);
        
        gameState.ribbonValue = newVal;
        gameState.targetRibbonValue = newVal;
        gameState.isAnimating = true;

        gameState.cards.forEach(card => {
            if(card.sealedTurns > 0) card.sealedTurns--;
        });

        let isJoker = Math.random() < 0.02;
        c.value = isJoker ? 'üÉè' : randFloat(0.1, 2.0);
        c.isJoker = isJoker;
        c.sealedTurns = 0;
        let base = getCardBasePosition(cardIndex);
        c.x = base.x; c.y = base.y - 150;
        c.targetX = base.x; c.targetY = base.y;
    }

    function changeJokerVal(delta) {
        jokerCurrentVal = Math.round((jokerCurrentVal + delta) * 10) / 10;
        if(jokerCurrentVal < 0.1) jokerCurrentVal = 0.1;
        if(jokerCurrentVal > 2.0) jokerCurrentVal = 2.0;
        document.getElementById('joker-display-val').innerText = jokerCurrentVal.toFixed(1);
    }

    function decideJoker() {
        document.getElementById('joker-popup').classList.add('hidden');
        applyCardValue(pendingJokerIndex, jokerCurrentVal);
        pendingJokerIndex = -1;
    }

    function cancelJoker() {
        document.getElementById('joker-popup').classList.add('hidden');
        let c = gameState.cards[pendingJokerIndex];
        let base = getCardBasePosition(pendingJokerIndex);
        c.targetX = base.x; c.targetY = base.y;
        pendingJokerIndex = -1;
    }

    function checkEvents() {
        let newVal = gameState.ribbonValue;
        let triggeredEv = null;

        gameState.events.forEach(ev => {
            if(!ev.triggered && newVal >= ev.start && newVal <= ev.end) {
                ev.triggered = true; triggeredEv = ev;
            }
        });

        if(triggeredEv) triggerEvent(triggeredEv);

        if(newVal % 1 === 0 && newVal > 0 && newVal <= 4) {
            let bonus = newVal * 200;
            gameState.score += bonus;
            createParticles(640, 390, '#FFD700', 50);
            showGameMessage(`‚ú®„Å¥„Å£„Åü„Çä„Éú„Éº„Éä„ÇπÔºÅ‚ú®\n${newVal}.0 „Å´Ê≠¢„Åæ„Å£„Åü„ÅÆ„Åß\n${bonus}ÁÇπ GETÔºÅ`);
        }

        if(messageQueue.length === 0 && !gameMessage.active) checkStageClear();
    }

    function triggerEvent(ev) {
        let px = 640, py = 390;
        if(ev.type === 'gold') {
            let pts = ev.subType === 'mega_gold' ? 1500 : 500;
            gameState.score += pts;
            createParticles(px, py, '#FFF59D', 40);
            showGameMessage(`${ev.icon}Ë≤°ÂÆù„ÇíÁô∫Ë¶ãÔºÅ\n„Çπ„Ç≥„Ç¢„Åå ${pts} Â¢ó„Åà„ÅüÔºÅ`, () => { ev.cleared = true; });
        } else if (ev.type === 'gem') {
            gameState.gems++;
            createParticles(px, py, '#81D4FA', 40);
            showGameMessage(`${ev.icon}„ÉÄ„Ç§„É§„ÇíÁô∫Ë¶ãÔºÅ\n„ÅäÂä©„Åë„Ç¢„Ç§„ÉÜ„É†„Çí 1ÂÄã GETÔºÅ`, () => { ev.cleared = true; });
        } else if (ev.type === 'snack') {
            gameState.snacksCollected.push(ev.icon);
            gameState.availableSnacks = gameState.availableSnacks.filter(s => s !== ev.icon);
            createParticles(px, py, '#F48FB1', 40);
            
            let msg = `üç∞„Åä„Åã„Åó„ÇíÁô∫Ë¶ãÔºÅ\n${ev.icon} „Çí GETÔºÅ`;
            if (gameState.snacksCollected.length === 12) {
                msg += `\n\n„Åô„Åî„ÅÑÔºÅ„Åä„Åã„Åó„Çí„Åú„Çì„Å∂ÈõÜ„ÇÅ„ÅüÔºÅÔºÅ\n${ALL_SNACKS.join('')}`;
            }
            showGameMessage(msg, () => { ev.cleared = true; });
            
        } else if (ev.type === 'enemy') {
            createParticles(px, py, '#E57373', 50);
            let unsealed = gameState.cards.filter(c => c.sealedTurns === 0);
            
            if(ev.subType === 'dragon') {
                let sealCount = Math.min(2, unsealed.length);
                for(let i=0; i<sealCount; i++) {
                    let idx = randInt(0, unsealed.length - 1);
                    unsealed[idx].sealedTurns = 5;
                    unsealed.splice(idx, 1);
                }
                if(gameState.cards.filter(c => c.sealedTurns > 0).length === 5) {
                    appState = 'GAMEOVER_WAIT';
                    showGameMessage(`üê≤„Éâ„É©„Ç¥„É≥„ÅÆÊîªÊíÉÔºÅ\n„Åô„Åπ„Å¶„ÅÆ„Ç´„Éº„Éâ„Åå\nÂ∞ÅÂç∞„Åï„Çå„Å¶„Åó„Åæ„Å£„Åü...`, () => { 
                        ev.cleared = true; processGameOver();
                    });
                } else {
                    showGameMessage(`üê≤„Éâ„É©„Ç¥„É≥„ÅÆÊîªÊíÉÔºÅ\n„Ç´„Éº„Éâ„Åå${sealCount}ÊûöÂ∞ÅÂç∞„Åï„Çå„ÅüÔºÅ`, () => { ev.cleared = true; });
                }
            } else {
                if(unsealed.length > 0) {
                    let target = unsealed[randInt(0, unsealed.length - 1)];
                    target.sealedTurns = 5;
                    if(gameState.cards.filter(c => c.sealedTurns > 0).length === 5) {
                        appState = 'GAMEOVER_WAIT';
                        showGameMessage(`üëæÊïµ„ÅÆÊîªÊíÉÔºÅ\n„Åô„Åπ„Å¶„ÅÆ„Ç´„Éº„Éâ„Åå\nÂ∞ÅÂç∞„Åï„Çå„Å¶„Åó„Åæ„Å£„Åü...`, () => { 
                            ev.cleared = true; processGameOver();
                        });
                    } else {
                        showGameMessage(`üëæÊïµ„ÅÆÊîªÊíÉÔºÅ\n„Ç´„Éº„Éâ„Åå1ÊûöÂ∞ÅÂç∞„Åï„Çå„ÅüÔºÅ`, () => { ev.cleared = true; });
                    }
                } else {
                    showGameMessage(`üëæÊïµ„ÅÆÊîªÊíÉÔºÅ\n„Åó„Åã„ÅóÂ∞ÅÂç∞„Åß„Åç„Çã„Ç´„Éº„Éâ„Åå„Å™„ÅÑÔºÅ`, () => { ev.cleared = true; });
                }
            }
        }
    }

    function checkStageClear() {
        let finalVal = gameState.ribbonValue;
        if(finalVal >= 5.0) {
            if(finalVal === 5.0) {
                gameState.score += 1000;
                showGameMessage("üéâ„Ç∏„É£„Çπ„Éà 5.0 ÈÅîÊàêÔºÅüéâ\n„Éú„Éº„Éä„Çπ 1000ÁÇπ GETÔºÅ\n„ÉÄ„É°„Éº„Ç∏ 0 „Åß„ÇØ„É™„Ç¢ÔºÅ", nextStage);
            } else {
                let dmg = floatSub(finalVal, 5.0);
                gameState.hp = floatSub(gameState.hp, dmg);
                if(gameState.hp <= 0) {
                    appState = 'GAMEOVER_WAIT';
                    showGameMessage(`HP„Åå0„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ\n5.0„Çí ${dmg.toFixed(1)} „Ç™„Éº„Éê„Éº„Åó„Åæ„Åó„Åü...`, () => {
                        processGameOver();
                    });
                } else {
                    showGameMessage(`üö©„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢ÔºÅüö©\n5.0„Çí ${dmg.toFixed(1)} „Ç™„Éº„Éê„Éº„Åó„Åü„Åü„ÇÅ„ÄÅ\nHP„Åå ${dmg.toFixed(1)} Ê∏õ„Çä„Åæ„Åó„Åü„ÄÇ`, nextStage);
                }
            }
        }
    }

    function nextStage() {
        if(gameState.stage >= gameState.maxStage) { processGameClear(); } 
        else { gameState.stage++; initStage(); }
    }

    function processGameClear() {
        appState = 'RESULT';
        let snackCount = gameState.snacksCollected.length;
        let snackBonus = snackCount * snackCount * 200;
        let hpBonus = Math.floor(10000 * (Math.max(0, gameState.hp) / gameState.maxHp));
        let totalScore = gameState.score + snackBonus + hpBonus;
        
        gameState.score = totalScore;
        saveScore(true);
        
        showResultScreen('„Ç≤„Éº„É†„ÇØ„É™„Ç¢ÔºÅ', '#4CAF50', gameState.score - snackBonus - hpBonus, snackBonus, hpBonus, totalScore);
    }

    function processGameOver() {
        appState = 'RESULT';
        let snackCount = gameState.snacksCollected.length;
        let snackBonus = snackCount * snackCount * 200;
        let hpBonus = Math.floor(10000 * (Math.max(0, gameState.hp) / gameState.maxHp));
        let totalScore = gameState.score + snackBonus + hpBonus;
        
        gameState.score = totalScore;
        saveScore(false);
        
        showResultScreen('„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº', '#D32F2F', gameState.score - snackBonus - hpBonus, snackBonus, hpBonus, totalScore);
    }

    function showResultScreen(title, color, baseScore, snackBonus, hpBonus, totalScore) {
        document.querySelectorAll('.ui-layer').forEach(el => el.classList.add('hidden'));
        const resScreen = document.getElementById('screen-result');
        resScreen.classList.remove('hidden');
        
        const titleEl = document.getElementById('result-title');
        titleEl.innerText = title;
        titleEl.style.color = color;
        
        const details = document.getElementById('result-details');
        details.innerHTML = `
            <div style="display:flex; justify-content:space-between; margin-bottom: 15px;"><span>„Çπ„Ç≥„Ç¢:</span> <span>${baseScore} ÁÇπ</span></div>
            <div style="display:flex; justify-content:space-between; margin-bottom: 15px;"><span>„Åä„Åã„Åó„Éú„Éº„Éä„Çπ:</span> <span>${snackBonus} ÁÇπ</span></div>
            <div style="display:flex; justify-content:space-between; margin-bottom: 15px; border-bottom: 3px dashed #BCAAA4; padding-bottom: 15px;"><span>„ÅÆ„Åì„ÇäHP„Éú„Éº„Éä„Çπ:</span> <span>${hpBonus} ÁÇπ</span></div>
            <div style="display:flex; justify-content:space-between; font-size: 38px; color: #E65100; margin-top: 15px;"><span>Á∑èÂêà„Çπ„Ç≥„Ç¢:</span> <span>${totalScore} ÁÇπ</span></div>
        `;
    }

    /* =========================================
       Rendering (Canvas)
    ========================================= */
    function drawRoundedRect(ctx, x, y, w, h, r, fill, stroke) {
        ctx.beginPath(); ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
        if(fill) { ctx.fillStyle = fill; ctx.fill(); }
        if(stroke) { ctx.lineWidth = 4; ctx.strokeStyle = stroke; ctx.stroke(); }
    }

    function renderGame() {
        ctx.clearRect(0, 0, GAME_W, GAME_H);
        
        // Background
        ctx.fillStyle = '#FFF9E6';
        ctx.fillRect(0, 0, GAME_W, GAME_H);

        // --- Top Buttons ---
        drawRoundedRect(ctx, HOWTO_BTN.x, HOWTO_BTN.y, HOWTO_BTN.w, HOWTO_BTN.h, 20, '#FFCDD2', '#E57373');
        ctx.fillStyle = '#5D4037';
        ctx.textAlign = 'center';
        ctx.font = `bold 22px ${FONT_FAMILY}`;
        ctx.fillText('„ÅÇ„Åù„Å≥„Åã„Åü', HOWTO_BTN.x + HOWTO_BTN.w/2, HOWTO_BTN.y + 32);

        drawRoundedRect(ctx, TITLE_BTN.x, TITLE_BTN.y, TITLE_BTN.w, TITLE_BTN.h, 20, '#E0E0E0', '#BDBDBD');
        ctx.fillStyle = '#5D4037';
        ctx.fillText('„Çø„Ç§„Éà„É´„Å∏', TITLE_BTN.x + TITLE_BTN.w/2, TITLE_BTN.y + 32);

        // --- Top Center (HP Bar) ---
        drawRoundedRect(ctx, 340, 15, 600, 60, 20, '#FFFFFF', '#BCAAA4');
        ctx.fillStyle = '#5D4037';
        ctx.textAlign = 'left';
        ctx.font = `bold 32px ${FONT_FAMILY}`;
        ctx.fillText('HP :', 370, 55);
        
        let hpW = 400, hpH = 30;
        drawRoundedRect(ctx, 450, 30, hpW, hpH, 15, '#EEEEEE', '#BCAAA4');
        let hpPct = Math.max(0, gameState.hp / gameState.maxHp);
        if(hpPct > 0) {
            ctx.save(); ctx.beginPath(); ctx.rect(450, 30, hpW * hpPct, hpH); ctx.clip();
            let hpColor = hpPct > 0.3 ? '#81C784' : '#E57373';
            drawRoundedRect(ctx, 450, 30, hpW, hpH, 15, hpColor, null);
            ctx.restore();
        }
        ctx.textAlign = 'center';
        ctx.fillStyle = '#3E2723';
        ctx.font = `bold 28px ${FONT_FAMILY}`;
        ctx.fillText(`${gameState.hp.toFixed(1)} / ${gameState.maxHp.toFixed(1)}`, 450 + hpW/2, 53);

        // --- Center Top (Ribbon) ---
        const rX = 140, rY = 200, rW = 1000, rH = 80;
        
        ctx.fillStyle = '#FFF0F5';
        ctx.fillRect(rX, rY, rW, rH);
        
        let fillPct = gameState.displayRibbonValue / 5.0;
        if(fillPct > 0) {
            ctx.fillStyle = '#FFB6C1';
            ctx.fillRect(rX, rY, rW * fillPct, rH);
        }

        ctx.lineWidth = 6;
        ctx.strokeStyle = '#F48FB1';
        ctx.strokeRect(rX, rY, rW, rH);

        // 1.0 markers
        ctx.beginPath();
        for(let i=0; i<=50; i++) {
            let lineX = rX + (i / 50) * rW;
            if(i % 10 === 0) {
                ctx.moveTo(lineX, rY); ctx.lineTo(lineX, rY + rH + 20);
            } else {
                ctx.moveTo(lineX, rY + rH); ctx.lineTo(lineX, rY + rH + 10);
            }
        }
        ctx.strokeStyle = '#8D6E63'; ctx.lineWidth = 3; ctx.stroke();

        // 0.1 steps 
        ctx.beginPath();
        for(let i=1; i<50; i++) {
            if(i % 10 !== 0) {
                let lineX = rX + (i / 50) * rW;
                ctx.moveTo(lineX, rY); ctx.lineTo(lineX, rY + rH);
            }
        }
        ctx.strokeStyle = 'rgba(141, 110, 99, 0.4)'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]); ctx.stroke();

        // 0.5 steps (Stronger dashes)
        ctx.beginPath();
        for(let i=1; i<50; i++) {
            if(i % 5 === 0 && i % 10 !== 0) {
                let lineX = rX + (i / 50) * rW;
                ctx.moveTo(lineX, rY); ctx.lineTo(lineX, rY + rH);
            }
        }
        ctx.strokeStyle = '#8D6E63'; ctx.lineWidth = 4; ctx.setLineDash([6, 4]); ctx.stroke();
        ctx.setLineDash([]); 

        ctx.textAlign = 'center';
        ctx.font = `bold 32px ${FONT_FAMILY}`;
        ctx.fillStyle = '#5D4037';
        for(let i=0; i<=5; i++) {
            let mX = rX + (i / 5) * rW;
            ctx.fillText(i + ".0", mX, rY + rH + 55);
        }

        // Events Zones
        let lastNormalX = -999;
        let lastUpX = -999;

        gameState.events.forEach(ev => {
            if(!ev.cleared) {
                let sX = rX + (ev.start / 5.0) * rW;
                let eX = rX + (ev.end / 5.0) * rW;
                let w = eX - sX;
                let centerX = sX + w/2;
                
                if(ev.type === 'enemy') ctx.fillStyle = 'rgba(206, 147, 216, 0.6)';
                if(ev.type === 'gold') ctx.fillStyle = 'rgba(255, 245, 157, 0.6)';
                if(ev.type === 'gem') ctx.fillStyle = 'rgba(128, 222, 234, 0.6)';
                if(ev.type === 'snack') ctx.fillStyle = 'rgba(244, 143, 177, 0.6)';
                ctx.fillRect(sX, rY, w, rH);
                
                let iconSize = (ev.icon === 'üí∞' || ev.icon === 'üê≤') ? 87 : 58;
                let iconY = rY - 25;
                let textY = rY - 5;

                if (centerX - lastNormalX < 120) {
                    textY = rY - 75;
                    if (iconSize > 58) textY = rY - 100;
                    lastUpX = centerX;
                } else {
                    lastNormalX = centerX;
                }

                ctx.font = `${iconSize}px ${FONT_FAMILY}`;
                ctx.fillText(ev.icon, centerX, iconY);

                ctx.font = `bold 26px ${FONT_FAMILY}`;
                ctx.fillStyle = '#5D4037';
                ctx.fillText(`${ev.start.toFixed(1)}~${ev.end.toFixed(1)}`, centerX, textY);
            }
        });

        // Big Numeric Value Card
        const cardW = 240, cardH = 100;
        const cardX = 640 - cardW/2, cardY = 390; 
        
        ctx.fillStyle = '#5D4037';
        ctx.font = `bold 20px ${FONT_FAMILY}`;
        ctx.fillText('„ÅÑ„Åæ„ÅÆ„Åô„ÅÜ„Åò', 640, cardY - 10);

        drawRoundedRect(ctx, cardX, cardY, cardW, cardH, 20, '#FFFFFF', '#FFCC80');
        ctx.fillStyle = '#E65100';
        ctx.font = `bold 64px ${FONT_FAMILY}`;
        ctx.fillText(gameState.displayRibbonValue.toFixed(1), cardX + cardW/2, cardY + 70);

        // --- Left Bottom (Info & Buttons) ---
        drawRoundedRect(ctx, 30, 410, 300, 280, 20, '#FFFFFF', '#FFCC80');
        
        ctx.font = `bold 26px ${FONT_FAMILY}`;
        let labelX = 200, valX = 290;
        
        ctx.textAlign = 'right';
        ctx.fillStyle = '#5D4037'; ctx.fillText('„Çπ„ÉÜ„Éº„Ç∏ :', labelX, 460);
        ctx.fillText(`${gameState.stage} / ${gameState.maxStage}`, valX, 460);
        
        ctx.fillStyle = '#5D4037'; ctx.fillText('„Çπ„Ç≥„Ç¢ :', labelX, 510);
        ctx.fillStyle = '#1976D2'; ctx.fillText(`${gameState.score}`, valX, 510);
        
        ctx.fillStyle = '#5D4037'; ctx.fillText('„ÉÄ„Ç§„É§üíé :', labelX, 560);
        ctx.fillStyle = '#00838F'; ctx.fillText(`${gameState.gems}`, valX, 560);

        let btnColor = gameState.gems > 0 ? '#FFF59D' : '#E0E0E0';
        drawRoundedRect(ctx, GEM_BTN.x, GEM_BTN.y, GEM_BTN.w, GEM_BTN.h, 20, btnColor, '#FFD54F');
        ctx.fillStyle = gameState.gems > 0 ? '#5D4037' : '#9E9E9E';
        ctx.textAlign = 'center';
        ctx.font = `bold 28px ${FONT_FAMILY}`;
        ctx.fillText('üíé„ÉÅ„Çß„É≥„Ç∏', GEM_BTN.x + GEM_BTN.w/2, GEM_BTN.y + 40);

        // --- Right Bottom (Snacks) ---
        drawRoundedRect(ctx, 950, 410, 300, 280, 20, '#FFFFFF', '#FFCC80');

        ctx.fillStyle = '#5D4037';
        ctx.textAlign = 'center';
        ctx.font = `bold 24px ${FONT_FAMILY}`;
        ctx.fillText(`„ÅÇ„Å§„ÇÅ„Åü„Åä„Åã„Åó Ôºà${gameState.snacksCollected.length}/12Ôºâ`, 1100, 440);
        
        ctx.font = `46px ${FONT_FAMILY}`;
        ALL_SNACKS.forEach((snack, i) => {
            let col = i % 4;
            let row = Math.floor(i / 4);
            let collected = gameState.snacksCollected.includes(snack);
            ctx.globalAlpha = collected ? 1.0 : 0.25;
            let px = 995 + col * 70;
            let py = 520 + row * 60;
            ctx.fillText(snack, px, py);
            ctx.globalAlpha = 1.0;
        });

        // --- Center Bottom (Cards) ---
        gameState.cards.forEach(c => {
            if(!c.isDragging) { c.x += (c.targetX - c.x) * 0.2; c.y += (c.targetY - c.y) * 0.2; }
        });

        gameState.cards.forEach(c => { if(!c.isDragging) drawCard(c); });
        let draggingCard = gameState.cards.find(c => c.isDragging);
        if(draggingCard) drawCard(draggingCard);

        updateAndDrawParticles();

        // Message Overlay
        if(gameMessage.active && !isHowToPlayActive) {
            const mX = 240, mY = 180, mW = 800, mH = 260;
            ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 10;
            drawRoundedRect(ctx, mX, mY, mW, mH, 20, 'rgba(255,255,255,0.95)', '#FFB74D');
            ctx.shadowColor = 'transparent';
            
            ctx.fillStyle = '#5D4037';
            ctx.font = `bold 38px ${FONT_FAMILY}`;
            ctx.textAlign = 'center';
            gameMessage.lines.forEach((line, i) => {
                ctx.fillText(line, mX + mW/2, mY + 80 + i * 46);
            });
            ctx.font = `bold 22px ${FONT_FAMILY}`;
            ctx.fillStyle = '#8D6E63';
            ctx.fillText('‚ñº ÁîªÈù¢„Çí„Çø„ÉÉ„Éó„Åô„Çã„Åã„Ç≠„Éº„ÇíÊäº„Åó„Å¶Ê¨°„Å∏', mX + mW/2, mY + mH - 24);
        }

        // How To Play Overlay
        if(isHowToPlayActive) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, GAME_W, GAME_H);

            const pX = 140, pY = 80, pW = 1000, pH = 560;
            drawRoundedRect(ctx, pX, pY, pW, pH, 30, '#FFF', '#FFCDD2');

            ctx.fillStyle = '#5D4037';
            ctx.textAlign = 'center';
            ctx.font = `bold 38px ${FONT_FAMILY}`;
            ctx.fillText('„ÅÇ„Åù„Å≥„Åã„Åü', pX + pW/2, pY + 60);

            ctx.font = `bold 24px ${FONT_FAMILY}`;
            ctx.textAlign = 'left';
            const rules = [
                "‚ë† ÊâãÊú≠„ÅÆ„Ç´„Éº„Éâ„ÇíÂ†¥„ÅÆÊï∞ÂÄ§„Ç´„Éº„Éâ„Å´Èáç„Å≠„Çà„ÅÜ„ÄÇ",
                "‚ë° „Ç´„Éº„Éâ„ÅÆÊï∞Â≠ó„Å†„ÅëÊï∞Áõ¥Á∑ö„ÅÆ„Éê„Éº„Åå„Ç∞„Éº„Å£„Å®‰º∏„Å≥„Çã„Çà„ÄÇ",
                "‚ë¢ 5.0 „ÇíË∂Ö„Åà„Çã„Å®„ÇØ„É™„Ç¢„Å†„Åë„Å©„ÄÅË∂Ö„Åà„ÅüÂàÜHP„ÅåÊ∏õ„Çã„ÇàÔºÅ",
                "‚ë£ 1.0, 2.0, 3.0, 4.0, 5.0 „Åß„Å¥„Å£„Åü„Çä„Å®„Åæ„Çã„Å®„Éú„Éº„Éä„Çπ„Éù„Ç§„É≥„ÉàÔºÅ",
                "‚ë§ „Ç§„Éô„É≥„Éà„Éû„Çπ„Å´Ê≠¢„Åæ„Çã„Å®Êïµ„ÇÑÂÆù„ÅåÂá∫„Çã„Çà„ÄÇ",
                "‚ë• ÂÖ®Ôºó„Çπ„ÉÜ„Éº„Ç∏„ÇíHP„ÅåÔºê„Å´„Å™„ÇãÂâç„Å´„ÇØ„É™„Ç¢„Åó„Çà„ÅÜÔºÅ",
                "Ôºà„Ç¢„Éâ„Éê„Ç§„ÇπÔºâ",
                "„ÉªÊïµüëæüê≤„Å´„Å®„Åæ„Çã„Å®ÊâãÊú≠„ÅåÂ∞ÅÂç∞„Åï„Çå„Çã„Çà„ÄÇ",
                "„ÉªË≤°ÂÆùü™ôüí∞„Å´„Å®„Åæ„Çã„Å®„Çπ„Ç≥„Ç¢„Åå„Ç¢„ÉÉ„Éó„Åô„Çã„Çà„ÄÇ",
                "„Éª„Å®„Å£„Åü„ÉÄ„Ç§„É§üíé„Çí„Å§„Åã„ÅÜ„Å®ÊâãÊú≠„ÇíÂÖ®ÈÉ®„ÉÅ„Çß„É≥„Ç∏„Åß„Åç„Çã„Çà„ÄÇ",
                "„Éª„Ç∏„Éß„Éº„Ç´„ÉºüÉè„ÅØÂ•Ω„Åç„Å™Êï∞Â≠ó„ÇíÈÅ∏„Åπ„Çã„Çà„ÄÇ",
                "„Éª„Åä„Åã„Åó„ÅØ„Åü„Åè„Åï„ÇìÈõÜ„ÇÅ„Çã„Åª„Å©ÊúÄÂæå„Å´„Çπ„Ç≥„Ç¢„ÅåÈ´ò„Åè„Å™„Çã„ÇàÔºÅ"
            ];
            rules.forEach((r, i) => ctx.fillText(r, pX + 40, pY + 115 + i * 35));

            ctx.textAlign = 'center';
            ctx.fillStyle = '#D32F2F';
            ctx.font = `bold 26px ${FONT_FAMILY}`;
            ctx.fillText('‚ñº ÁîªÈù¢„ÅÆ„Å©„Åì„Åã„Çí„Çø„ÉÉ„Éó„Åó„Å¶Èñâ„Åò„Çã', pX + pW/2, pY + pH - 25);
        }
    }

    function drawCard(c) {
        const cw = 108, ch = 144; 
        ctx.save();
        if(c.sealedTurns > 0) ctx.globalAlpha = 0.5;
        
        ctx.shadowColor = 'rgba(0,0,0,0.1)';
        ctx.shadowBlur = c.isDragging ? 20 : 10;
        ctx.shadowOffsetY = c.isDragging ? 15 : 5;

        let cardColor = '#81D4FA'; 
        let textColor = '#0277BD';
        if (!c.isJoker) {
            if (c.value <= 0.5) {
                cardColor = '#A5D6A7'; textColor = '#2E7D32'; 
            } else if (c.value <= 1.0) {
                cardColor = '#81D4FA'; textColor = '#0277BD'; 
            } else if (c.value <= 1.5) {
                cardColor = '#FFCC80'; textColor = '#E65100'; 
            } else {
                cardColor = '#F48FB1'; textColor = '#C2185B'; 
            }
        } else {
            cardColor = '#CE93D8'; textColor = '#6A1B9A'; 
        }

        drawRoundedRect(ctx, c.x, c.y, cw, ch, 15, '#FFF', cardColor);
        ctx.shadowColor = 'transparent';

        ctx.fillStyle = textColor;
        ctx.textAlign = 'center';
        ctx.font = `bold 46px ${FONT_FAMILY}`;
        ctx.fillText(c.isJoker ? 'üÉè' : c.value.toFixed(1), c.x + cw/2, c.y + ch/2 + 16);

        if(c.sealedTurns > 0) {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            drawRoundedRect(ctx, c.x, c.y, cw, ch, 15, 'rgba(0,0,0,0.4)', null);
            ctx.fillStyle = '#FFF';
            ctx.font = `bold 24px ${FONT_FAMILY}`;
            ctx.fillText('Â∞ÅÂç∞', c.x + cw/2, c.y + ch/2 - 10);
            ctx.fillText(`„ÅÇ„Å®${c.sealedTurns}`, c.x + cw/2, c.y + ch/2 + 25);
        }

        ctx.restore();
    }

    /* =========================================
       Particles
    ========================================= */
    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            gameState.particles.push({
                x: x, y: y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12,
                life: 1.0, color: color
            });
        }
    }

    function updateAndDrawParticles() {
        for(let i=gameState.particles.length-1; i>=0; i--) {
            let p = gameState.particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.02;
            if(p.life <= 0) { gameState.particles.splice(i, 1); } 
            else {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
    }

    /* =========================================
       Input Handling
    ========================================= */
    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX = e.touches ? e.touches[0].clientX : e.clientX;
        let clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: (clientX - rect.left) / currentScale, y: (clientY - rect.top) / currentScale };
    }

    function advanceMessageHandler(e) {
        if ((appState === 'PLAYING' || appState === 'GAMEOVER_WAIT') && gameMessage.active && !isHowToPlayActive) {
            if(e) e.preventDefault();
            let cb = gameMessage.callback;
            gameMessage.active = false;
            if(cb) cb();
            advanceMessage();
            return true;
        }
        return false;
    }

    window.addEventListener('keydown', (e) => advanceMessageHandler(e));

    function onPointerDown(e) {
        if(appState === 'GAMEOVER_WAIT' || appState === 'PLAYING') {
            if(advanceMessageHandler(e)) return; 
        }
        if(appState !== 'PLAYING') return;

        if(isHowToPlayActive) { isHowToPlayActive = false; return; }
        if(gameState.isAnimating) return;
        if(pendingJokerIndex !== -1) return;

        const pos = getPointerPos(e);
        mouseX = pos.x; mouseY = pos.y;

        if(mouseX >= HOWTO_BTN.x && mouseX <= HOWTO_BTN.x + HOWTO_BTN.w &&
           mouseY >= HOWTO_BTN.y && mouseY <= HOWTO_BTN.y + HOWTO_BTN.h) {
            isHowToPlayActive = true; return;
        }

        if(mouseX >= GEM_BTN.x && mouseX <= GEM_BTN.x + GEM_BTN.w &&
           mouseY >= GEM_BTN.y && mouseY <= GEM_BTN.y + GEM_BTN.h) {
            if(gameState.gems > 0) {
                document.getElementById('change-popup').classList.remove('hidden');
            }
            return;
        }

        if(mouseX >= TITLE_BTN.x && mouseX <= TITLE_BTN.x + TITLE_BTN.w &&
           mouseY >= TITLE_BTN.y && mouseY <= TITLE_BTN.y + TITLE_BTN.h) {
            showScreen('screen-title'); return;
        }

        for(let i=0; i<gameState.cards.length; i++) {
            let c = gameState.cards[i];
            if(c.sealedTurns === 0 && mouseX >= c.x && mouseX <= c.x + 108 && mouseY >= c.y && mouseY <= c.y + 144) {
                draggingCardIndex = i;
                c.isDragging = true;
                dragOffsetX = mouseX - c.x;
                dragOffsetY = mouseY - c.y;
                break;
            }
        }
    }

    function onPointerMove(e) {
        if(draggingCardIndex === -1) return;
        e.preventDefault();
        const pos = getPointerPos(e);
        let c = gameState.cards[draggingCardIndex];
        c.x = pos.x - dragOffsetX;
        c.y = pos.y - dragOffsetY;
    }

    function onPointerUp(e) {
        if(draggingCardIndex === -1) return;
        let c = gameState.cards[draggingCardIndex];
        c.isDragging = false;

        const rX = 140, rY = 200, rW = 1000, rH = 80;
        const cardW = 240, cardH = 100;
        const cardX = 640 - cardW/2, cardY = 390;

        let cx = c.x + 54, cy = c.y + 72;
        
        let onRibbon = (cx >= rX && cx <= rX + rW && cy >= rY - 40 && cy <= rY + rH + 60);
        let onNumCard = (cx >= cardX && cx <= cardX + cardW && cy >= cardY && cy <= cardY + cardH);

        if(onRibbon || onNumCard) {
            processDrop(draggingCardIndex);
        } else {
            c.targetX = getCardBasePosition(draggingCardIndex).x;
            c.targetY = getCardBasePosition(draggingCardIndex).y;
        }
        draggingCardIndex = -1;
    }

    canvas.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, {passive: false});
    window.addEventListener('touchmove', onPointerMove, {passive: false});
    window.addEventListener('touchend', onPointerUp);

    /* =========================================
       Main Loop & Animation Update
    ========================================= */
    function gameLoop(time) {
        if(appState === 'PLAYING' || appState === 'GAMEOVER_WAIT') {
            if(gameState.isAnimating) {
                let diff = gameState.targetRibbonValue - gameState.displayRibbonValue;
                if(diff > 0.005) {
                    gameState.displayRibbonValue += diff * 0.1; 
                } else {
                    gameState.displayRibbonValue = gameState.targetRibbonValue;
                    gameState.isAnimating = false;
                    checkEvents();
                }
            }
            renderGame();
        }
        animationId = requestAnimationFrame(gameLoop);
    }

    updateCurrentPlayerDisplay();

</script>
</body>
</html>