<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ãŸã™ã¦ã‚“ï¼</title>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&display=swap" rel="stylesheet">
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, where, orderBy, limit, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBCg5dCEM89UmYYhfGqVeRf_VrUlg8_o-4",
            authDomain: "math-braves.firebaseapp.com",
            projectId: "math-braves",
            storageBucket: "math-braves.firebasestorage.app",
            messagingSenderId: "217117619290",
            appId: "1:217117619290:web:d227feb603970d3948d463"
        };

        try {
            const app = initializeApp(firebaseConfig);
            const db = getFirestore(app);
            const auth = getAuth(app);
            
            // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«å…¬é–‹ï¼ˆGameãƒ­ã‚¸ãƒƒã‚¯ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ï¼‰
            window.dbInstance = db;
            window.authInstance = auth;
            window.collection = collection;
            window.addDoc = addDoc;
            window.query = query;
            window.where = where;
            window.orderBy = orderBy;
            window.limit = limit;
            window.getDocs = getDocs;
            window.serverTimestamp = serverTimestamp;

            // èªè¨¼çŠ¶æ…‹ã®ç›£è¦–
            onAuthStateChanged(auth, (user) => {
                window.currentUser = user;
                // ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ã®å ´åˆã€æç”»æ›´æ–°ï¼ˆãƒœã‚¿ãƒ³ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆã®ãŸã‚ï¼‰
                if(window.GameInstance && window.GameInstance.isInTitle()) {
                    // å†æç”»ã®ãƒˆãƒªã‚¬ãƒ¼ãŒå¿…è¦ãªã‚‰ã“ã“ã§è¡Œã†ãŒã€requestAnimationFrameã§å›ã£ã¦ã„ã‚‹ã®ã§è‡ªå‹•åæ˜ ã•ã‚Œã‚‹
                }
            });

            // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
            window.handleGoogleAuth = async function() {
                if (auth.currentUser && !auth.currentUser.isAnonymous) {
                    // ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†
                    try {
                        await signOut(auth);
                        alert("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ");
                    } catch(e) {
                        alert("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                    }
                } else {
                    // ãƒ­ã‚°ã‚¤ãƒ³å‡¦ç†
                    const provider = new GoogleAuthProvider();
                    try {
                        await signInWithPopup(auth, provider);
                        alert("ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸï¼\nãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã« è¨˜éŒ²ã•ã‚Œã‚‹ã‚ˆã†ã« ãªã£ãŸã‚ˆï¼");
                    } catch(e) {
                        alert("ãƒ­ã‚°ã‚¤ãƒ³ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                    }
                }
            };

        } catch (err) {
            console.error("Firebase Init Error:", err);
        }
    </script>

    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #4E342E; /* å¤–å´ã®èƒŒæ™¯ï¼šæ¿ƒã„èŒ¶è‰² */
            overflow: hidden;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            touch-action: none;
        }
        #game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1280px;
            height: 720px;
            background-color: #FFF8E1; /* ã‚²ãƒ¼ãƒ èƒŒæ™¯ï¼šã‚¯ãƒªãƒ¼ãƒ è‰² */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        .overlay-input {
            position: absolute;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            z-index: 100;
            border: 4px solid #FF9800;
        }
        /* ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆã‚¨ãƒ©ãƒ¼è¡¨ç¤ºç”¨ */
        #dbErrorOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            background: #FFEBEE;
            border: 4px solid #D32F2F;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            display: none;
            flex-direction: column;
            z-index: 200;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        input[type="text"] {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-size: 24px;
            padding: 10px;
            border: 3px solid #FF9800;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            outline: none;
            background-color: #FFF3E0;
        }
        button.ui-btn {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            font-size: 20px;
            padding: 10px 20px;
            background-color: #FF9800;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px #E65100;
            transition: transform 0.1s;
        }
        button.ui-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="1280" height="720"></canvas>
    
    <div id="playerInputOverlay" class="overlay-input" style="top: 50%; left: 50%; transform: translate(-50%, -50%); width: 400px;">
        <h3 style="margin-top:0; color:#5D4037;">ãªã¾ãˆã‚’ã„ã‚Œã¦ã­</h3>
        <p style="font-size:14px; color:#666;">ã²ã‚‰ãŒãª 8ã‚‚ã˜ ã¾ã§</p>
        <input type="text" id="playerNameInput" maxlength="8" placeholder="ã²ã‚‰ãŒãªã®ã¿">
        <div style="display:flex; gap:10px;">
            <button class="ui-btn" onclick="Game.registerPlayer()">ã¨ã†ã‚ã</button>
            <button class="ui-btn" style="background-color:#90A4AE; box-shadow:0 4px #546E7A;" onclick="Game.closePlayerInput()">ã‚„ã‚ã‚‹</button>
        </div>
        <p id="inputError" style="color:red; font-size:14px; margin-bottom:0; min-height:20px;"></p>
    </div>

    <div id="dbErrorOverlay">
        <h3 style="color:#D32F2F; margin-top:0;">ã‚·ã‚¹ãƒ†ãƒ è¨­å®šãŒå¿…è¦ã§ã™</h3>
        <p style="color:#555; text-align:left;">
            ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­å®šãŒå¿…è¦ã§ã™ã€‚<br>
            é–‹ç™ºè€…ã®æ–¹ã¯ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨­å®šã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚
        </p>
        <a id="dbErrorLink" href="#" target="_blank" style="color:#1565C0; font-weight:bold; font-size:18px; text-decoration:underline; word-break:break-all; display:block; margin:20px 0;">
            ï¼ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆç”»é¢ã¸ ï¼œ
        </a>
        <button class="ui-btn" style="background-color:#90A4AE;" onclick="document.getElementById('dbErrorOverlay').style.display='none'">ã¨ã˜ã‚‹</button>
    </div>
</div>

<script>
/**
 * å®šæ•°ãƒ»è¨­å®š
 */
const COLLECTION_NAME = "scores_tasuten";

// NGãƒ¯ãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ
const NG_WORDS_HIRAGANA = [
    'ã—ã­', 'ã—ã¬', 'ã—ã«', 'ã“ã‚ã™', 'ã“ã‚ã›', 'ã•ã¤ãŒã„', 'ããŸã°ã‚Œ',
    'ã˜ã•ã¤', 'ãã•ã¤', 'ã¤ã‚‹ã™', 'ã‚Œã‚“ãŸã‚“', 'ã—ã«ãŸã„',
    'ã¦ã‚', 'ã¦ã‚ã‚Šã™ã¨', 'ã°ãã¯', 'ã°ãã ã‚“', 'ã»ã†ã‹',
    'ã¯ã‚“ã–ã„', 'ã”ã†ã¨ã†', 'ã‚†ã†ã‹ã„', 'ã‹ã‚“ãã‚“', 'ãŠãã†',
    'ã‚„ãã–', 'ã¼ã†ã‚Šã‚‡ã', 'ã¯ã‚“ãã‚Œ', 'ã¡ã‚“ã´ã‚‰', 'ã¾ãµãƒã‚',
    'ãŸã„ã¾', 'ã¾ã‚„ã', 'ã‹ãã›ã„ã–ã„', 'ã—ã‚ƒã¶', 'ã©ã‚‰ã£ã', 'ã“ã‹ã„ã‚“',
    'ã¸ã‚ã„ã‚“', 'ãˆãã™ãŸã—ãƒ¼', 'ã ã£ã½ã†', 'ãã‚ã›ã',
    'ã„ã˜ã‚', 'ãã‚ƒããŸã„',
    'ã°ã‹', 'ã‚ã»', 'ã¾ã¬ã‘', 'ãã¡ãŒã„', 'ãé•ã„',
    'ã†ã–ã„', 'ã†ã–', 'ãã‚‚ã„', 'ãã‚‚', 'ãã—ã‚‡ã„', 'ããˆã‚',
    'ããš', 'ã”ã¿', 'ã”ã¿ã‚€ã—', 'ã‹ã™', 'ã–ã“', 'ãœã¤',
    'ã¶ã™', 'ã§ã¶', 'ã¯ã’', 'ã¡ã³', 'ã§ã£ã±', 'ã„ãªã‹ã‚‚ã®',
    'ã†ã˜', 'ã¯ã„ã¼ã', 'ã¾ã‘ã„ã¬', 'ãŠã¤ã‚€', 'ã®ã†ãŸã‚Šã‚“',
    'ã¦ã„ã®ã†', 'ã¡ã—ã‚‡ã†', 'ã—ã‚‡ã†ãŒã„', 'ãŒã„ã˜', 'ã‹ãŸã‚', 'ã³ã£ã“',
    'ã‚ãã‚‰', 'ã¤ã‚“ã¼', 'ãŠã—', 'ã©ã˜ã‚“', 'ãˆãŸ', 'ã²ã«ã‚“',
    'ãŸã²', 'ãŸã²ã­',
    'ã†ã›ã‚', 'ã ã¾ã‚Œ',
    'ã¡ã‚“ã¡ã‚“', 'ã¡ã‚“ã“', 'ã¡ã‚“ã½', 'ã¡ã‚“ã‹', 'ã¾ã‚‰', 'ã•ãŠ',
    'ã¾ã‚“ã“', 'ã¾ã‚“ã—ã‚…ã†', 'ã¾ã‚“ã’', 'ã‚ã‚Œã‚', 'ãŠã¾ãŸ',
    'ãã‚Š', 'ãã‚Šã¨ã‚Šã™', 'ã„ã‚“ã—ã‚“', 'ã„ã‚“ã‹ã', 'ã³ã‚‰ã³ã‚‰',
    'ã“ã†ãŒã‚“', 'ãŸã¾ãã‚“', 'ãã‚“ãŸã¾', 'ãµãã‚Š',
    'ãŠã£ã±ã„', 'ã¡ã¡', 'ã«ã‚…ã†ã‚Šã‚“', 'ã«ã‚…ã†ã¨ã†', 'ãã‚‡ã«ã‚…ã†', 'ã²ã‚“ã«ã‚…ã†',
    'ã‘ã¤', 'ã‚ãªã‚‹', 'ã“ã†ã‚‚ã‚“', 'ã‘ã¤ã®ã‚ãª',
    'ãˆã‚', 'ãˆã£ã¡', 'ã™ã‘ã¹', 'ã¸ã‚“ãŸã„', 'ã‚€ã£ã¤ã‚Š', 'ã—ã“',
    'ã›ã£ãã™', 'ã›ã„ã“ã†', 'ã¾ãã‚ã„', 'ãã†ã«ã‚…ã†', 'ã¯ã‚ã‚‹',
    'ãŠãªã«ãƒ¼', 'ã˜ã„', 'ã—ã“ã—ã“', 'ãµã‡ã‚‰', 'ã±ã„ãšã‚Š', 'ãã‚“ã«',
    'ã„ã‚‰ã¾', 'ã—ã£ã—ã‚“', 'ãªã‹ã ã—', 'ã”ã£ãã‚“', 'ã¶ã£ã‹ã‘',
    'ã—ãŠãµã', 'ãœã£ã¡ã‚‡ã†', 'ã„ã', 'ã„ã‹ã›ã‚', 'ã‚ãˆã',
    'ã©ã†ã¦ã„', 'ã—ã‚‡ã˜ã‚‡', 'ã‚„ã‚Šã¾ã‚“', 'ã‚„ã‚Šã¡ã‚“', 'ã³ã£ã¡',
    'ã›ãµã‚Œ', 'ã±ã“', 'ã±ã“ã±ã“', 'ã‚ã„ã›ã¤', 'ã‚ã‚Š', 'ã—ã‚‡ãŸ', 'ãºã©',
    'ãã‚“ã—ã‚“', 'ã˜ã‚…ã†ã‹ã‚“', 'ã‚Šã‚‡ã†ã˜ã‚‡ã', 'ã‚‰ã‚“ã“ã†', 'ã™ã‹ã‚“ã¨',
    'ã®ãƒ¼ã±ã‚“', 'ã±ã‚“ã¡ã‚‰',
    'ã‚Œã„ã·', 'ã”ã†ã‹ã‚“', 'ã¡ã‹ã‚“', 'ã¨ã†ã•ã¤', 'ã®ãã', 'ã‚ã—ã‚…ã¤',
    'ãµã†ãã', 'ããƒ¼ã·', 'ã¸ã‚‹ã™', 'ã§ã‚Šã¸ã‚‹', 'ã´ã‚“ã•ã‚', 'ã„ã‚ãã‚‰',
    'ã‚ã ã‚‹ã¨', 'ãˆãƒ¼ã¶ã„', 'ãˆã¶ã„', 'ã½ã‚‹ã®', 'ã†ã‚‰ã³ã§ãŠ', 'ã‚€ã—ã‚…ã†ã›ã„',
    'ãˆã‚“ã“ã†', 'ãˆã‚“ã˜ã‚‡', 'ã†ã‚Š', 'ã‹ã„ã—ã‚…ã‚“', 'ã°ã„ã—ã‚…ã‚“',
    'ã±ã±ã‹ã¤', 'ã¾ã¾ã‹ã¤', 'ã†ã‚Šã›ã‚“',
    'ã†ã‚“ã“', 'ã†ã‚“ã¡', 'ãã', 'ã’ã‚Š', 'ã¹ã‚“', 'ãµã‚“',
    'ã—ã£ã“', 'ã—ã‚‡ã‚“ã¹ã‚“', 'ã«ã‚‡ã†', 'ã»ã†ã«ã‚‡ã†',
    'ã¸', 'ãŠãªã‚‰', 'ã’ã‚', 'ãŸã‚“',
    'ã†ã‚“ãˆã„', 'ã“ã†ã—ã', 'ã™ãŸã£ãµ', 'ã‹ã‚“ã‚Š', 'ã±ã¨ã‚ãƒ¼ã‚‹',
    'ã˜ãˆã‚€', 'ã’ãƒ¼ã‚€ã¾ã™ãŸãƒ¼', 'ã¾ã™ãŸãƒ¼', 'ã‚ã©ã¿ã‚“', 'ã—ã™ã¦ã‚€',
    'ã•ãƒ¼ã°ãƒ¼', 'ã‚ã‹ã°ã‚“', 'ã°ã‚“', 'ã¡ãƒ¼ã¨', 'ã¡ãƒ¼ãŸãƒ¼', 'ã°ã',
    'ã‚‰ã„ã‚“', 'ã‹ã‹ãŠ', 'ã™ã‹ã„ã·', 'ã„ã‚“ã™ãŸ', 'ã¤ã„ã£ãŸãƒ¼', 'ã§ãƒã™ã“',
    'ã§ã‚“ã‚', 'ã°ã‚“ã”ã†', 'ã‘ã„ãŸã„', 'ã‚ã©ã‚Œã™', 'ã‚ã‚ã©', 'ã˜ã‚…ã†ã—ã‚‡',
    'ã‚ãŠ', 'ã‚ã„ãŸã„', 'ã¾ã¡ã‚ã‚ã›', 'ã»ã¦ã‚‹', 'ã‚‰ã¶ã»', 'ãŠãµã‹ã„',
    'ã±ã™ã‚ãƒ¼ã©', 'ã±ã™', 'ã‚ã‹ã†ã‚“ã¨', 'ã“ã˜ã‚“ã˜ã‚‡ã†ã»ã†'
];

/**
 * ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³
 */
const Game = (function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // ç”»åƒèª­ã¿è¾¼ã¿
    const bgImage = new Image();
    bgImage.src = 'images/title.png';
    
    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
    const STATE = {
        TITLE: 0,
        PLAYER_SELECT: 1,
        DIFFICULTY_SELECT: 2,
        PLAYING: 3,
        ANIMATING: 4,
        GAME_OVER: 5,
        RANKING: 6
    };
    
    let currentState = STATE.TITLE;
    
    const BASE_WIDTH = 1280;
    const BASE_HEIGHT = 720;
    
    // ã‚°ãƒªãƒƒãƒ‰è¨­å®šï¼ˆä¸­å¤®ã«é…ç½®ï¼‰
    const GRID_ROWS = 5;
    const GRID_COLS = 5;
    const CELL_SIZE = 110;
    // ä¸­å¤®ã‚¨ãƒªã‚¢ã®è¨ˆç®—
    const GRID_OFFSET_X = (BASE_WIDTH - CELL_SIZE * GRID_COLS) / 2;
    const GRID_OFFSET_Y = (BASE_HEIGHT - CELL_SIZE * GRID_ROWS) / 2 + 10;
    
    // ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿
    let grid = [];
    let score = 0;
    let turnCount = 0;
    let difficulty = 'normal';
    let matchGroupsQueue = [];
    let animationTimer = 0;
    let selectedCell = null;
    let isDragging = false;
    let currentChain = 0; // ã‚³ãƒ³ãƒœï¼ˆé€£é–ï¼‰æ•°
    
    // ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆæµã‚Œæ˜Ÿï¼‰
    let starStock = 0;
    let isSelectingStar = false; // æµã‚Œæ˜Ÿã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨æ™‚ã®ç•ªå·é¸æŠãƒ¢ãƒ¼ãƒ‰
    
    // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ»ãƒŸãƒƒã‚·ãƒ§ãƒ³ç®¡ç†
    let currentStage = 1;
    let nextStageScore = 2000;
    let stageMonsterRateBonus = 0;

    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç®¡ç†ç”¨
    let effects = [];
    
    // ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ç®¡ç†
    let players = [];
    let currentPlayerIndex = -1;
    
    // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç”¨
    let rankingData = [];
    let rankingScope = 'local';
    let rankingTab = 'easy'; 
    
    // ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒåº§æ¨™
    const inputState = { x: 0, y: 0, isDown: false };

    // ãƒ‘ãƒãƒ«ã®èƒŒæ™¯è‰²ï¼ˆæ•°å­—ã”ã¨ï¼‰
    const NUMBER_BG_COLORS = [
        "#E53935", // 1: èµ¤
        "#1E88E5", // 2: é’
        "#43A047", // 3: ç·‘
        "#8E24AA", // 4: ç´«
        "#FB8C00", // 5: ã‚ªãƒ¬ãƒ³ã‚¸
        "#00ACC1", // 6: ã‚·ã‚¢ãƒ³
        "#D81B60", // 7: ãƒ”ãƒ³ã‚¯
        "#7CB342", // 8: é»„ç·‘
        "#6D4C41"  // 9: èŒ¶
    ];
    
    // åˆæœŸåŒ–
    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousedown', handleInputStart);
        canvas.addEventListener('mousemove', handleInputMove);
        canvas.addEventListener('mouseup', handleInputEnd);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInputStart(e.touches[0]); }, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleInputMove(e.touches[0]); }, {passive: false});
        canvas.addEventListener('touchend', handleInputEnd);
        
        loadPlayers();
        requestAnimationFrame(loop);
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å…¬é–‹ï¼ˆAuthListenerã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ç”¨ï¼‰
        window.GameInstance = {
            isInTitle: () => currentState === STATE.TITLE
        };
    }
    
    function resize() {
        const scaleX = window.innerWidth / BASE_WIDTH;
        const scaleY = window.innerHeight / BASE_HEIGHT;
        const scale = Math.min(scaleX, scaleY);
        const container = document.getElementById('game-container');
        container.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }

    // ------------------ ç¢ºç‡ãƒ»æŠ½é¸ãƒ­ã‚¸ãƒƒã‚¯ ------------------
    
    function getWeightedRandomVal() {
        const rand = Math.random() * 100;
        if (rand < 18) return 1;
        if (rand < 34) return 2;
        if (rand < 48) return 3;
        if (rand < 60) return 4;
        if (rand < 70) return 5;
        if (rand < 79) return 6;
        if (rand < 87) return 7;
        if (rand < 94) return 8;
        return 9;
    }

    function getSpecialTileType() {
        const rand = Math.random() * 100;
        
        // 0.5%ã®ç¢ºç‡ã§æµã‚Œæ˜Ÿ
        if (rand < 0.5) return 'star';

        let monsterRate, coinRate, bagRate;

        if (difficulty === 'easy') {
            monsterRate = 5; coinRate = 4; bagRate = 1;
        } else if (difficulty === 'normal') {
            monsterRate = 10; coinRate = 4; bagRate = 1;
        } else { // hard
            monsterRate = 15; coinRate = 4; bagRate = 1;
        }

        monsterRate += stageMonsterRateBonus;
        if (monsterRate > 75) monsterRate = 75;

        // æ®‹ã‚Šã®99.5%ã®ä¸­ã§åˆ¤å®šã™ã‚‹ãŸã‚ã«ã‚¹ã‚±ãƒ¼ãƒ«
        const subRand = Math.random() * 100;
        if (subRand < monsterRate) return 'monster';
        if (subRand < monsterRate + coinRate) return 'coin';
        if (subRand < monsterRate + coinRate + bagRate) return 'bag';
        return null;
    }
    
    // ------------------ ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ------------------
    
    function startNewGame(diff) {
        difficulty = diff;
        score = 0;
        turnCount = 0;
        currentStage = 1;
        nextStageScore = 2000;
        stageMonsterRateBonus = 0;
        currentChain = 0;
        starStock = 0;
        isSelectingStar = false;

        grid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
        effects = [];
        spawnNumbers(5, true); 
        currentState = STATE.PLAYING;
    }
    
    function spawnNumbers(count, isInitial) {
        let emptySpots = [];
        for(let r=0; r<GRID_ROWS; r++) {
            for(let c=0; c<GRID_COLS; c++) {
                if(!grid[r][c]) emptySpots.push({r, c});
            }
        }
        
        if (emptySpots.length === 0 && !isInitial) {
            checkGameOver();
            return;
        }

        emptySpots.sort(() => Math.random() - 0.5);
        let spawnCount = Math.min(count, emptySpots.length);
        
        for(let i=0; i<spawnCount; i++) {
            let pos = emptySpots[i];
            let specialType = getSpecialTileType();

            if (specialType === 'star') {
                grid[pos.r][pos.c] = { type: 'star', val: -1, life: 1, id: Date.now() + Math.random() };
            } else if (specialType === 'monster') {
                grid[pos.r][pos.c] = { type: 'monster', val: -1, id: Date.now() + Math.random() };
            } else if (specialType === 'coin') {
                grid[pos.r][pos.c] = { type: 'coin', val: -1, life: 1, id: Date.now() + Math.random() };
            } else if (specialType === 'bag') {
                grid[pos.r][pos.c] = { type: 'bag', val: -1, life: 1, id: Date.now() + Math.random() };
            } else {
                // å®‰å…¨ãªæ•°å€¤ãŒå‡ºã‚‹ã¾ã§æŠ½é¸ï¼ˆçµ„ã¿åˆã‚ã›çš„ã«å¿…ãšï¼‘ã¤ã¯å…¥ã‚‹æ•°å€¤ãŒã‚ã‚‹ï¼‰
                let val;
                let valid = false;
                
                do {
                    val = getWeightedRandomVal();
                    let creates10 = false;
                    
                    // æ¨ªæ–¹å‘ã®ãƒã‚§ãƒƒã‚¯
                    // ãã®è¡Œã®ã€æ–°ã—ã„æ•°å€¤(pos.c)ã‚’å«ã‚€å…¨ã¦ã®éƒ¨åˆ†åˆ—ã‚’æ¤œæŸ»
                    for(let start = 0; start <= pos.c; start++) {
                        for(let end = pos.c; end < GRID_COLS; end++) {
                            let sum = 0;
                            let possible = true;
                            for(let k = start; k <= end; k++) {
                                let v;
                                if(k === pos.c) {
                                    v = val;
                                } else {
                                    let cell = grid[pos.r][k];
                                    if(cell && cell.type === 'number') {
                                        v = cell.val;
                                    } else {
                                        // æ•°å€¤ä»¥å¤–ï¼ˆç©ºãƒ»ã‚¢ã‚¤ãƒ†ãƒ ç­‰ï¼‰ãŒæŒŸã¾ã‚‹ã¨é€£ç¶šã—ãªã„
                                        possible = false;
                                        break;
                                    }
                                }
                                sum += v;
                            }
                            if(possible && sum === 10) {
                                creates10 = true;
                                break;
                            }
                        }
                        if(creates10) break;
                    }

                    if(!creates10) {
                        // ç¸¦æ–¹å‘ã®ãƒã‚§ãƒƒã‚¯
                        for(let start = 0; start <= pos.r; start++) {
                            for(let end = pos.r; end < GRID_ROWS; end++) {
                                let sum = 0;
                                let possible = true;
                                for(let k = start; k <= end; k++) {
                                    let v;
                                    if(k === pos.r) {
                                        v = val;
                                    } else {
                                        let cell = grid[k][pos.c];
                                        if(cell && cell.type === 'number') {
                                            v = cell.val;
                                        } else {
                                            possible = false;
                                            break;
                                        }
                                    }
                                    sum += v;
                                }
                                if(possible && sum === 10) {
                                    creates10 = true;
                                    break;
                                }
                            }
                            if(creates10) break;
                        }
                    }
                    
                    if(!creates10) valid = true;
                    
                } while(!valid);

                grid[pos.r][pos.c] = { type: 'number', val: val, id: Date.now() + Math.random() };
            }
        }
        
        if (!isInitial) {
            let full = true;
            for(let r=0; r<GRID_ROWS; r++) {
                for(let c=0; c<GRID_COLS; c++) {
                    if(!grid[r][c]) full = false;
                }
            }
        }
    }
    
    function findMatches() {
        let groups = [];
        // æ¨ª
        for(let r=0; r<GRID_ROWS; r++) {
            let rowCells = [];
            for(let c=0; c<GRID_COLS; c++) {
                if(grid[r][c] && grid[r][c].type === 'number') {
                    rowCells.push({val: grid[r][c].val, r, c});
                } else {
                    rowCells.push(null); 
                }
            }
            checkLine(rowCells, groups);
        }
        // ç¸¦
        for(let c=0; c<GRID_COLS; c++) {
            let colCells = [];
            for(let r=0; r<GRID_ROWS; r++) {
                if(grid[r][c] && grid[r][c].type === 'number') {
                    colCells.push({val: grid[r][c].val, r, c});
                } else {
                    colCells.push(null);
                }
            }
            checkLine(colCells, groups);
        }

        // å‘¨å›²å·»ãè¾¼ã¿å‡¦ç†
        groups.forEach(group => {
            let extrasToAdd = [];
            let checkSet = new Set(); 
            group.forEach(cell => {
                const neighbors = [
                    {r: cell.r-1, c: cell.c}, {r: cell.r+1, c: cell.c},
                    {r: cell.r, c: cell.c-1}, {r: cell.r, c: cell.c+1}
                ];
                neighbors.forEach(n => {
                    if(n.r >= 0 && n.r < GRID_ROWS && n.c >= 0 && n.c < GRID_COLS) {
                        let target = grid[n.r][n.c];
                        // æµã‚Œæ˜Ÿ(star)ã‚‚å·»ãè¾¼ã¿å¯¾è±¡ã«è¿½åŠ 
                        if(target && (target.type === 'monster' || target.type === 'coin' || target.type === 'bag' || target.type === 'star')) {
                            let key = `${n.r},${n.c}`;
                            if(!checkSet.has(key)) {
                                checkSet.add(key);
                                extrasToAdd.push({r: n.r, c: n.c, type: target.type}); 
                            }
                        }
                    }
                });
            });
            extrasToAdd.forEach(m => group.push(m));
        });

        return groups;
    }
    
    function checkLine(line, groups) {
        for(let start=0; start<line.length; start++) {
            if(line[start] === null) continue;
            let sum = 0;
            let currentGroup = [];
            
            for(let end=start; end<line.length; end++) {
                if(line[end] === null) break;
                sum += line[end].val;
                currentGroup.push({r: line[end].r, c: line[end].c, type: 'number'});
                
                if(sum === 10) {
                    if(currentGroup.length >= 2) {
                        groups.push([...currentGroup]);
                    }
                }
                if(sum > 10) break;
            }
        }
    }
    
    // ãƒãƒƒãƒåˆ¤å®šã¨ã‚¹ã‚³ã‚¢è¨ˆç®—ã€ãƒ©ã‚¤ãƒ•æ¶ˆè²»ã‚’çµ±æ‹¬ã™ã‚‹é–¢æ•°
    function resolveMatches(consumeLife) {
        const matches = findMatches();
        let uniqueRemovedKeys = new Set();

        if(matches.length > 0) {
            // ã‚³ãƒ³ãƒœæ•°ï¼ˆãã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ä½•ç¨®é¡ã®å’ŒãŒ10ã‚’ä½œã‚ŒãŸã‹ï¼æˆç«‹ã—ãŸã‚°ãƒ«ãƒ¼ãƒ—æ•°ï¼‰ã‚’åŠ ç®—
            currentChain += matches.length;
            
            let weightedPointTotal = 0;
            
            matches.forEach(group => {
                group.forEach(cell => {
                    const key = `${cell.r},${cell.c}`;
                    if(!uniqueRemovedKeys.has(key)) {
                        uniqueRemovedKeys.add(key);
                        const actualCell = grid[cell.r][cell.c];
                        if (actualCell) {
                            // å¾—ç‚¹è¨ˆç®—ï¼ˆé‡ã¿ä»˜ã‘ï¼‰
                            if (actualCell.type === 'number') {
                                weightedPointTotal += 1;
                            } else if (actualCell.type === 'coin') {
                                weightedPointTotal += 3;
                            } else if (actualCell.type === 'bag') {
                                weightedPointTotal += 10;
                            } else if (actualCell.type === 'monster') {
                                weightedPointTotal += 0;
                            } else if (actualCell.type === 'star') {
                                // æµã‚Œæ˜Ÿã‚’ç²å¾—ï¼ˆç‚¹æ•°ã¯0æ‰±ã„ï¼‰
                                starStock++;
                                effects.push({
                                    x: GRID_OFFSET_X + cell.c * CELL_SIZE + CELL_SIZE/2,
                                    y: GRID_OFFSET_Y + cell.r * CELL_SIZE + CELL_SIZE/2,
                                    text: "GET!",
                                    life: 50,
                                    maxLife: 50,
                                    color: "#FFD700",
                                    scale: 0.8
                                });
                            }
                        }
                    }
                });
            });
            
            if (weightedPointTotal > 0) {
                // ã‚¹ã‚³ã‚¢è¨ˆç®—: (é‡ã¿ä»˜ã‘ã—ãŸæ¶ˆå»ãƒ‘ãƒãƒ«ç‚¹æ•°) * (ã‚³ãƒ³ãƒœæ•°) * 100
                let pts = weightedPointTotal * currentChain * 100;
                score += pts;
                
                // --- ã‚³ãƒ³ãƒœãƒ»ã‚¹ã‚³ã‚¢æ¼”å‡ºï¼ˆã‚¿ã‚¤ãƒŸãƒ³ã‚°èª¿æ•´ï¼‰ ---
                
                // 1. ã¾ãšæ ãŒå›²ã¾ã‚Œã‚‹ï¼ˆcurrentStateãŒANIMATINGã«ãªã‚Šã€updateã§æç”»ã•ã‚Œã‚‹ï¼‰
                // 2. ã‚³ãƒ³ãƒœè¡¨ç¤º (å°‘ã—é…ã‚Œã¦è¡¨ç¤º)
                setTimeout(() => {
                    effects.push({
                        x: BASE_WIDTH / 2,
                        y: BASE_HEIGHT / 2 - 50,
                        text: `x${currentChain} COMBO!`,
                        life: 75, // åŠåˆ†ã«çŸ­ç¸®
                        maxLife: 75,
                        color: "#FF6D00", // æ¿ƒã„ã‚ªãƒ¬ãƒ³ã‚¸ã§è¦‹ã‚„ã™ã
                        scale: 1.5,
                        stroke: "#FFF" // ç™½ç¸å–ã‚Š
                    });
                }, 400); // æ è¡¨ç¤ºãŒè¦‹ãˆã¦ã‹ã‚‰
                
                // 3. ã‚¹ã‚³ã‚¢è¡¨ç¤º (ã‚³ãƒ³ãƒœã®å¾Œã«è¡¨ç¤º)
                setTimeout(() => {
                    effects.push({
                         x: BASE_WIDTH / 2,
                         y: BASE_HEIGHT / 2 + 60,
                         text: `+${pts}`,
                         life: 60, // åŠåˆ†ã«çŸ­ç¸®
                         maxLife: 60,
                         color: "#FFFFFF",
                         scale: 1.2,
                         stroke: "#000" // é»’ç¸å–ã‚Š
                    });
                }, 900); // ã‚³ãƒ³ãƒœè¡¨ç¤ºã‹ã‚‰ã•ã‚‰ã«é…ã‚Œã¦

                checkStageClear();
            }

            matchGroupsQueue = matches;
            currentState = STATE.ANIMATING;
            animationTimer = performance.now();
        } else {
            // ãƒãƒƒãƒç„¡ã—
            if (consumeLife) {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œå¾Œã®å ´åˆã€ãƒªãƒ•ã‚£ãƒ«ã¸
                processRefill();
            } else {
                // ãƒªãƒ•ã‚£ãƒ«å¾Œã®è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã§ãƒãƒƒãƒç„¡ã—ï¼é€£é–çµ‚äº†
                // ã“ã“ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®š
                checkGameOver();
            }
        }

        // ãƒ©ã‚¤ãƒ•æ¶ˆè²»å‡¦ç†ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œæ™‚ã®ã¿ï¼‰
        if (consumeLife) {
            turnCount++;
            for(let r=0; r<GRID_ROWS; r++) {
                for(let c=0; c<GRID_COLS; c++) {
                    if(uniqueRemovedKeys.has(`${r},${c}`)) continue;
                    let cell = grid[r][c];
                    if(cell && (cell.type === 'coin' || cell.type === 'bag')) {
                        cell.life--;
                        if(cell.life <= 0) grid[r][c] = null;
                    }
                }
            }
        }
    }
    
    function useStarItem(targetVal) {
        starStock--;
        let removed = false;
        
        // æŒ‡å®šã•ã‚ŒãŸæ•°å­—ã‚’å…¨ã¦æ¶ˆå»
        for(let r=0; r<GRID_ROWS; r++) {
            for(let c=0; c<GRID_COLS; c++) {
                if(grid[r][c] && grid[r][c].type === 'number' && grid[r][c].val === targetVal) {
                    grid[r][c] = null;
                    removed = true;
                    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                    effects.push({
                        x: GRID_OFFSET_X + c * CELL_SIZE + CELL_SIZE/2,
                        y: GRID_OFFSET_Y + r * CELL_SIZE + CELL_SIZE/2,
                        text: "â˜…",
                        life: 40,
                        maxLife: 40,
                        color: "#FFF",
                        scale: 1.0
                    });
                }
            }
        }
        
        isSelectingStar = false;
        if(removed) {
            currentChain = 0;
            // ãƒªãƒ•ã‚£ãƒ«ã‚’å‘¼ã°ãšã«çµ‚äº†
        }
    }

    function checkStageClear() {
        if(score >= nextStageScore) {
            currentStage++;
            // ä¿®æ­£ï¼š1ã¤å‰ã®ç›®æ¨™ã®0.5å€ã‚’è¶³ã™ï¼ˆ=1.5å€ã«ã™ã‚‹ï¼‰
            nextStageScore = Math.floor(nextStageScore * 1.5);
            stageMonsterRateBonus += 2;
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢è±ªè¯æ¼”å‡º
            setTimeout(() => {
                effects.push({
                    x: BASE_WIDTH / 2,
                    y: BASE_HEIGHT / 2,
                    text: `STAGE ${currentStage-1} CLEAR!!`,
                    life: 180,
                    maxLife: 180,
                    color: "#FFEB3B", // é»„è‰²
                    subText: "ğŸ‘‘",
                    isBig: true
                });
            }, 1000); // ã‚¹ã‚³ã‚¢è¡¨ç¤ºå¾Œãã‚‰ã„ã«å‡ºã™
        }
    }

    function processRefill() {
        // å‡ºç¾ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼Xã®è¨ˆç®—
        let spawnParamX = 0;
        
        // åŸºæœ¬å€¤ã®è¨­å®š
        if(difficulty === 'easy') spawnParamX = 2.5;
        else if(difficulty === 'normal') spawnParamX = 3.0;
        else spawnParamX = 3.5; // hard
        
        // ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œã«ã‚ˆã‚‹å¢—åŠ  (ã‚¹ãƒ†ãƒ¼ã‚¸1ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆãªã®ã§ -1 ã—ã¦ã‹ã‚‰ 0.1 ã‚’æ›ã‘ã‚‹)
        spawnParamX += (currentStage - 1) * 0.1;
        
        // ç¢ºå®šæ•°ï¼ˆæ•´æ•°éƒ¨åˆ†ï¼‰
        let count = Math.floor(spawnParamX);
        
        // ç¢ºç‡å¤‰å‹•ï¼ˆå°æ•°éƒ¨åˆ†ï¼‰
        let probability = spawnParamX - count;
        
        // ç¢ºç‡åˆ¤å®š
        if(Math.random() < probability) {
            count++;
        }
        
        spawnNumbers(count, false);
        
        // å‡ºç¾ç›´å¾Œã«ãƒãƒƒãƒã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆé€£é–åˆ¤å®šã€ãƒ©ã‚¤ãƒ•æ¶ˆè²»ãªã—ï¼‰
        resolveMatches(false);
    }
    
    function checkGameOver() {
        let full = true;
        for(let r=0; r<GRID_ROWS; r++) {
            for(let c=0; c<GRID_COLS; c++) {
                if(!grid[r][c]) full = false;
            }
        }
        if(full) {
            currentState = STATE.GAME_OVER;
            saveScore();
        }
    }
    
    function update() {
        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
        for(let i = effects.length - 1; i >= 0; i--) {
            effects[i].life--;
            // ä¿®æ­£ï¼šå‹•ãã‚’ãªã‚ã‚‰ã‹ã«ï¼ˆ0.2ã‹ã‚‰0.6ã¸é€Ÿåº¦ã‚¢ãƒƒãƒ—ï¼‰
            effects[i].y -= 0.6; 
            if(effects[i].life <= 0) {
                effects.splice(i, 1);
            }
        }

        if (currentState === STATE.ANIMATING) {
            const now = performance.now();
            if (matchGroupsQueue.length > 0) {
                if (now - animationTimer > 300) {
                    const group = matchGroupsQueue.shift();
                    applyScoreAndRemove(group);
                    animationTimer = now;
                    
                    if (matchGroupsQueue.length === 0) {
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã€ãƒªãƒ•ã‚£ãƒ«ã¸ï¼ˆé€£é–ä¸­ãªã‚‰å†åº¦resolveMatchesãŒå‘¼ã°ã‚Œã‚‹ã“ã¨ã«ãªã‚‹ï¼‰
                        setTimeout(() => {
                            currentState = STATE.PLAYING;
                            processRefill();
                        }, 100);
                    }
                }
            }
        }
    }
    
    function applyScoreAndRemove(group) {
        let uniqueGroup = [];
        let seen = new Set();
        group.forEach(pos => {
            let key = `${pos.r},${pos.c}`;
            if(!seen.has(key)) {
                seen.add(key);
                uniqueGroup.push(pos);
            }
        });
        uniqueGroup.forEach(pos => {
            if(grid[pos.r][pos.c]) grid[pos.r][pos.c] = null;
        });
    }
    
    // ------------------ æç”» ------------------
    
    function draw() {
        ctx.fillStyle = "#FFF8E1";
        ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        
        switch(currentState) {
            case STATE.TITLE: drawTitle(); break;
            case STATE.PLAYER_SELECT: drawPlayerSelect(); break;
            case STATE.DIFFICULTY_SELECT: drawDifficultySelect(); break;
            case STATE.PLAYING:
            case STATE.ANIMATING:
            case STATE.GAME_OVER:
                drawGame();
                if(currentState === STATE.GAME_OVER) drawGameOver();
                break;
            case STATE.RANKING: drawRanking(); break;
        }
    }
    
    function drawTitle() {
        if (bgImage.complete && bgImage.naturalWidth !== 0) {
            ctx.drawImage(bgImage, 0, 0, BASE_WIDTH, BASE_HEIGHT);
            // ä¿®æ­£ï¼šã¼ã‹ã—ï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼‰ã‚’å‰Šé™¤
        } else {
            ctx.fillStyle = "#FFF3E0";
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        }
        
        ctx.fillStyle = "#FF6F00";
        // ä¿®æ­£ï¼šã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´ã€ŒãŸã™ã¦ã‚“ã€
        ctx.font = "bold 150px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.fillText("ãŸã™ã¦ã‚“", BASE_WIDTH/2, 200);
        
        ctx.fillStyle = "#5D4037";
        // ä¿®æ­£ï¼šã‚µãƒ–ã‚¿ã‚¤ãƒˆãƒ«å¤‰æ›´ã€Œï½Let's make 10ï½ã€
        ctx.font = "bold 50px 'M PLUS Rounded 1c'";
        ctx.fillText("ï½Let's make 10ï½", BASE_WIDTH/2, 280);

        const startY = 380;
        const gap = 80;
        
        // ä¿®æ­£ï¼šãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼åã‚’è¡¨ç¤ºï¼ˆã¯ã˜ã‚ã‚‹ãƒœã‚¿ãƒ³ã®ä¸Šï¼‰
        ctx.fillStyle = "#3E2723";
        ctx.font = "800 36px 'M PLUS Rounded 1c'"; // å¤ªãã€å¤§ãã
        let pname = currentPlayerIndex >= 0 ? players[currentPlayerIndex] : "æœªé¸æŠ";
        ctx.fillText("ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼: " + pname, BASE_WIDTH/2, startY - 20);

        const buttons = [
            { text: "ã¯ã˜ã‚ã‚‹", y: startY, action: "start", color: "#FF9800" },
            { text: "ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã›ã‚“ãŸã", y: startY + gap, action: "player", color: "#8D6E63" },
            { text: "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ" + (window.currentUser ? "" : "(Googleãƒ­ã‚°ã‚¤ãƒ³)"), y: startY + gap*2, action: "login", color: "#4285F4" },
            { text: "ãƒ©ãƒ³ã‚­ãƒ³ã‚°", y: startY + gap*3, action: "ranking", color: "#7CB342" },
            { text: "INDEXã¸", y: startY + gap*4, action: "index", color: "#9E9E9E" }
        ];
        
        buttons.forEach(btn => {
            let t = btn.text;
            if(btn.action === "login") t = window.currentUser ? "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ" : "Googleã§ãƒ­ã‚°ã‚¤ãƒ³";
            drawButton(BASE_WIDTH/2, btn.y, 320, 60, t, btn.color);
        });
    }
    
    function drawPlayerSelect() {
        if (bgImage.complete && bgImage.naturalWidth !== 0) {
            ctx.drawImage(bgImage, 0, 0, BASE_WIDTH, BASE_HEIGHT);
            ctx.fillStyle = "rgba(255, 243, 224, 0.9)"; 
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        } else {
            ctx.fillStyle = "#FFF3E0";
            ctx.fillRect(0,0,BASE_WIDTH, BASE_HEIGHT);
        }
        
        ctx.fillStyle = "#5D4037";
        ctx.font = "bold 50px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.fillText("ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’ãˆã‚‰ã‚“ã§ã­", BASE_WIDTH/2, 100);
        
        players.forEach((p, i) => {
            let y = 180 + i * 80;
            let isSelected = (i === currentPlayerIndex);
            drawButton(BASE_WIDTH/2, y, 400, 60, p, isSelected ? "#7CB342" : "#fff", isSelected ? "#fff" : "#5D4037");
            drawButton(BASE_WIDTH/2 + 250, y, 60, 60, "Ã—", "#E57373");
        });
        
        if(players.length < 5) {
            drawButton(BASE_WIDTH/2, 180 + players.length * 80, 400, 60, "ï¼‹ ã‚ãŸã‚‰ã—ã„ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼", "#FFB74D", "#5D4037");
        }
        drawButton(BASE_WIDTH/2, 650, 200, 50, "ã‚‚ã©ã‚‹", "#B0BEC5");
    }

    function drawDifficultySelect() {
        if (bgImage.complete && bgImage.naturalWidth !== 0) {
            ctx.drawImage(bgImage, 0, 0, BASE_WIDTH, BASE_HEIGHT);
            ctx.fillStyle = "rgba(78, 52, 46, 0.7)"; 
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        } else {
            ctx.fillStyle = "rgba(78, 52, 46, 0.8)";
            ctx.fillRect(0,0,BASE_WIDTH, BASE_HEIGHT);
        }
        
        ctx.fillStyle = "#fff";
        ctx.font = "bold 50px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.fillText("ãªã‚“ã„ã©ã‚’ãˆã‚‰ã‚“ã§ã­", BASE_WIDTH/2, 200);
        
        drawButton(BASE_WIDTH/2, 300, 300, 70, "ã‚„ã•ã—ã„", "#AED581", "#33691E");
        drawButton(BASE_WIDTH/2, 400, 300, 70, "ãµã¤ã†", "#FFB74D", "#E65100");
        drawButton(BASE_WIDTH/2, 500, 300, 70, "ã‚€ãšã‹ã—ã„", "#E57373", "#B71C1C");
        drawButton(BASE_WIDTH/2, 620, 200, 50, "ã‚„ã‚ã‚‹", "#B0BEC5");
    }
    
    function drawGame() {
        // ã‚®ãƒªã‚®ãƒªæ¼”å‡º
        let emptyCount = 0;
        for(let r=0; r<GRID_ROWS; r++) {
            for(let c=0; c<GRID_COLS; c++) {
                if(!grid[r][c]) emptyCount++;
            }
        }
        if (emptyCount <= 3 && currentState === STATE.PLAYING) {
            let alpha = 0.3 + 0.2 * Math.sin(Date.now() / 150);
            ctx.lineWidth = 15;
            ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
            ctx.strokeRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        }

        // å·¦å´ï¼šéŠã³æ–¹
        ctx.fillStyle = "#D7CCC8";
        ctx.fillRect(0, 0, 300, BASE_HEIGHT);
        
        ctx.fillStyle = "#5D4037";
        ctx.font = "800 36px 'M PLUS Rounded 1c'"; // ä¿®æ­£ï¼šå¤ªã
        ctx.textAlign = "center";
        ctx.fillText("ã‚ãã³ã‹ãŸ", 150, 60);

        ctx.font = "bold 22px 'M PLUS Rounded 1c'"; // ä¿®æ­£ï¼šå¤§ããå¤ªã
        ctx.textAlign = "left";
        const helpText = [
            "ãŸã¦ ã‹ ã‚ˆã“ ã§", "ï¼‘ï¼ ã‚’ã¤ãã‚ã†ã€‚", "ï¼‘ï¼ãŒã§ãã‚‹ã¨", "ããˆã‚‹ã‚ˆã€‚", "",
            "é€£ç¶šã§æ¶ˆã—ã¦", "ã‚³ãƒ³ãƒœã‚’ç‹™ãŠã†ï¼", "",
            "ğŸ‘¾ã¯ãŠã˜ã‚ƒã¾", "ã¾ã‚ã‚Šã‚’ã‘ã™ã¨", "ããˆã‚‹ã‚ˆã€‚", "",
            "ğŸŒ ã¯ã™ã”ã„ã‚¢ã‚¤ãƒ†ãƒ ", "ã¾ã‚ã‚Šã‚’æ¶ˆã—ã¦", "ã‚¹ãƒˆãƒƒã‚¯ã—ã‚ˆã†ï¼", "",
            "ğŸª™ğŸ’°ã¯ãƒœãƒ¼ãƒŠã‚¹", "1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§", "ã™ãã«ããˆã‚‹ã‚ˆï¼"
        ];
        let helpY = 120;
        helpText.forEach(line => {
            ctx.fillText(line, 20, helpY);
            helpY += 28;
        });

        // å³å´ï¼šæƒ…å ±è¡¨ç¤º
        ctx.fillStyle = "#EFEBE9";
        ctx.fillRect(980, 0, 300, BASE_HEIGHT);

        ctx.textAlign = "center";
        
        ctx.fillStyle = "#5D4037";
        ctx.font = "bold 24px 'M PLUS Rounded 1c'";
        let pname = currentPlayerIndex >= 0 ? players[currentPlayerIndex] : "ã‚²ã‚¹ãƒˆ";
        ctx.fillText(pname, 1130, 60);

        ctx.fillStyle = "#E65100";
        ctx.font = "bold 36px 'M PLUS Rounded 1c'";
        ctx.fillText("STAGE " + currentStage, 1130, 110);

        ctx.fillStyle = "#5D4037";
        ctx.font = "bold 30px 'M PLUS Rounded 1c'";
        ctx.fillText("SCORE", 1130, 160);

        ctx.fillStyle = "#D81B60"; 
        ctx.font = "800 60px 'M PLUS Rounded 1c'";
        ctx.fillText(score, 1130, 220);

        // æ¬¡ã®ç›®æ¨™ï¼ˆå¼·èª¿ï¼‰
        ctx.fillStyle = "#5D4037";
        ctx.font = "bold 24px 'M PLUS Rounded 1c'";
        ctx.fillText("ã¤ãã®ç›®æ¨™", 1130, 280);
        ctx.fillStyle = "#D32F2F"; // èµ¤è‰²ã§å¼·èª¿
        ctx.font = "800 40px 'M PLUS Rounded 1c'";
        ctx.fillText(nextStageScore, 1130, 330);
        
        // ã‚¢ã‚¤ãƒ†ãƒ è¡¨ç¤º
        ctx.fillStyle = "#5D4037";
        ctx.font = "bold 24px 'M PLUS Rounded 1c'";
        ctx.fillText("ã‚¢ã‚¤ãƒ†ãƒ ", 1130, 400);
        
        ctx.fillStyle = "#FFD700";
        ctx.font = "40px sans-serif";
        ctx.fillText("ğŸŒ ", 1080, 440);
        ctx.fillStyle = "#333";
        ctx.font = "bold 30px 'M PLUS Rounded 1c'";
        ctx.fillText("x " + starStock, 1130, 440);
        
        // ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨ãƒœã‚¿ãƒ³
        if(starStock > 0 && !isSelectingStar) {
            drawButton(1130, 490, 160, 50, "ã¤ã‹ã†", "#FFC107", "#5D4037");
        } else if (isSelectingStar) {
            ctx.fillStyle = "#FF9800";
            ctx.font = "bold 20px 'M PLUS Rounded 1c'";
            ctx.fillText("ã™ã†ã˜ã‚’ãˆã‚‰ã‚“ã§ã­", 1130, 490);
        } else {
            // ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆé¢¨
            ctx.fillStyle = "#BDBDBD";
            roundRect(ctx, 1130-80, 490-25, 160, 50, 10, true, false);
            ctx.fillStyle = "#757575";
            ctx.font = "bold 24px 'M PLUS Rounded 1c'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("ã¤ã‹ã†", 1130, 490);
        }

        ctx.fillStyle = "#5D4037";
        ctx.textBaseline = "alphabetic"; // æˆ»ã™
        ctx.font = "bold 20px 'M PLUS Rounded 1c'";
        ctx.fillText("ã‚¿ãƒ¼ãƒ³: " + turnCount, 1130, 560);

        let diffText = difficulty === 'easy' ? 'ã‚„ã•ã—ã„' : difficulty === 'normal' ? 'ãµã¤ã†' : 'ã‚€ãšã‹ã—ã„';
        ctx.fillText("é›£æ˜“åº¦: " + diffText, 1130, 600);

        drawButton(1130, 660, 220, 50, "ã‚¿ã‚¤ãƒˆãƒ«ã¸", "#B0BEC5");

        // ä¸­å¤®ï¼šã‚°ãƒªãƒƒãƒ‰
        ctx.fillStyle = "#FFFFFF"; 
        ctx.fillRect(GRID_OFFSET_X - 10, GRID_OFFSET_Y - 10, CELL_SIZE * GRID_COLS + 20, CELL_SIZE * GRID_ROWS + 20);
        
        for(let r=0; r<GRID_ROWS; r++) {
            for(let c=0; c<GRID_COLS; c++) {
                let x = GRID_OFFSET_X + c * CELL_SIZE;
                let y = GRID_OFFSET_Y + r * CELL_SIZE;
                
                ctx.strokeStyle = "#EEE";
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, CELL_SIZE, CELL_SIZE);
                
                let cell = grid[r][c];
                
                if (currentState === STATE.ANIMATING && matchGroupsQueue.length > 0) {
                    let currentGroup = matchGroupsQueue[0];
                    let isHighlighted = currentGroup.some(p => p.r === r && p.c === c);
                    if(isHighlighted) {
                        ctx.fillStyle = "rgba(255, 167, 38, 0.5)";
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        ctx.lineWidth = 5;
                        ctx.strokeStyle = "#FF9800";
                        ctx.strokeRect(x+2, y+2, CELL_SIZE-4, CELL_SIZE-4);
                    }
                }

                if (cell) {
                    if(isDragging && selectedCell && selectedCell.r === r && selectedCell.c === c) continue;
                    drawCellContent(x, y, cell);
                }
            }
        }
        
        if(isDragging && selectedCell) {
            let cell = grid[selectedCell.r][selectedCell.c];
            if(cell) {
                drawCellContent(inputState.x - CELL_SIZE/2, inputState.y - CELL_SIZE/2, cell, true);
            }
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ é¸æŠã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
        if(isSelectingStar) {
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(0,0, BASE_WIDTH, BASE_HEIGHT);
            
            ctx.fillStyle = "#FFF";
            roundRect(ctx, BASE_WIDTH/2 - 200, BASE_HEIGHT/2 - 250, 400, 500, 20, true, false);
            
            ctx.fillStyle = "#5D4037";
            ctx.font = "bold 30px 'M PLUS Rounded 1c'";
            ctx.textAlign = "center";
            ctx.fillText("ã‘ã™ ã™ã†ã˜ ã‚’ãˆã‚‰ã‚“ã§ã­", BASE_WIDTH/2, BASE_HEIGHT/2 - 200);
            
            for(let i=1; i<=9; i++) {
                let r = Math.floor((i-1)/3);
                let c = (i-1)%3;
                let btnX = BASE_WIDTH/2 - 100 + c * 100;
                let btnY = BASE_HEIGHT/2 - 120 + r * 100;
                
                drawButton(btnX, btnY, 80, 80, i, NUMBER_BG_COLORS[i-1]);
            }
            
            drawButton(BASE_WIDTH/2, BASE_HEIGHT/2 + 180, 150, 50, "ã‚„ã‚ã‚‹", "#B0BEC5");
        }
        
        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæç”»
        effects.forEach(ef => {
            ctx.save();
            ctx.globalAlpha = Math.min(1, ef.life / 20); // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ãªã©ã®å¤§æ¼”å‡º
            if (ef.isBig) {
                ctx.fillStyle = "rgba(0,0,0,0.7)"; // èƒŒæ™¯æš—è»¢
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                ctx.globalAlpha = 1;
                
                ctx.shadowColor = "black";
                ctx.shadowBlur = 20;
                ctx.font = "900 80px 'M PLUS Rounded 1c'";
                ctx.fillStyle = ef.color;
                ctx.textAlign = "center";
                ctx.fillText(ef.text, ef.x, ef.y);
                
                if(ef.subText) {
                    ctx.font = "100px sans-serif";
                    ctx.fillText(ef.subText, ef.x, ef.y - 100);
                }
            } else {
                // é€šå¸¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                let scale = ef.scale || 1.0;
                ctx.translate(ef.x, ef.y);
                ctx.scale(scale, scale);
                
                ctx.font = "bold 60px 'M PLUS Rounded 1c'";
                ctx.textAlign = "center";
                
                // ç¸å–ã‚Šï¼ˆè¦–èªæ€§å‘ä¸Šï¼‰
                if (ef.stroke) {
                    ctx.strokeStyle = ef.stroke;
                    ctx.lineWidth = 4;
                    ctx.strokeText(ef.text, 0, 0);
                } else {
                    // æŒ‡å®šãŒãªã„å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç¸å–ã‚Š
                    ctx.strokeStyle = "rgba(0,0,0,0.5)";
                    ctx.lineWidth = 4;
                    ctx.strokeText(ef.text, 0, 0);
                }
                
                ctx.fillStyle = ef.color || "#D84315";
                ctx.fillText(ef.text, 0, 0);
            }
            ctx.restore();
        });
    }
    
    function drawCellContent(x, y, cell, shadow=false) {
        if(cell.type === 'monster' || cell.type === 'coin' || cell.type === 'bag' || cell.type === 'star') {
            ctx.fillStyle = "#FFFFFF";
        } else {
            ctx.fillStyle = NUMBER_BG_COLORS[cell.val - 1] || "#333";
        }
        
        if(shadow) {
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.shadowBlur = 10;
        } else {
            ctx.shadowBlur = 0;
        }
        
        roundRect(ctx, x+5, y+5, CELL_SIZE-10, CELL_SIZE-10, 15, true, false);
        ctx.shadowBlur = 0;
        
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        if (cell.type === 'monster') {
            ctx.font = "80px sans-serif";
            ctx.fillText("ğŸ‘¾", x + CELL_SIZE/2, y + CELL_SIZE/2);
        } else if (cell.type === 'coin') {
            ctx.font = "80px sans-serif";
            ctx.fillText("ğŸª™", x + CELL_SIZE/2, y + CELL_SIZE/2);
        } else if (cell.type === 'bag') {
            ctx.font = "80px sans-serif";
            ctx.fillText("ğŸ’°", x + CELL_SIZE/2, y + CELL_SIZE/2);
        } else if (cell.type === 'star') {
            ctx.font = "80px sans-serif";
            ctx.fillText("ğŸŒ ", x + CELL_SIZE/2, y + CELL_SIZE/2);
        } else {
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "bold 65px 'M PLUS Rounded 1c'";
            ctx.fillText(cell.val, x + CELL_SIZE/2, y + CELL_SIZE/2 + 5);
        }
    }
    
    function drawGameOver() {
        ctx.fillStyle = "rgba(78, 52, 46, 0.9)";
        ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        
        ctx.fillStyle = "#fff";
        ctx.font = "bold 80px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.fillText("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼", BASE_WIDTH/2, 250);
        
        ctx.font = "bold 50px 'M PLUS Rounded 1c'";
        ctx.fillText("ã‚¹ã‚³ã‚¢: " + score, BASE_WIDTH/2, 350);
        ctx.fillText("åˆ°é”ã‚¹ãƒ†ãƒ¼ã‚¸: " + currentStage, BASE_WIDTH/2, 420);
        
        drawButton(BASE_WIDTH/2, 550, 300, 60, "ã‚¿ã‚¤ãƒˆãƒ«ã¸", "#FF9800");
    }
    
    function drawRanking() {
        if (bgImage.complete && bgImage.naturalWidth !== 0) {
            ctx.drawImage(bgImage, 0, 0, BASE_WIDTH, BASE_HEIGHT);
            ctx.fillStyle = "rgba(255, 243, 224, 0.9)"; 
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        } else {
            ctx.fillStyle = "#FFF3E0";
            ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
        }
        
        ctx.fillStyle = "#5D4037";
        ctx.font = "bold 50px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.fillText("ãƒ©ãƒ³ã‚­ãƒ³ã‚° (TOP 10)", BASE_WIDTH/2, 70);
        
        const scopeY = 120;
        drawButton(BASE_WIDTH/2 - 150, scopeY, 280, 45, "ãƒ­ãƒ¼ã‚«ãƒ«", rankingScope==='local' ? "#8D6E63" : "#E0E0E0", rankingScope==='local' ? "#FFF" : "#9E9E9E");
        drawButton(BASE_WIDTH/2 + 150, scopeY, 280, 45, "ãƒ¯ãƒ¼ãƒ«ãƒ‰ (ãƒãƒƒãƒˆ)", rankingScope==='world' ? "#4285F4" : "#E0E0E0", rankingScope==='world' ? "#FFF" : "#9E9E9E");

        const tabY = 180;
        const tabW = 200;
        const tabH = 50;
        
        drawButton(BASE_WIDTH/2 - 220, tabY, tabW, tabH, "ã‚„ã•ã—ã„", rankingTab==='easy' ? "#AED581" : "#E0E0E0", rankingTab==='easy' ? "#33691E" : "#9E9E9E");
        drawButton(BASE_WIDTH/2, tabY, tabW, tabH, "ãµã¤ã†", rankingTab==='normal' ? "#FFB74D" : "#E0E0E0", rankingTab==='normal' ? "#E65100" : "#9E9E9E");
        drawButton(BASE_WIDTH/2 + 220, tabY, tabW, tabH, "ã‚€ãšã‹ã—ã„", rankingTab==='hard' ? "#E57373" : "#E0E0E0", rankingTab==='hard' ? "#B71C1C" : "#9E9E9E");

        ctx.font = "28px 'M PLUS Rounded 1c'";
        ctx.textAlign = "left";
        let startY = 250;
        
        if(rankingData.length === 0) {
            ctx.fillStyle = "#5D4037";
            ctx.textAlign = "center";
            let msg = "ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“";
            if(rankingScope === 'world') msg = "èª­ã¿è¾¼ã¿ä¸­ ã¾ãŸã¯ ãƒ‡ãƒ¼ã‚¿ãªã—";
            ctx.fillText(msg, BASE_WIDTH/2, 350);
        } else {
            rankingData.forEach((d, i) => {
                ctx.fillStyle = i < 3 ? "#E65100" : "#5D4037";
                ctx.textAlign = "left";
                ctx.fillText(`${i+1}. ${d.name}`, 300, startY + i*45);
                ctx.textAlign = "right";
                ctx.fillText(`${d.score} ç‚¹`, 980, startY + i*45);
            });
        }
        drawButton(BASE_WIDTH/2, 650, 200, 50, "ã‚‚ã©ã‚‹", "#B0BEC5");
    }
    
    function drawButton(x, y, w, h, text, color, textColor="#fff") {
        ctx.save();
        ctx.translate(x - w/2, y - h/2);
        ctx.fillStyle = color;
        roundRect(ctx, 0, 0, w, h, 10, true, false);
        ctx.fillStyle = textColor;
        ctx.font = "bold 24px 'M PLUS Rounded 1c'";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, w/2, h/2);
        ctx.restore();
    }
    
    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
    }
    
    // ------------------ å…¥åŠ›å‡¦ç† ------------------
    
    function handleInputStart(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        inputState.x = ( (e.clientX || e.pageX) - rect.left) * scaleX;
        inputState.y = ( (e.clientY || e.pageY) - rect.top) * scaleY;
        inputState.isDown = true;
        
        if(currentState === STATE.TITLE) checkTitleClick(inputState.x, inputState.y);
        else if(currentState === STATE.PLAYER_SELECT) checkPlayerSelectClick(inputState.x, inputState.y);
        else if(currentState === STATE.DIFFICULTY_SELECT) checkDifficultyClick(inputState.x, inputState.y);
        else if(currentState === STATE.PLAYING) checkGameClick(inputState.x, inputState.y);
        else if(currentState === STATE.GAME_OVER) checkGameOverClick(inputState.x, inputState.y);
        else if(currentState === STATE.RANKING) checkRankingClick(inputState.x, inputState.y);
    }
    
    function handleInputMove(e) {
        if(!inputState.isDown) return;
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        inputState.x = ( (e.clientX || e.pageX) - rect.left) * scaleX;
        inputState.y = ( (e.clientY || e.pageY) - rect.top) * scaleY;
        if(currentState === STATE.PLAYING && selectedCell) isDragging = true;
    }
    
    function handleInputEnd(e) {
        inputState.isDown = false;
        if(currentState === STATE.PLAYING && isDragging && selectedCell) {
            let c = Math.floor((inputState.x - GRID_OFFSET_X) / CELL_SIZE);
            let r = Math.floor((inputState.y - GRID_OFFSET_Y) / CELL_SIZE);
            if(r >= 0 && r < GRID_ROWS && c >= 0 && c < GRID_COLS) {
                if(!grid[r][c]) {
                    grid[r][c] = grid[selectedCell.r][selectedCell.c];
                    grid[selectedCell.r][selectedCell.c] = null;
                    // ç§»å‹•å®Œäº†ï¼šã‚³ãƒ³ãƒœã‚«ã‚¦ãƒ³ãƒˆãƒªã‚»ãƒƒãƒˆã—ã¦ãƒãƒƒãƒåˆ¤å®šã¸
                    currentChain = 0;
                    resolveMatches(true); // true = ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œãªã®ã§ãƒ©ã‚¤ãƒ•æ¶ˆè²»ã‚ã‚Š
                }
            }
        }
        selectedCell = null;
        isDragging = false;
    }
    
    function isBtnClicked(mx, my, x, y, w, h) {
        return mx >= x - w/2 && mx <= x + w/2 && my >= y - h/2 && my <= y + h/2;
    }
    
    function checkTitleClick(x, y) {
        const startY = 380;
        const gap = 80;
        if(isBtnClicked(x, y, BASE_WIDTH/2, startY, 320, 60)) {
            if(currentPlayerIndex === -1) alert("ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã‚’é¸æŠã—ã¦ã­");
            else currentState = STATE.DIFFICULTY_SELECT;
        }
        else if(isBtnClicked(x, y, BASE_WIDTH/2, startY+gap, 320, 60)) currentState = STATE.PLAYER_SELECT;
        else if(isBtnClicked(x, y, BASE_WIDTH/2, startY+gap*2, 320, 60)) {
            if(window.handleGoogleAuth) window.handleGoogleAuth();
            else alert("èª­ã¿è¾¼ã¿ä¸­...");
        }
        else if(isBtnClicked(x, y, BASE_WIDTH/2, startY+gap*3, 320, 60)) {
            rankingScope = 'local'; rankingTab = 'easy'; updateRankingView(); currentState = STATE.RANKING;
        }
        else if(isBtnClicked(x, y, BASE_WIDTH/2, startY+gap*4, 320, 60)) window.location.href = '../index.html';
    }
    
    function checkPlayerSelectClick(x, y) {
        if(isBtnClicked(x, y, BASE_WIDTH/2, 650, 200, 50)) { currentState = STATE.TITLE; return; }
        for(let i=0; i<players.length; i++) {
            let by = 180 + i * 80;
            if(isBtnClicked(x, y, BASE_WIDTH/2, by, 400, 60)) { currentPlayerIndex = i; localStorage.setItem('tasuten_last_player', i); }
            if(isBtnClicked(x, y, BASE_WIDTH/2 + 250, by, 60, 60)) {
                players.splice(i, 1);
                if(currentPlayerIndex === i) currentPlayerIndex = -1;
                else if(currentPlayerIndex > i) currentPlayerIndex--;
                savePlayers();
                return;
            }
        }
        if(players.length < 5) {
            let by = 180 + players.length * 80;
            if(isBtnClicked(x, y, BASE_WIDTH/2, by, 400, 60)) {
                document.getElementById('playerInputOverlay').style.display = 'flex';
                document.getElementById('inputError').innerText = "";
                document.getElementById('playerNameInput').value = "";
            }
        }
    }
    
    function checkDifficultyClick(x, y) {
        if(isBtnClicked(x, y, BASE_WIDTH/2, 300, 300, 70)) startNewGame('easy');
        else if(isBtnClicked(x, y, BASE_WIDTH/2, 400, 300, 70)) startNewGame('normal');
        else if(isBtnClicked(x, y, BASE_WIDTH/2, 500, 300, 70)) startNewGame('hard');
        else if(isBtnClicked(x, y, BASE_WIDTH/2, 620, 200, 50)) currentState = STATE.TITLE;
    }
    
    function checkGameClick(x, y) {
        // ã‚¢ã‚¤ãƒ†ãƒ é¸æŠä¸­ã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
        if(isSelectingStar) {
            for(let i=1; i<=9; i++) {
                let r = Math.floor((i-1)/3);
                let c = (i-1)%3;
                let btnX = BASE_WIDTH/2 - 100 + c * 100;
                let btnY = BASE_HEIGHT/2 - 120 + r * 100;
                if(isBtnClicked(x, y, btnX, btnY, 80, 80)) {
                    useStarItem(i);
                }
            }
            // ã‚„ã‚ã‚‹ãƒœã‚¿ãƒ³
            if(isBtnClicked(x, y, BASE_WIDTH/2, BASE_HEIGHT/2 + 180, 150, 50)) {
                isSelectingStar = false;
            }
            return; // é¸æŠä¸­ã¯ç›¤é¢æ“ä½œç„¡åŠ¹
        }

        if(isBtnClicked(x, y, 1130, 660, 220, 50)) {
            if(confirm("ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚Šã¾ã™ã‹ï¼Ÿã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚Šã¾ã™")) {
                currentState = STATE.GAME_OVER; saveScore();
            }
            return;
        }
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãƒœã‚¿ãƒ³
        if(starStock > 0 && isBtnClicked(x, y, 1130, 490, 160, 50)) {
            isSelectingStar = true;
            return;
        }

        let c = Math.floor((x - GRID_OFFSET_X) / CELL_SIZE);
        let r = Math.floor((y - GRID_OFFSET_Y) / CELL_SIZE);
        if(r >= 0 && r < GRID_ROWS && c >= 0 && c < GRID_COLS) {
            if(grid[r][c]) selectedCell = {r, c};
        }
    }
    
    function checkGameOverClick(x, y) {
        if(isBtnClicked(x, y, BASE_WIDTH/2, 550, 300, 60)) currentState = STATE.TITLE;
    }
    
    function checkRankingClick(x, y) {
        if(isBtnClicked(x, y, BASE_WIDTH/2, 650, 200, 50)) { currentState = STATE.TITLE; return; }
        const scopeY = 120;
        if(isBtnClicked(x, y, BASE_WIDTH/2 - 150, scopeY, 280, 45)) { if(rankingScope !== 'local') { rankingScope = 'local'; updateRankingView(); } }
        else if(isBtnClicked(x, y, BASE_WIDTH/2 + 150, scopeY, 280, 45)) { if(rankingScope !== 'world') { rankingScope = 'world'; updateRankingView(); } }
        const tabY = 180;
        if(isBtnClicked(x, y, BASE_WIDTH/2 - 220, tabY, 200, 50)) { if(rankingTab !== 'easy') { rankingTab = 'easy'; updateRankingView(); } }
        else if(isBtnClicked(x, y, BASE_WIDTH/2, tabY, 200, 50)) { if(rankingTab !== 'normal') { rankingTab = 'normal'; updateRankingView(); } }
        else if(isBtnClicked(x, y, BASE_WIDTH/2 + 220, tabY, 200, 50)) { if(rankingTab !== 'hard') { rankingTab = 'hard'; updateRankingView(); } }
    }

    // ------------------ ãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ç®¡ç† ------------------
    
    function loadPlayers() {
        const data = localStorage.getItem('tasuten_players');
        if(data) players = JSON.parse(data);
        const last = localStorage.getItem('tasuten_last_player');
        if(last !== null) { currentPlayerIndex = parseInt(last); if(currentPlayerIndex >= players.length) currentPlayerIndex = -1; }
    }
    
    function savePlayers() {
        localStorage.setItem('tasuten_players', JSON.stringify(players));
        if(currentPlayerIndex >= 0) localStorage.setItem('tasuten_last_player', currentPlayerIndex);
    }
    
    function registerPlayer() {
        const input = document.getElementById('playerNameInput');
        const err = document.getElementById('inputError');
        const name = input.value.trim();
        if(!name) { err.innerText = "ãªã¾ãˆã‚’ã„ã‚Œã¦ã­"; return; }
        if(name.length > 8) { err.innerText = "8ã‚‚ã˜ã„ãªã„ã«ã—ã¦ã­"; return; }
        if(!/^[ã-ã‚“ãƒ¼]+$/.test(name)) { err.innerText = "ã²ã‚‰ãŒãªã ã‘ã§ã„ã‚Œã¦ã­"; return; }
        for(let ng of NG_WORDS_HIRAGANA) { if(name.includes(ng)) { err.innerText = "ã¤ã‹ãˆãªã„ã“ã¨ã°ãŒãµãã¾ã‚Œã¦ã„ã¾ã™"; return; } }
        players.push(name);
        currentPlayerIndex = players.length - 1;
        savePlayers();
        document.getElementById('playerInputOverlay').style.display = 'none';
    }
    
    function closePlayerInput() { document.getElementById('playerInputOverlay').style.display = 'none'; }
    
    // ------------------ ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ»ãƒ©ãƒ³ã‚­ãƒ³ã‚° ------------------
    
    function saveScore() {
        if(currentPlayerIndex === -1) return;
        const playerName = players[currentPlayerIndex];
        const scoreData = { name: playerName, score: score, difficulty: difficulty, stage: currentStage, date: Date.now() };
        let localScores = JSON.parse(localStorage.getItem('tasuten_scores') || "[]");
        localScores.push(scoreData);
        localStorage.setItem('tasuten_scores', JSON.stringify(localScores));
        
        // ä¿®æ­£ï¼šFirebase v9å¯¾å¿œ
        if(window.dbInstance && window.addDoc) {
            window.addDoc(window.collection(window.dbInstance, COLLECTION_NAME), {
                name: playerName, score: score, difficulty: difficulty, stage: currentStage,
                uid: window.currentUser ? window.currentUser.uid : "guest",
                date: window.serverTimestamp()
            }).catch(err => console.error("Score save error", err));
        }
    }
    
    function updateRankingView() {
        rankingData = [];
        if(rankingScope === 'local') fetchLocalRanking(rankingTab);
        else fetchWorldRanking(rankingTab);
    }

    function fetchLocalRanking(diff) {
        let localScores = JSON.parse(localStorage.getItem('tasuten_scores') || "[]");
        rankingData = localScores.filter(d => d.difficulty === diff).sort((a, b) => b.score - a.score).slice(0, 10);
    }
    
    function fetchWorldRanking(diff) {
        if(!window.dbInstance) return;
        
        // ä¿®æ­£ï¼šFirebase v9å¯¾å¿œ & ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç”¨ï¼‰
        const q = window.query(
            window.collection(window.dbInstance, COLLECTION_NAME),
            window.where("difficulty", "==", diff),
            window.orderBy("score", "desc"),
            window.limit(10)
        );

        window.getDocs(q)
            .then(snapshot => {
                rankingData = [];
                snapshot.forEach(doc => rankingData.push(doc.data()));
            })
            .catch(err => {
                console.error("Ranking fetch error", err);
                
                // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã®å ´åˆã®å‡¦ç†ï¼ˆãƒªãƒ³ã‚¯ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤ºï¼‰
                const match = err.message.match(/https:\/\/console\.firebase\.google\.com[^\s]*/);
                if (err.code === 'failed-precondition' || match) {
                    let url = match ? match[0] : '#';
                    const link = document.getElementById('dbErrorLink');
                    link.href = url;
                    document.getElementById('dbErrorOverlay').style.display = 'flex';
                }
            });
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    window.onload = init;
    return { registerPlayer: registerPlayer, closePlayerInput: closePlayerInput };
})();
</script>
</body>
</html>
